#!/bin/sh
exec 1>>/tmp/sound.log
exec 2>&1

#GPIO to control power amplifier
AMP_GPIO=504
AMP_GPIO_HOLD=60

AUDIO_CHANS_IN=2
AUDIO_CHANS_OUT=6
AUDIO_RATE=48000
AUDIO_PERIOD_SZ=64
AUDIO_PERIODS=4

# increase priority of apps by this amount
JACK_PRI=70
APP_PRI=5
IRQ_PRI=95
CIFS_PRI=50

JACKNAME=default
MIXERNAME="SoftMaster"
INIT_VOL="/etc/.soundvolume"
MPD_DIR="/etc/mpd"
MPD_EXT_DIR="/mnt/music/.mpd"
SERVICES="mpd zita-n2j"

AUDIO_BUF_SZ=$((AUDIO_PERIOD_SZ*AUDIO_PERIODS))

SOUND_VAR_DIR="/var/run/sound"
mkdir -p $SOUND_VAR_DIR

thispid=`exec sh -c 'echo $PPID'`
cardname=`head -n1 /proc/asound/cards | awk -F'[' '{print$2}' | awk -F']' '{print$1}' | sed -e 's/[[:space:]]*$//'`
echo "Starting Sound service on soundcard \"$cardname\", pid $thispid"

# SKIP cpu detect if we don't want to assign round robin processes.
N_CPUS=`cat /proc/cpuinfo | awk '/^processor/{print $3}'| wc -l`

# start or stop jack services
service_control(){
	local ctl="stop"
	[ "$1" == "start" ] && ctl="start"
	for srvc in $SERVICES; do
		[ -n "$(pgrep $srvc)" ] && { 
			[ "$ctl" == "start" ] && continue
			:
		} || [ "$ctl" == "start" ] || continue
		echo "$ctl service $srvc"
		/etc/init.d/$srvc $ctl
	done
}

# recursively get list of pids backgrounded from here
getpids() {
	local pids
	pids=$(pgrep -P $1)
	echo -n $pids" "
	for pid in $pids; do getpids $pid; done
}

cleanup() {
	local pids
	service_control stop
	pids=`getpids $thispid 2>/dev/null`
	echo "Killing spawned processes: $pids"
	kill $pids &>/dev/null
	exit
}

trap cleanup SIGINT SIGTERM SIGHUP SIGQUIT

# round robin CPU affinity- supply PID
set_cpu_affinity() {
	[ -n "$N_CPUS" ] && [ $N_CPUS -gt 1 ] || return
	taskset -p "$((0x1<<cpu_offst))" $1
	cpu_offst=$(((cpu_offst+1)%N_CPUS))
}

# critical interrupts- eg USB- this can be a cross platform list
IRQS=
irq_addrs="2184000 2184200"

for addr in $irq_addrs; do IRQS="$IRQS `pgrep $addr`"; done
cpu_offst=0
for irq in $IRQS; do
	chrt -fp $IRQ_PRI $irq
	set_cpu_affinity $irq
done

# pid, exepath
checkpid(){
	local path=`readlink -f $1` && [ "$path" == "$2" ] || return 1
}

ALSA_FORMAT=

# arg 1 is format
# arg 2 is additional option- eg device
# arg 3 is output channels
alsa_test() {
	local achans=$3
	[ -z "$achans" ] && achans=2
	aplay $2 -s50 -f$1 -c$achans -r48000 /dev/zero &
	aplay_pid=$!
	wait $aplay_pid
}

set_asla_format() {
	formats="S32_LE S24_3LE S16_LE"
	for fmt in $formats; do
		ALSA_FORMAT=$fmt
		alsa_test $fmt -Dhw:0 && break
	done
	echo "Card supports up to $ALSA_FORMAT- using this for alsa"
	write_alsa_config
	[ `readlink "/etc/asound.conf" 2>/dev/null` == "/var/run/sound/asound.conf" ] || {
		rm -f /etc/asound.conf 2>/dev/null
		ln -s $SOUND_VAR_DIR/asound.conf /etc/asound.conf
		echo "Created Alsa config symlink"
	}
	echo "setting mixer to $ALSA_FORMAT, $AUDIO_CHANS_OUT channels"
	alsa_test $ALSA_FORMAT -Dduplex $AUDIO_CHANS_OUT
}

write_alsa_config() {
	cat << EOF > $SOUND_VAR_DIR/asound.conf
# Set Default sound card
pcm.snd_card {
   type hw
   card 0
}

# Allow mixing of multiple output streams to this device
pcm.dmixer {
   type dmix
   ipc_key 1024
   slave.pcm "snd_card"
   slave {
      period_time 0
      period_size $AUDIO_PERIOD_SZ
      buffer_size $AUDIO_BUF_SZ
      format $ALSA_FORMAT
      rate $AUDIO_RATE
      channels $AUDIO_CHANS_OUT
   }
}

pcm.softvol {
    type            softvol
    slave {
        pcm         "dmixer"
    }
    control {
        name        "SoftMaster"
        card        0
    }
}

ctl.!default {
	type hw
	card 0
}

ctl.softvol {
	type hw
	card 0
}

ctl.dmixer {
        type hw
        card 0
}

ctl.duplex {
        type hw
        card 0
}

pcm.dsnooper {
   type dsnoop
   ipc_key 1024
   slave.pcm "snd_card"

   slave {
      period_time 0
      period_size $AUDIO_PERIOD_SZ
      buffer_size $AUDIO_BUF_SZ
      format $ALSA_FORMAT
      rate $AUDIO_RATE
      channels $AUDIO_CHANS_IN
   }
}

pcm.duplex {
   type asym
   playback.pcm "softvol"
   capture.pcm "dsnooper"
}

pcm.!default {
   type plug
   slave.pcm "duplex"
}

pcm.jackdsp {
    type jack
    playback_ports {
        0 jconvolver:in.L
        1 jconvolver:in.R
    }
}

pcm.jack {
    type plug
    slave { pcm "jackdsp" }
    hint {
 	description "JACK DSP port"
    }
}

EOF
}

echo "`date` starting sound service"
start=
while true; do
	sleep 1
	checkpid /var/run/sound/jackd /usr/bin/jackd || {
		# soft mixer does not appear straight away...
		# for some reason when jack loads it gets fixed to 100%
		# and cannot be reduced... makes things a tad loud
		# so we trick the mixer into existance, then set it
		# then start jack...
		# and to add to the fun, sometimes aplay plays indefinitely even if
		# we set the duration to 1
		set_asla_format
		
		init_vol=`printf %d $(cat "$INIT_VOL" 2>/dev/null) 2>/dev/null`||init_vol=12
		amixer sset $MIXERNAME $((init_vol*255/100)) || continue
		
		echo "Set mixer $MIXERNAME level to ${init_vol}%... Starting Jack"
		nice -n-$APP_PRI jackd -R -P$JACK_PRI -d alsa -dduplex -r$AUDIO_RATE -zs -s -i$AUDIO_CHANS_IN -o$AUDIO_CHANS_OUT -n$AUDIO_PERIODS -p$AUDIO_PERIOD_SZ &
		jackpid=$!
		echo "started jack on CPU $((1+cpu_offst))"
		set_cpu_affinity $jackpid
		rm /var/run/sound/jackd 2>/dev/null
		ln -s /proc/${jackpid}/exe /var/run/sound/jackd || continue
		start=1
		continue
	}
	
	[ "$start" != "1" ] || \
		jackres=`jack_wait -c -s $JACKNAME 2>/dev/null | tail -n1` && [ "$jackres" == "running" ] || \
		continue
	
	# check if jconvolver running
	checkpid /var/run/sound/jconvolver /usr/bin/jconvolver || {
		echo "Starting convolver"
		nice -n-$APP_PRI jconvolver -s $JACKNAME /root/convolver.jconv &
		convpid=$!
		echo "started jconvolver on CPU $((1+cpu_offst))"
		set_cpu_affinity $convpid
		rm /var/run/sound/jconvolver 2>/dev/null
		ln -s /proc/${convpid}/exe /var/run/sound/jconvolver || continue
		start=2
		continue
	}
	
	# create DSP alias
	[ "$start" != "2" ] || jack_lsp -A | grep dsp || {
		jack_alias jconvolver:in.L dsp.1 && \
			jack_alias jconvolver:in.R dsp.2
		continue
	}
	
	#check that power switch has started
	meterpid=`pgrep jack_meter` || {
		echo "Starting signal monitors"
		jack_meter -p30 -P dsp.1,dsp.2 system:capture_1 system:capture_2 &
		[ -z "$AMP_GPIO" ] || jack_meter -g $AMP_GPIO -p$AMP_GPIO_HOLD jconvolver:Out-1 jconvolver:Out-2 &
		start=3
		continue
	}

	[ "$AUDIO_CHANS_OUT" -gt 2 ] && [ -f "/root/xover.conf" ] && {
		checkpid /var/run/sound/zita-lrx /usr/bin/zita-lrx || {
			nice -n-$APP_PRI /usr/bin/zita-lrx -s $JACKNAME /root/xover.conf &
			xoverpid=$!
			echo "started zita-lrx"
			rm /var/run/sound/zita-lrx  2>/dev/null
			ln -s /proc/${xoverpid}/exe /var/run/sound/zita-lrx  || continue
			start=4
			continue
		}
	}

	# run lirc
	[ "$cardname" != "Pro" ] || {
		lircpid=`pgrep lirc` || {
			echo "Starting lirc"
			mkdir -p /var/run/lirc 2>/dev/null
			[ -f "/usr/bin/sh" ] || ln -s /bin/sh /usr/bin/sh
			lircd --driver=alsa_usb --device=hw:"$cardname"
			start=5
			sleep 2
			continue
		}
		irexecpid=`pgrep irexec` || {
			echo "Starting irexec"
			sh -c "export LIRC_SOCKET_PATH=/var/run/lirc/lircd.socket; irexec -d /etc/lirc/lircrc.conf"
			start=6
			continue
		}
	}

	# run jack event monitor in background- sending output to named pipe. wait for data on the pipe-
	# specifically "Client wifi-n2j registered" type events- which we will use to trigger connects
	# dbus-monitor --monitor  "type=signal,path=/org/jackaudio/Controller,interface='org.jackaudio.JackPatchbay',member=PortAppeared"
	[ -n "$start" ] && {
		echo "Started audio ($start) jackd($jackpid) jconvolver($convpid) n2j($zitapid)"
		[ -f "/root/alsa.init" ] && alsactl --file /root/alsa.init restore
		start=
		
		# connect crossover
		[ -z "$xoverpid" ] || {
			jack_connect jconvolver:Out-1 zita-lrx:inp-1
			jack_connect jconvolver:Out-2 zita-lrx:inp-2
			echo "Connected crossover inputs"
		}

		mount -a
		for cifspid in $(pgrep cifs); do chrt -fp $CIFS_PRI $cifspid; done

		[ -f ${MPD_DIR}/database ] || ln -s ${MPD_EXT_DIR}/database ${MPD_DIR}/database
		[ -d ${MPD_DIR}/playlists ] || ln -s ${MPD_EXT_DIR}/playlists ${MPD_DIR}/playlists
		
		service_control start
	}
	sleep 3
done;
