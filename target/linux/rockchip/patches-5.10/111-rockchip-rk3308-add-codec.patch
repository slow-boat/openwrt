Index: linux-5.10.27/arch/arm64/boot/dts/rockchip/rk3308-rock-pi-s.dts
===================================================================
--- linux-5.10.27.orig/arch/arm64/boot/dts/rockchip/rk3308-rock-pi-s.dts
+++ linux-5.10.27/arch/arm64/boot/dts/rockchip/rk3308-rock-pi-s.dts
@@ -15,6 +15,11 @@
 		stdout-path = "serial0:1500000n8";
 	};
 
+	dummy_codec: dummy-codec {
+		compatible = "rockchip,dummy-codec";
+		#sound-dai-cells = <0>;
+	};
+
 	leds {
 		compatible = "gpio-leds";
 		pinctrl-names = "default";
@@ -136,6 +141,19 @@
 			  3300000 0x1>;
 		vin-supply = <&vcc_io>;
 	};
+
+	acodec_sound: acodec-sound {
+		compatible = "rockchip,multicodecs-card";
+		rockchip,card-name = "rockchip,rk3308-acodec";
+		rockchip,codec-hp-det;
+		rockchip,mclk-fs = <256>;
+		rockchip,cpu = <&i2s_8ch_2>;
+		rockchip,codec = <&acodec>;
+	};
+};
+
+&acodec {
+	status = "okay";
 };
 
 &cpu0 {
@@ -156,6 +174,11 @@
 	status = "okay";
 };
 
+&i2s_8ch_2 {
+	status = "okay";
+	#sound-dai-cells = <0>;
+};
+
 &mac {
 	assigned-clocks = <&cru SCLK_MAC>;
 	assigned-clock-parents = <&cru SCLK_MAC_SRC>;
@@ -189,8 +212,8 @@
 };
 
 &pwm0 {
-	status = "okay";
 	pinctrl-0 = <&pwm0_pin_pull_down>;
+	status = "okay";
 };
 
 &saradc {
@@ -216,6 +239,26 @@
 	max-freq = <10000000>;
 };
 
+&tsadc {
+	rockchip,hw-tshut-mode = <0>;		/* 0:CRU */
+	rockchip,hw-tshut-polarity = <1>;	/* 1:HIGH */
+	status = "okay";
+};
+
+&u2phy {
+	status = "okay";
+
+	u2phy_host: host-port {
+		phy-supply = <&vcc5v0_otg>;
+		status = "okay";
+	};
+
+	u2phy_otg: otg-port {
+		vbus-supply = <&vcc5v0_otg>;
+		status = "okay";
+	};
+};
+
 &uart0 {
 	status = "okay";
 	pinctrl-names = "default";
@@ -223,7 +266,7 @@
 };
 
 &usb20_otg {
-	dr_mode = "host";
+	dr_mode = "otg";
 	status = "okay";
 };
 
@@ -234,3 +277,7 @@
 &usb_host0_ohci{
 	status = "okay";
 };
+
+&wdt {
+	status = "okay";
+};
Index: linux-5.10.27/sound/soc/codecs/rk3308_codec.c
===================================================================
--- /dev/null
+++ linux-5.10.27/sound/soc/codecs/rk3308_codec.c
@@ -0,0 +1,5174 @@
+/*
+ * rk3308_codec.c -- RK3308 ALSA Soc Audio Driver
+ *
+ * Copyright (c) 2018, Fuzhou Rockchip Electronics Co., Ltd All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/reset.h>
+// #include <linux/rockchip/grf.h>
+#include <linux/version.h>
+#include <sound/core.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/initval.h>
+#include <sound/jack.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/simple_card.h>
+#include <sound/soc.h>
+#include <sound/tlv.h>
+
+#include "rk3308_codec.h"
+#include "rk3308_codec_provider.h"
+
+#if defined(CONFIG_DEBUG_FS)
+#include <linux/fs.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#endif
+
+#define CODEC_DRV_NAME			"rk3308-acodec"
+
+#define ADC_GRP_SKIP_MAGIC		0x1001
+#define ADC_LR_GROUP_MAX		4
+#define ADC_STABLE_MS			200
+#define DEBUG_POP_ALWAYS		0
+#define HPDET_POLL_MS			2000
+#define NOT_USED			255
+#define LOOPBACK_HANDLE_MS		100
+#define PA_DRV_MS		        5
+
+#define GRF_SOC_CON1			0x304
+#define GRF_CHIP_ID			0x800
+#define GRF_I2S2_8CH_SDI_SFT		0
+#define GRF_I2S3_4CH_SDI_SFT		8
+#define GRF_I2S1_2CH_SDI_SFT		12
+
+#define GRF_I2S2_8CH_SDI_R_MSK(i, v)	((v >> (i * 2 + GRF_I2S2_8CH_SDI_SFT)) & 0x3)
+#define GRF_I2S2_8CH_SDI_W_MSK(i)	(0x3 << (i * 2 + GRF_I2S2_8CH_SDI_SFT + 16))
+#define GRF_I2S2_8CH_SDI(i, v)		(((v & 0x3) << (i * 2 + GRF_I2S2_8CH_SDI_SFT)) |\
+					 GRF_I2S2_8CH_SDI_W_MSK(i))
+
+#define GRF_I2S3_4CH_SDI_W_MSK(i)	(0x3 << (i * 2 + GRF_I2S3_4CH_SDI_SFT + 16))
+#define GRF_I2S3_4CH_SDI(i, v)		(((v & 0x3) << (i * 2 + GRF_I2S3_4CH_SDI_SFT)) |\
+					 GRF_I2S3_4CH_SDI_W_MSK(i))
+
+#define GRF_I2S1_2CH_SDI_W_MSK		(0x3 << (GRF_I2S1_2CH_SDI_SFT + 16))
+#define GRF_I2S1_2CH_SDI(v)		(((v & 0x3) << GRF_I2S1_2CH_SDI_SFT) |\
+					 GRF_I2S1_2CH_SDI_W_MSK)
+
+#define DETECT_GRF_ACODEC_HPDET_COUNTER		0x0030
+#define DETECT_GRF_ACODEC_HPDET_CON		0x0034
+#define DETECT_GRF_ACODEC_HPDET_STATUS		0x0038
+#define DETECT_GRF_ACODEC_HPDET_STATUS_CLR	0x003c
+
+/* 200ms based on pclk is 100MHz */
+#define DEFAULT_HPDET_COUNT			20000000
+#define HPDET_NEG_IRQ_SFT			1
+#define HPDET_POS_IRQ_SFT			0
+#define HPDET_BOTH_NEG_POS			((1 << HPDET_NEG_IRQ_SFT) |\
+						 (1 << HPDET_POS_IRQ_SFT))
+
+#define ACODEC_VERSION_A			0xa
+#define ACODEC_VERSION_B			0xb
+
+enum {
+	ACODEC_TO_I2S2_8CH = 0,
+	ACODEC_TO_I2S3_4CH,
+	ACODEC_TO_I2S1_2CH,
+};
+
+enum {
+	ADC_GRP0_MICIN = 0,
+	ADC_GRP0_LINEIN
+};
+
+enum {
+	ADC_TYPE_NORMAL = 0,
+	ADC_TYPE_LOOPBACK,
+	ADC_TYPE_DBG,
+	ADC_TYPE_ALL,
+};
+
+enum {
+	DAC_LINEOUT = 0,
+	DAC_HPOUT = 1,
+	DAC_LINEOUT_HPOUT = 11,
+};
+
+enum {
+	EXT_MICBIAS_NONE = 0,
+	EXT_MICBIAS_FUNC1,  /* enable external micbias via GPIO */
+	EXT_MICBIAS_FUNC2,  /* enable external micbias via regulator */
+};
+
+enum {
+	PATH_IDLE = 0,
+	PATH_BUSY,
+};
+
+enum {
+	PM_NORMAL = 0,
+	PM_LLP_DOWN,		/* light low power down */
+	PM_LLP_UP,
+	PM_DLP_DOWN,		/* deep low power down */
+	PM_DLP_UP,
+	PM_DLP_DOWN2,
+	PM_DLP_UP2,
+};
+
+struct rk3308_codec_priv {
+	const struct device *plat_dev;
+	struct device dev;
+	struct reset_control *reset;
+	struct regmap *regmap;
+	struct regmap *grf;
+	struct regmap *detect_grf;
+	struct clk *pclk;
+	struct clk *mclk_rx;
+	struct clk *mclk_tx;
+	struct gpio_desc *micbias_en_gpio;
+	struct gpio_desc *hp_ctl_gpio;
+	struct gpio_desc *spk_ctl_gpio;
+	struct gpio_desc *pa_drv_gpio;
+	struct snd_soc_component *component;
+	struct snd_soc_jack *hpdet_jack;
+	struct regulator *vcc_micbias;
+	u32 codec_ver;
+
+	/*
+	 * To select ADCs for groups:
+	 *
+	 * grp 0 -- select ADC1 / ADC2
+	 * grp 1 -- select ADC3 / ADC4
+	 * grp 2 -- select ADC5 / ADC6
+	 * grp 3 -- select ADC7 / ADC8
+	 */
+	u32 used_adc_grps;
+	/* The ADC group which is used for loop back */
+	u32 loopback_grp;
+	u32 cur_dbg_grp;
+	u32 en_always_grps[ADC_LR_GROUP_MAX];
+	u32 en_always_grps_num;
+	u32 skip_grps[ADC_LR_GROUP_MAX];
+	u32 i2s_sdis[ADC_LR_GROUP_MAX];
+	u32 to_i2s_grps;
+	u32 delay_loopback_handle_ms;
+	u32 delay_start_play_ms;
+	u32 delay_pa_drv_ms;
+	u32 micbias_num;
+	u32 micbias_volt;
+	int which_i2s;
+	int irq;
+	int adc_grp0_using_linein;
+	int adc_zerocross;
+	/* 0: line out, 1: hp out, 11: lineout and hpout */
+	int dac_output;
+	int dac_path_state;
+
+	int ext_micbias;
+	int pm_state;
+
+	/* AGC L/R Off/on */
+	unsigned int agc_l[ADC_LR_GROUP_MAX];
+	unsigned int agc_r[ADC_LR_GROUP_MAX];
+
+	/* AGC L/R Approximate Sample Rate */
+	unsigned int agc_asr_l[ADC_LR_GROUP_MAX];
+	unsigned int agc_asr_r[ADC_LR_GROUP_MAX];
+
+	/* ADC MIC Mute/Work */
+	unsigned int mic_mute_l[ADC_LR_GROUP_MAX];
+	unsigned int mic_mute_r[ADC_LR_GROUP_MAX];
+
+	/* For the high pass filter */
+	unsigned int hpf_cutoff[ADC_LR_GROUP_MAX];
+
+	/* Only hpout do fade-in and fade-out */
+	unsigned int hpout_l_dgain;
+	unsigned int hpout_r_dgain;
+
+	bool adc_grps_endisable[ADC_LR_GROUP_MAX];
+	bool dac_endisable;
+	bool enable_all_adcs;
+	bool enable_micbias;
+	bool micbias1;
+	bool micbias2;
+	bool hp_jack_reversed;
+	bool hp_plugged;
+	bool loopback_dacs_enabled;
+	bool no_deep_low_power;
+	bool no_hp_det;
+	struct delayed_work hpdet_work;
+	struct delayed_work loopback_work;
+
+#if defined(CONFIG_DEBUG_FS)
+	struct dentry *dbg_codec;
+#endif
+};
+
+static const DECLARE_TLV_DB_SCALE(rk3308_codec_alc_agc_grp_gain_tlv,
+				  -1800, 150, 2850);
+static const DECLARE_TLV_DB_SCALE(rk3308_codec_alc_agc_grp_max_gain_tlv,
+				  -1350, 600, 2850);
+static const DECLARE_TLV_DB_SCALE(rk3308_codec_alc_agc_grp_min_gain_tlv,
+				  -1800, 600, 2400);
+static const DECLARE_TLV_DB_SCALE(rk3308_codec_adc_alc_gain_tlv,
+				  -1800, 150, 2850);
+static const DECLARE_TLV_DB_SCALE(rk3308_codec_dac_lineout_gain_tlv,
+				  -600, 150, 0);
+static const DECLARE_TLV_DB_SCALE(rk3308_codec_dac_hpout_gain_tlv,
+				  -3900, 150, 600);
+static const DECLARE_TLV_DB_SCALE(rk3308_codec_dac_hpmix_gain_tlv,
+				  -600, 600, 0);
+
+static const DECLARE_TLV_DB_RANGE(rk3308_codec_adc_mic_gain_tlv_a,
+	0, 0, TLV_DB_SCALE_ITEM(0, 0, 0),
+	3, 3, TLV_DB_SCALE_ITEM(2000, 0, 0),
+);
+
+static const DECLARE_TLV_DB_RANGE(rk3308_codec_adc_mic_gain_tlv_b,
+	0, 0, TLV_DB_SCALE_ITEM(0, 0, 0),
+	1, 1, TLV_DB_SCALE_ITEM(660, 0, 0),
+	2, 2, TLV_DB_SCALE_ITEM(1300, 0, 0),
+	3, 3, TLV_DB_SCALE_ITEM(2000, 0, 0),
+);
+
+static bool handle_loopback(struct rk3308_codec_priv *rk3308);
+
+static int check_micbias(int micbias);
+
+static int rk3308_codec_micbias_enable(struct rk3308_codec_priv *rk3308,
+				       int micbias);
+static int rk3308_codec_micbias_disable(struct rk3308_codec_priv *rk3308);
+
+static int rk3308_codec_hpout_l_get_tlv(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol);
+static int rk3308_codec_hpout_l_put_tlv(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol);
+static int rk3308_codec_hpout_r_get_tlv(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol);
+static int rk3308_codec_hpout_r_put_tlv(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol);
+static int rk3308_codec_hpf_get(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol);
+static int rk3308_codec_hpf_put(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol);
+static int rk3308_codec_agc_get(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol);
+static int rk3308_codec_agc_put(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol);
+static int rk3308_codec_agc_asr_get(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol);
+static int rk3308_codec_agc_asr_put(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol);
+static int rk3308_codec_mic_mute_get(struct snd_kcontrol *kcontrol,
+				     struct snd_ctl_elem_value *ucontrol);
+static int rk3308_codec_mic_mute_put(struct snd_kcontrol *kcontrol,
+				     struct snd_ctl_elem_value *ucontrol);
+static int rk3308_codec_mic_gain_get(struct snd_kcontrol *kcontrol,
+				     struct snd_ctl_elem_value *ucontrol);
+static int rk3308_codec_mic_gain_put(struct snd_kcontrol *kcontrol,
+				     struct snd_ctl_elem_value *ucontrol);
+static int rk3308_codec_micbias_volts_get(struct snd_kcontrol *kcontrol,
+					  struct snd_ctl_elem_value *ucontrol);
+static int rk3308_codec_micbias_volts_put(struct snd_kcontrol *kcontrol,
+					  struct snd_ctl_elem_value *ucontrol);
+static int rk3308_codec_main_micbias_get(struct snd_kcontrol *kcontrol,
+					 struct snd_ctl_elem_value *ucontrol);
+static int rk3308_codec_main_micbias_put(struct snd_kcontrol *kcontrol,
+					 struct snd_ctl_elem_value *ucontrol);
+
+static const char *offon_text[2] = {
+	[0] = "Off",
+	[1] = "On",
+};
+
+static const char *mute_text[2] = {
+	[0] = "Work",
+	[1] = "Mute",
+};
+
+/* ADC MICBIAS Volt */
+#define MICBIAS_VOLT_NUM		8
+
+#define MICBIAS_VREFx0_5		0
+#define MICBIAS_VREFx0_55		1
+#define MICBIAS_VREFx0_6		2
+#define MICBIAS_VREFx0_65		3
+#define MICBIAS_VREFx0_7		4
+#define MICBIAS_VREFx0_75		5
+#define MICBIAS_VREFx0_8		6
+#define MICBIAS_VREFx0_85		7
+
+static const char *micbias_volts_enum_array[MICBIAS_VOLT_NUM] = {
+	[MICBIAS_VREFx0_5] = "VREFx0_5",
+	[MICBIAS_VREFx0_55] = "VREFx0_55",
+	[MICBIAS_VREFx0_6] = "VREFx0_6",
+	[MICBIAS_VREFx0_65] = "VREFx0_65",
+	[MICBIAS_VREFx0_7] = "VREFx0_7",
+	[MICBIAS_VREFx0_75] = "VREFx0_75",
+	[MICBIAS_VREFx0_8] = "VREFx0_8",
+	[MICBIAS_VREFx0_85] = "VREFx0_85",
+};
+
+static const struct soc_enum rk3308_micbias_volts_enum_array[] = {
+	SOC_ENUM_SINGLE(0, 0, ARRAY_SIZE(micbias_volts_enum_array), micbias_volts_enum_array),
+};
+
+/* ADC MICBIAS1 and MICBIAS2 Main Switch */
+static const struct soc_enum rk3308_main_micbias_enum_array[] = {
+	SOC_ENUM_SINGLE(0, 0, ARRAY_SIZE(offon_text), offon_text),
+};
+
+static const struct soc_enum rk3308_hpf_enum_array[] = {
+	SOC_ENUM_SINGLE(0, 0, ARRAY_SIZE(offon_text), offon_text),
+	SOC_ENUM_SINGLE(1, 0, ARRAY_SIZE(offon_text), offon_text),
+	SOC_ENUM_SINGLE(2, 0, ARRAY_SIZE(offon_text), offon_text),
+	SOC_ENUM_SINGLE(3, 0, ARRAY_SIZE(offon_text), offon_text),
+};
+
+/* ALC AGC Switch */
+static const struct soc_enum rk3308_agc_enum_array[] = {
+	SOC_ENUM_SINGLE(0, 0, ARRAY_SIZE(offon_text), offon_text),
+	SOC_ENUM_SINGLE(0, 1, ARRAY_SIZE(offon_text), offon_text),
+	SOC_ENUM_SINGLE(1, 0, ARRAY_SIZE(offon_text), offon_text),
+	SOC_ENUM_SINGLE(1, 1, ARRAY_SIZE(offon_text), offon_text),
+	SOC_ENUM_SINGLE(2, 0, ARRAY_SIZE(offon_text), offon_text),
+	SOC_ENUM_SINGLE(2, 1, ARRAY_SIZE(offon_text), offon_text),
+	SOC_ENUM_SINGLE(3, 0, ARRAY_SIZE(offon_text), offon_text),
+	SOC_ENUM_SINGLE(3, 1, ARRAY_SIZE(offon_text), offon_text),
+};
+
+/* ADC MIC Mute/Work Switch */
+static const struct soc_enum rk3308_mic_mute_enum_array[] = {
+	SOC_ENUM_SINGLE(0, 0, ARRAY_SIZE(mute_text), mute_text),
+	SOC_ENUM_SINGLE(0, 1, ARRAY_SIZE(mute_text), mute_text),
+	SOC_ENUM_SINGLE(1, 0, ARRAY_SIZE(mute_text), mute_text),
+	SOC_ENUM_SINGLE(1, 1, ARRAY_SIZE(mute_text), mute_text),
+	SOC_ENUM_SINGLE(2, 0, ARRAY_SIZE(mute_text), mute_text),
+	SOC_ENUM_SINGLE(2, 1, ARRAY_SIZE(mute_text), mute_text),
+	SOC_ENUM_SINGLE(3, 0, ARRAY_SIZE(mute_text), mute_text),
+	SOC_ENUM_SINGLE(3, 1, ARRAY_SIZE(mute_text), mute_text),
+};
+
+/* ALC AGC Approximate Sample Rate */
+#define AGC_ASR_NUM				8
+
+#define AGC_ASR_96KHZ				0
+#define AGC_ASR_48KHZ				1
+#define AGC_ASR_44_1KHZ				2
+#define AGC_ASR_32KHZ				3
+#define AGC_ASR_24KHZ				4
+#define AGC_ASR_16KHZ				5
+#define AGC_ASR_12KHZ				6
+#define AGC_ASR_8KHZ				7
+
+static const char *agc_asr_text[AGC_ASR_NUM] = {
+	[AGC_ASR_96KHZ] = "96KHz",
+	[AGC_ASR_48KHZ] = "48KHz",
+	[AGC_ASR_44_1KHZ] = "44.1KHz",
+	[AGC_ASR_32KHZ] = "32KHz",
+	[AGC_ASR_24KHZ] = "24KHz",
+	[AGC_ASR_16KHZ] = "16KHz",
+	[AGC_ASR_12KHZ] = "12KHz",
+	[AGC_ASR_8KHZ] = "8KHz",
+};
+
+static const struct soc_enum rk3308_agc_asr_enum_array[] = {
+	SOC_ENUM_SINGLE(0, 0, ARRAY_SIZE(agc_asr_text), agc_asr_text),
+	SOC_ENUM_SINGLE(0, 1, ARRAY_SIZE(agc_asr_text), agc_asr_text),
+	SOC_ENUM_SINGLE(1, 0, ARRAY_SIZE(agc_asr_text), agc_asr_text),
+	SOC_ENUM_SINGLE(1, 1, ARRAY_SIZE(agc_asr_text), agc_asr_text),
+	SOC_ENUM_SINGLE(2, 0, ARRAY_SIZE(agc_asr_text), agc_asr_text),
+	SOC_ENUM_SINGLE(2, 1, ARRAY_SIZE(agc_asr_text), agc_asr_text),
+	SOC_ENUM_SINGLE(3, 0, ARRAY_SIZE(agc_asr_text), agc_asr_text),
+	SOC_ENUM_SINGLE(3, 1, ARRAY_SIZE(agc_asr_text), agc_asr_text),
+};
+
+static const struct snd_kcontrol_new mic_gains_a[] = {
+	/* ADC MIC */
+	SOC_SINGLE_EXT_TLV("ADC MIC Group 0 Left Volume",
+			   RK3308_ADC_ANA_CON01(0),
+			   RK3308_ADC_CH1_MIC_GAIN_SFT,
+			   RK3308_ADC_CH1_MIC_GAIN_MAX,
+			   0,
+			   rk3308_codec_mic_gain_get,
+			   rk3308_codec_mic_gain_put,
+			   rk3308_codec_adc_mic_gain_tlv_a),
+	SOC_SINGLE_EXT_TLV("ADC MIC Group 0 Right Volume",
+			   RK3308_ADC_ANA_CON01(0),
+			   RK3308_ADC_CH2_MIC_GAIN_SFT,
+			   RK3308_ADC_CH2_MIC_GAIN_MAX,
+			   0,
+			   rk3308_codec_mic_gain_get,
+			   rk3308_codec_mic_gain_put,
+			   rk3308_codec_adc_mic_gain_tlv_a),
+	SOC_SINGLE_EXT_TLV("ADC MIC Group 1 Left Volume",
+			   RK3308_ADC_ANA_CON01(1),
+			   RK3308_ADC_CH1_MIC_GAIN_SFT,
+			   RK3308_ADC_CH1_MIC_GAIN_MAX,
+			   0,
+			   rk3308_codec_mic_gain_get,
+			   rk3308_codec_mic_gain_put,
+			   rk3308_codec_adc_mic_gain_tlv_a),
+	SOC_SINGLE_EXT_TLV("ADC MIC Group 1 Right Volume",
+			   RK3308_ADC_ANA_CON01(1),
+			   RK3308_ADC_CH2_MIC_GAIN_SFT,
+			   RK3308_ADC_CH2_MIC_GAIN_MAX,
+			   0,
+			   rk3308_codec_mic_gain_get,
+			   rk3308_codec_mic_gain_put,
+			   rk3308_codec_adc_mic_gain_tlv_a),
+	SOC_SINGLE_EXT_TLV("ADC MIC Group 2 Left Volume",
+			   RK3308_ADC_ANA_CON01(2),
+			   RK3308_ADC_CH1_MIC_GAIN_SFT,
+			   RK3308_ADC_CH1_MIC_GAIN_MAX,
+			   0,
+			   rk3308_codec_mic_gain_get,
+			   rk3308_codec_mic_gain_put,
+			   rk3308_codec_adc_mic_gain_tlv_a),
+	SOC_SINGLE_EXT_TLV("ADC MIC Group 2 Right Volume",
+			   RK3308_ADC_ANA_CON01(2),
+			   RK3308_ADC_CH2_MIC_GAIN_SFT,
+			   RK3308_ADC_CH2_MIC_GAIN_MAX,
+			   0,
+			   rk3308_codec_mic_gain_get,
+			   rk3308_codec_mic_gain_put,
+			   rk3308_codec_adc_mic_gain_tlv_a),
+	SOC_SINGLE_EXT_TLV("ADC MIC Group 3 Left Volume",
+			   RK3308_ADC_ANA_CON01(3),
+			   RK3308_ADC_CH1_MIC_GAIN_SFT,
+			   RK3308_ADC_CH1_MIC_GAIN_MAX,
+			   0,
+			   rk3308_codec_mic_gain_get,
+			   rk3308_codec_mic_gain_put,
+			   rk3308_codec_adc_mic_gain_tlv_a),
+	SOC_SINGLE_EXT_TLV("ADC MIC Group 3 Right Volume",
+			   RK3308_ADC_ANA_CON01(3),
+			   RK3308_ADC_CH2_MIC_GAIN_SFT,
+			   RK3308_ADC_CH2_MIC_GAIN_MAX,
+			   0,
+			   rk3308_codec_mic_gain_get,
+			   rk3308_codec_mic_gain_put,
+			   rk3308_codec_adc_mic_gain_tlv_a),
+};
+
+static const struct snd_kcontrol_new mic_gains_b[] = {
+	/* ADC MIC */
+	SOC_SINGLE_EXT_TLV("ADC MIC Group 0 Left Volume",
+			   RK3308_ADC_ANA_CON01(0),
+			   RK3308_ADC_CH1_MIC_GAIN_SFT,
+			   RK3308_ADC_CH1_MIC_GAIN_MAX,
+			   0,
+			   rk3308_codec_mic_gain_get,
+			   rk3308_codec_mic_gain_put,
+			   rk3308_codec_adc_mic_gain_tlv_b),
+	SOC_SINGLE_EXT_TLV("ADC MIC Group 0 Right Volume",
+			   RK3308_ADC_ANA_CON01(0),
+			   RK3308_ADC_CH2_MIC_GAIN_SFT,
+			   RK3308_ADC_CH2_MIC_GAIN_MAX,
+			   0,
+			   rk3308_codec_mic_gain_get,
+			   rk3308_codec_mic_gain_put,
+			   rk3308_codec_adc_mic_gain_tlv_b),
+	SOC_SINGLE_EXT_TLV("ADC MIC Group 1 Left Volume",
+			   RK3308_ADC_ANA_CON01(1),
+			   RK3308_ADC_CH1_MIC_GAIN_SFT,
+			   RK3308_ADC_CH1_MIC_GAIN_MAX,
+			   0,
+			   rk3308_codec_mic_gain_get,
+			   rk3308_codec_mic_gain_put,
+			   rk3308_codec_adc_mic_gain_tlv_b),
+	SOC_SINGLE_EXT_TLV("ADC MIC Group 1 Right Volume",
+			   RK3308_ADC_ANA_CON01(1),
+			   RK3308_ADC_CH2_MIC_GAIN_SFT,
+			   RK3308_ADC_CH2_MIC_GAIN_MAX,
+			   0,
+			   rk3308_codec_mic_gain_get,
+			   rk3308_codec_mic_gain_put,
+			   rk3308_codec_adc_mic_gain_tlv_b),
+	SOC_SINGLE_EXT_TLV("ADC MIC Group 2 Left Volume",
+			   RK3308_ADC_ANA_CON01(2),
+			   RK3308_ADC_CH1_MIC_GAIN_SFT,
+			   RK3308_ADC_CH1_MIC_GAIN_MAX,
+			   0,
+			   rk3308_codec_mic_gain_get,
+			   rk3308_codec_mic_gain_put,
+			   rk3308_codec_adc_mic_gain_tlv_b),
+	SOC_SINGLE_EXT_TLV("ADC MIC Group 2 Right Volume",
+			   RK3308_ADC_ANA_CON01(2),
+			   RK3308_ADC_CH2_MIC_GAIN_SFT,
+			   RK3308_ADC_CH2_MIC_GAIN_MAX,
+			   0,
+			   rk3308_codec_mic_gain_get,
+			   rk3308_codec_mic_gain_put,
+			   rk3308_codec_adc_mic_gain_tlv_b),
+	SOC_SINGLE_EXT_TLV("ADC MIC Group 3 Left Volume",
+			   RK3308_ADC_ANA_CON01(3),
+			   RK3308_ADC_CH1_MIC_GAIN_SFT,
+			   RK3308_ADC_CH1_MIC_GAIN_MAX,
+			   0,
+			   rk3308_codec_mic_gain_get,
+			   rk3308_codec_mic_gain_put,
+			   rk3308_codec_adc_mic_gain_tlv_b),
+	SOC_SINGLE_EXT_TLV("ADC MIC Group 3 Right Volume",
+			   RK3308_ADC_ANA_CON01(3),
+			   RK3308_ADC_CH2_MIC_GAIN_SFT,
+			   RK3308_ADC_CH2_MIC_GAIN_MAX,
+			   0,
+			   rk3308_codec_mic_gain_get,
+			   rk3308_codec_mic_gain_put,
+			   rk3308_codec_adc_mic_gain_tlv_b),
+};
+
+static const struct snd_kcontrol_new rk3308_codec_dapm_controls[] = {
+	/* ALC AGC Group */
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 0 Left Volume",
+			     RK3308_ALC_L_DIG_CON03(0),
+			     RK3308_AGC_PGA_GAIN_SFT,
+			     RK3308_AGC_PGA_GAIN_MIN,
+			     RK3308_AGC_PGA_GAIN_MAX,
+			     0, rk3308_codec_alc_agc_grp_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 0 Right Volume",
+			     RK3308_ALC_R_DIG_CON03(0),
+			     RK3308_AGC_PGA_GAIN_SFT,
+			     RK3308_AGC_PGA_GAIN_MIN,
+			     RK3308_AGC_PGA_GAIN_MAX,
+			     0, rk3308_codec_alc_agc_grp_gain_tlv),
+
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 1 Left Volume",
+			     RK3308_ALC_L_DIG_CON03(1),
+			     RK3308_AGC_PGA_GAIN_SFT,
+			     RK3308_AGC_PGA_GAIN_MIN,
+			     RK3308_AGC_PGA_GAIN_MAX,
+			     0, rk3308_codec_alc_agc_grp_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 1 Right Volume",
+			     RK3308_ALC_R_DIG_CON03(1),
+			     RK3308_AGC_PGA_GAIN_SFT,
+			     RK3308_AGC_PGA_GAIN_MIN,
+			     RK3308_AGC_PGA_GAIN_MAX,
+			     0, rk3308_codec_alc_agc_grp_gain_tlv),
+
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 2 Left Volume",
+			     RK3308_ALC_L_DIG_CON03(2),
+			     RK3308_AGC_PGA_GAIN_SFT,
+			     RK3308_AGC_PGA_GAIN_MIN,
+			     RK3308_AGC_PGA_GAIN_MAX,
+			     0, rk3308_codec_alc_agc_grp_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 2 Right Volume",
+			     RK3308_ALC_R_DIG_CON03(2),
+			     RK3308_AGC_PGA_GAIN_SFT,
+			     RK3308_AGC_PGA_GAIN_MIN,
+			     RK3308_AGC_PGA_GAIN_MAX,
+			     0, rk3308_codec_alc_agc_grp_gain_tlv),
+
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 3 Left Volume",
+			     RK3308_ALC_L_DIG_CON03(3),
+			     RK3308_AGC_PGA_GAIN_SFT,
+			     RK3308_AGC_PGA_GAIN_MIN,
+			     RK3308_AGC_PGA_GAIN_MAX,
+			     0, rk3308_codec_alc_agc_grp_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 3 Right Volume",
+			     RK3308_ALC_R_DIG_CON03(3),
+			     RK3308_AGC_PGA_GAIN_SFT,
+			     RK3308_AGC_PGA_GAIN_MIN,
+			     RK3308_AGC_PGA_GAIN_MAX,
+			     0, rk3308_codec_alc_agc_grp_gain_tlv),
+
+	/* ALC AGC MAX */
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 0 Left Max Volume",
+			     RK3308_ALC_L_DIG_CON09(0),
+			     RK3308_AGC_MAX_GAIN_PGA_SFT,
+			     RK3308_AGC_MAX_GAIN_PGA_MIN,
+			     RK3308_AGC_MAX_GAIN_PGA_MAX,
+			     0, rk3308_codec_alc_agc_grp_max_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 0 Right Max Volume",
+			     RK3308_ALC_R_DIG_CON09(0),
+			     RK3308_AGC_MAX_GAIN_PGA_SFT,
+			     RK3308_AGC_MAX_GAIN_PGA_MIN,
+			     RK3308_AGC_MAX_GAIN_PGA_MAX,
+			     0, rk3308_codec_alc_agc_grp_max_gain_tlv),
+
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 1 Left Max Volume",
+			     RK3308_ALC_L_DIG_CON09(1),
+			     RK3308_AGC_MAX_GAIN_PGA_SFT,
+			     RK3308_AGC_MAX_GAIN_PGA_MIN,
+			     RK3308_AGC_MAX_GAIN_PGA_MAX,
+			     0, rk3308_codec_alc_agc_grp_max_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 1 Right Max Volume",
+			     RK3308_ALC_R_DIG_CON09(1),
+			     RK3308_AGC_MAX_GAIN_PGA_SFT,
+			     RK3308_AGC_MAX_GAIN_PGA_MIN,
+			     RK3308_AGC_MAX_GAIN_PGA_MAX,
+			     0, rk3308_codec_alc_agc_grp_max_gain_tlv),
+
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 2 Left Max Volume",
+			     RK3308_ALC_L_DIG_CON09(2),
+			     RK3308_AGC_MAX_GAIN_PGA_SFT,
+			     RK3308_AGC_MAX_GAIN_PGA_MIN,
+			     RK3308_AGC_MAX_GAIN_PGA_MAX,
+			     0, rk3308_codec_alc_agc_grp_max_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 2 Right Max Volume",
+			     RK3308_ALC_R_DIG_CON09(2),
+			     RK3308_AGC_MAX_GAIN_PGA_SFT,
+			     RK3308_AGC_MAX_GAIN_PGA_MIN,
+			     RK3308_AGC_MAX_GAIN_PGA_MAX,
+			     0, rk3308_codec_alc_agc_grp_max_gain_tlv),
+
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 3 Left Max Volume",
+			     RK3308_ALC_L_DIG_CON09(3),
+			     RK3308_AGC_MAX_GAIN_PGA_SFT,
+			     RK3308_AGC_MAX_GAIN_PGA_MIN,
+			     RK3308_AGC_MAX_GAIN_PGA_MAX,
+			     0, rk3308_codec_alc_agc_grp_max_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 3 Right Max Volume",
+			     RK3308_ALC_R_DIG_CON09(3),
+			     RK3308_AGC_MAX_GAIN_PGA_SFT,
+			     RK3308_AGC_MAX_GAIN_PGA_MIN,
+			     RK3308_AGC_MAX_GAIN_PGA_MAX,
+			     0, rk3308_codec_alc_agc_grp_max_gain_tlv),
+
+	/* ALC AGC MIN */
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 0 Left Min Volume",
+			     RK3308_ALC_L_DIG_CON09(0),
+			     RK3308_AGC_MIN_GAIN_PGA_SFT,
+			     RK3308_AGC_MIN_GAIN_PGA_MIN,
+			     RK3308_AGC_MIN_GAIN_PGA_MAX,
+			     0, rk3308_codec_alc_agc_grp_min_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 0 Right Min Volume",
+			     RK3308_ALC_R_DIG_CON09(0),
+			     RK3308_AGC_MIN_GAIN_PGA_SFT,
+			     RK3308_AGC_MIN_GAIN_PGA_MIN,
+			     RK3308_AGC_MIN_GAIN_PGA_MAX,
+			     0, rk3308_codec_alc_agc_grp_min_gain_tlv),
+
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 1 Left Min Volume",
+			     RK3308_ALC_L_DIG_CON09(1),
+			     RK3308_AGC_MIN_GAIN_PGA_SFT,
+			     RK3308_AGC_MIN_GAIN_PGA_MIN,
+			     RK3308_AGC_MIN_GAIN_PGA_MAX,
+			     0, rk3308_codec_alc_agc_grp_min_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 1 Right Min Volume",
+			     RK3308_ALC_R_DIG_CON09(1),
+			     RK3308_AGC_MIN_GAIN_PGA_SFT,
+			     RK3308_AGC_MIN_GAIN_PGA_MIN,
+			     RK3308_AGC_MIN_GAIN_PGA_MAX,
+			     0, rk3308_codec_alc_agc_grp_min_gain_tlv),
+
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 2 Left Min Volume",
+			     RK3308_ALC_L_DIG_CON09(2),
+			     RK3308_AGC_MIN_GAIN_PGA_SFT,
+			     RK3308_AGC_MIN_GAIN_PGA_MIN,
+			     RK3308_AGC_MIN_GAIN_PGA_MAX,
+			     0, rk3308_codec_alc_agc_grp_min_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 2 Right Min Volume",
+			     RK3308_ALC_R_DIG_CON09(2),
+			     RK3308_AGC_MIN_GAIN_PGA_SFT,
+			     RK3308_AGC_MIN_GAIN_PGA_MIN,
+			     RK3308_AGC_MIN_GAIN_PGA_MAX,
+			     0, rk3308_codec_alc_agc_grp_min_gain_tlv),
+
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 3 Left Min Volume",
+			     RK3308_ALC_L_DIG_CON09(3),
+			     RK3308_AGC_MIN_GAIN_PGA_SFT,
+			     RK3308_AGC_MIN_GAIN_PGA_MIN,
+			     RK3308_AGC_MIN_GAIN_PGA_MAX,
+			     0, rk3308_codec_alc_agc_grp_min_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ALC AGC Group 3 Right Min Volume",
+			     RK3308_ALC_R_DIG_CON09(3),
+			     RK3308_AGC_MIN_GAIN_PGA_SFT,
+			     RK3308_AGC_MIN_GAIN_PGA_MIN,
+			     RK3308_AGC_MIN_GAIN_PGA_MAX,
+			     0, rk3308_codec_alc_agc_grp_min_gain_tlv),
+
+	/* ALC AGC Switch */
+	SOC_ENUM_EXT("ALC AGC Group 0 Left Switch", rk3308_agc_enum_array[0],
+		     rk3308_codec_agc_get, rk3308_codec_agc_put),
+	SOC_ENUM_EXT("ALC AGC Group 0 Right Switch", rk3308_agc_enum_array[1],
+		     rk3308_codec_agc_get, rk3308_codec_agc_put),
+	SOC_ENUM_EXT("ALC AGC Group 1 Left Switch", rk3308_agc_enum_array[2],
+		     rk3308_codec_agc_get, rk3308_codec_agc_put),
+	SOC_ENUM_EXT("ALC AGC Group 1 Right Switch", rk3308_agc_enum_array[3],
+		     rk3308_codec_agc_get, rk3308_codec_agc_put),
+	SOC_ENUM_EXT("ALC AGC Group 2 Left Switch", rk3308_agc_enum_array[4],
+		     rk3308_codec_agc_get, rk3308_codec_agc_put),
+	SOC_ENUM_EXT("ALC AGC Group 2 Right Switch", rk3308_agc_enum_array[5],
+		     rk3308_codec_agc_get, rk3308_codec_agc_put),
+	SOC_ENUM_EXT("ALC AGC Group 3 Left Switch", rk3308_agc_enum_array[6],
+		     rk3308_codec_agc_get, rk3308_codec_agc_put),
+	SOC_ENUM_EXT("ALC AGC Group 3 Right Switch", rk3308_agc_enum_array[7],
+		     rk3308_codec_agc_get, rk3308_codec_agc_put),
+
+	/* ALC AGC Approximate Sample Rate */
+	SOC_ENUM_EXT("AGC Group 0 Left Approximate Sample Rate", rk3308_agc_asr_enum_array[0],
+		     rk3308_codec_agc_asr_get, rk3308_codec_agc_asr_put),
+	SOC_ENUM_EXT("AGC Group 0 Right Approximate Sample Rate", rk3308_agc_asr_enum_array[1],
+		     rk3308_codec_agc_asr_get, rk3308_codec_agc_asr_put),
+	SOC_ENUM_EXT("AGC Group 1 Left Approximate Sample Rate", rk3308_agc_asr_enum_array[2],
+		     rk3308_codec_agc_asr_get, rk3308_codec_agc_asr_put),
+	SOC_ENUM_EXT("AGC Group 1 Right Approximate Sample Rate", rk3308_agc_asr_enum_array[3],
+		     rk3308_codec_agc_asr_get, rk3308_codec_agc_asr_put),
+	SOC_ENUM_EXT("AGC Group 2 Left Approximate Sample Rate", rk3308_agc_asr_enum_array[4],
+		     rk3308_codec_agc_asr_get, rk3308_codec_agc_asr_put),
+	SOC_ENUM_EXT("AGC Group 2 Right Approximate Sample Rate", rk3308_agc_asr_enum_array[5],
+		     rk3308_codec_agc_asr_get, rk3308_codec_agc_asr_put),
+	SOC_ENUM_EXT("AGC Group 3 Left Approximate Sample Rate", rk3308_agc_asr_enum_array[6],
+		     rk3308_codec_agc_asr_get, rk3308_codec_agc_asr_put),
+	SOC_ENUM_EXT("AGC Group 3 Right Approximate Sample Rate", rk3308_agc_asr_enum_array[7],
+		     rk3308_codec_agc_asr_get, rk3308_codec_agc_asr_put),
+
+	/* ADC MICBIAS Voltage */
+	SOC_ENUM_EXT("ADC MICBIAS Voltage", rk3308_micbias_volts_enum_array[0],
+		     rk3308_codec_micbias_volts_get, rk3308_codec_micbias_volts_put),
+
+	/* ADC Main MICBIAS Switch */
+	SOC_ENUM_EXT("ADC Main MICBIAS", rk3308_main_micbias_enum_array[0],
+		     rk3308_codec_main_micbias_get, rk3308_codec_main_micbias_put),
+
+	/* ADC MICBIAS1 and MICBIAS2 Switch */
+	SOC_SINGLE("ADC MICBIAS1", RK3308_ADC_ANA_CON07(1),
+		   RK3308_ADC_MIC_BIAS_BUF_SFT, 1, 0),
+	SOC_SINGLE("ADC MICBIAS2", RK3308_ADC_ANA_CON07(2),
+		   RK3308_ADC_MIC_BIAS_BUF_SFT, 1, 0),
+
+	/* ADC MIC Mute/Work Switch */
+	SOC_ENUM_EXT("ADC MIC Group 0 Left Switch", rk3308_mic_mute_enum_array[0],
+		     rk3308_codec_mic_mute_get, rk3308_codec_mic_mute_put),
+	SOC_ENUM_EXT("ADC MIC Group 0 Right Switch", rk3308_mic_mute_enum_array[1],
+		     rk3308_codec_mic_mute_get, rk3308_codec_mic_mute_put),
+	SOC_ENUM_EXT("ADC MIC Group 1 Left Switch", rk3308_mic_mute_enum_array[2],
+		     rk3308_codec_mic_mute_get, rk3308_codec_mic_mute_put),
+	SOC_ENUM_EXT("ADC MIC Group 1 Right Switch", rk3308_mic_mute_enum_array[3],
+		     rk3308_codec_mic_mute_get, rk3308_codec_mic_mute_put),
+	SOC_ENUM_EXT("ADC MIC Group 2 Left Switch", rk3308_mic_mute_enum_array[4],
+		     rk3308_codec_mic_mute_get, rk3308_codec_mic_mute_put),
+	SOC_ENUM_EXT("ADC MIC Group 2 Right Switch", rk3308_mic_mute_enum_array[5],
+		     rk3308_codec_mic_mute_get, rk3308_codec_mic_mute_put),
+	SOC_ENUM_EXT("ADC MIC Group 3 Left Switch", rk3308_mic_mute_enum_array[6],
+		     rk3308_codec_mic_mute_get, rk3308_codec_mic_mute_put),
+	SOC_ENUM_EXT("ADC MIC Group 3 Right Switch", rk3308_mic_mute_enum_array[7],
+		     rk3308_codec_mic_mute_get, rk3308_codec_mic_mute_put),
+
+	/* ADC ALC */
+	SOC_SINGLE_RANGE_TLV("ADC ALC Group 0 Left Volume",
+			     RK3308_ADC_ANA_CON03(0),
+			     RK3308_ADC_CH1_ALC_GAIN_SFT,
+			     RK3308_ADC_CH1_ALC_GAIN_MIN,
+			     RK3308_ADC_CH1_ALC_GAIN_MAX,
+			     0, rk3308_codec_adc_alc_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ADC ALC Group 0 Right Volume",
+			     RK3308_ADC_ANA_CON04(0),
+			     RK3308_ADC_CH2_ALC_GAIN_SFT,
+			     RK3308_ADC_CH2_ALC_GAIN_MIN,
+			     RK3308_ADC_CH2_ALC_GAIN_MAX,
+			     0, rk3308_codec_adc_alc_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ADC ALC Group 1 Left Volume",
+			     RK3308_ADC_ANA_CON03(1),
+			     RK3308_ADC_CH1_ALC_GAIN_SFT,
+			     RK3308_ADC_CH1_ALC_GAIN_MIN,
+			     RK3308_ADC_CH1_ALC_GAIN_MAX,
+			     0, rk3308_codec_adc_alc_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ADC ALC Group 1 Right Volume",
+			     RK3308_ADC_ANA_CON04(1),
+			     RK3308_ADC_CH2_ALC_GAIN_SFT,
+			     RK3308_ADC_CH2_ALC_GAIN_MIN,
+			     RK3308_ADC_CH2_ALC_GAIN_MAX,
+			     0, rk3308_codec_adc_alc_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ADC ALC Group 2 Left Volume",
+			     RK3308_ADC_ANA_CON03(2),
+			     RK3308_ADC_CH1_ALC_GAIN_SFT,
+			     RK3308_ADC_CH1_ALC_GAIN_MIN,
+			     RK3308_ADC_CH1_ALC_GAIN_MAX,
+			     0, rk3308_codec_adc_alc_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ADC ALC Group 2 Right Volume",
+			     RK3308_ADC_ANA_CON04(2),
+			     RK3308_ADC_CH2_ALC_GAIN_SFT,
+			     RK3308_ADC_CH2_ALC_GAIN_MIN,
+			     RK3308_ADC_CH2_ALC_GAIN_MAX,
+			     0, rk3308_codec_adc_alc_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ADC ALC Group 3 Left Volume",
+			     RK3308_ADC_ANA_CON03(3),
+			     RK3308_ADC_CH1_ALC_GAIN_SFT,
+			     RK3308_ADC_CH1_ALC_GAIN_MIN,
+			     RK3308_ADC_CH1_ALC_GAIN_MAX,
+			     0, rk3308_codec_adc_alc_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("ADC ALC Group 3 Right Volume",
+			     RK3308_ADC_ANA_CON04(3),
+			     RK3308_ADC_CH2_ALC_GAIN_SFT,
+			     RK3308_ADC_CH2_ALC_GAIN_MIN,
+			     RK3308_ADC_CH2_ALC_GAIN_MAX,
+			     0, rk3308_codec_adc_alc_gain_tlv),
+
+	/* ADC High Pass Filter */
+	SOC_ENUM_EXT("ADC Group 0 HPF Cut-off", rk3308_hpf_enum_array[0],
+		     rk3308_codec_hpf_get, rk3308_codec_hpf_put),
+	SOC_ENUM_EXT("ADC Group 1 HPF Cut-off", rk3308_hpf_enum_array[1],
+		     rk3308_codec_hpf_get, rk3308_codec_hpf_put),
+	SOC_ENUM_EXT("ADC Group 2 HPF Cut-off", rk3308_hpf_enum_array[2],
+		     rk3308_codec_hpf_get, rk3308_codec_hpf_put),
+	SOC_ENUM_EXT("ADC Group 3 HPF Cut-off", rk3308_hpf_enum_array[3],
+		     rk3308_codec_hpf_get, rk3308_codec_hpf_put),
+
+	/* DAC LINEOUT */
+	SOC_SINGLE_TLV("DAC LINEOUT Left Volume",
+		       RK3308_DAC_ANA_CON04,
+		       RK3308_DAC_L_LINEOUT_GAIN_SFT,
+		       RK3308_DAC_L_LINEOUT_GAIN_MAX,
+		       0, rk3308_codec_dac_lineout_gain_tlv),
+	SOC_SINGLE_TLV("DAC LINEOUT Right Volume",
+		       RK3308_DAC_ANA_CON04,
+		       RK3308_DAC_R_LINEOUT_GAIN_SFT,
+		       RK3308_DAC_R_LINEOUT_GAIN_MAX,
+		       0, rk3308_codec_dac_lineout_gain_tlv),
+
+	/* DAC HPOUT */
+	SOC_SINGLE_EXT_TLV("DAC HPOUT Left Volume",
+			   RK3308_DAC_ANA_CON05,
+			   RK3308_DAC_L_HPOUT_GAIN_SFT,
+			   RK3308_DAC_L_HPOUT_GAIN_MAX,
+			   0,
+			   rk3308_codec_hpout_l_get_tlv,
+			   rk3308_codec_hpout_l_put_tlv,
+			   rk3308_codec_dac_hpout_gain_tlv),
+	SOC_SINGLE_EXT_TLV("DAC HPOUT Right Volume",
+			   RK3308_DAC_ANA_CON06,
+			   RK3308_DAC_R_HPOUT_GAIN_SFT,
+			   RK3308_DAC_R_HPOUT_GAIN_MAX,
+			   0,
+			   rk3308_codec_hpout_r_get_tlv,
+			   rk3308_codec_hpout_r_put_tlv,
+			   rk3308_codec_dac_hpout_gain_tlv),
+
+	/* DAC HPMIX */
+	SOC_SINGLE_RANGE_TLV("DAC HPMIX Left Volume",
+			     RK3308_DAC_ANA_CON12,
+			     RK3308_DAC_L_HPMIX_GAIN_SFT,
+			     RK3308_DAC_L_HPMIX_GAIN_MIN,
+			     RK3308_DAC_L_HPMIX_GAIN_MAX,
+			     0, rk3308_codec_dac_hpmix_gain_tlv),
+	SOC_SINGLE_RANGE_TLV("DAC HPMIX Right Volume",
+			     RK3308_DAC_ANA_CON12,
+			     RK3308_DAC_R_HPMIX_GAIN_SFT,
+			     RK3308_DAC_R_HPMIX_GAIN_MIN,
+			     RK3308_DAC_R_HPMIX_GAIN_MAX,
+			     0, rk3308_codec_dac_hpmix_gain_tlv),
+};
+
+static int rk3308_codec_agc_get(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	struct rk3308_codec_priv *rk3308 = snd_soc_component_get_drvdata(component);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+
+	if (e->reg < 0 || e->reg > ADC_LR_GROUP_MAX - 1) {
+		dev_err(rk3308->plat_dev,
+			"%s: Invalid ADC grp: %d\n", __func__, e->reg);
+		return -EINVAL;
+	}
+
+	if (e->shift_l)
+		ucontrol->value.integer.value[0] = rk3308->agc_r[e->reg];
+	else
+		ucontrol->value.integer.value[0] = rk3308->agc_l[e->reg];
+
+	return 0;
+}
+
+static int rk3308_codec_agc_put(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	struct rk3308_codec_priv *rk3308 = snd_soc_component_get_drvdata(component);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	unsigned int value = ucontrol->value.integer.value[0];
+	int grp = e->reg;
+
+	if (e->reg < 0 || e->reg > ADC_LR_GROUP_MAX - 1) {
+		dev_err(rk3308->plat_dev,
+			"%s: Invalid ADC grp: %d\n", __func__, e->reg);
+		return -EINVAL;
+	}
+
+	if (value) {
+		/* ALC AGC On */
+		if (e->shift_l) {
+			/* ALC AGC Right On */
+			regmap_update_bits(rk3308->regmap, RK3308_ALC_R_DIG_CON09(grp),
+					   RK3308_AGC_FUNC_SEL_MSK,
+					   RK3308_AGC_FUNC_SEL_EN);
+			regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON11(grp),
+					   RK3308_ADC_ALCR_CON_GAIN_PGAR_MSK,
+					   RK3308_ADC_ALCR_CON_GAIN_PGAR_EN);
+
+			rk3308->agc_r[e->reg] = 1;
+		} else {
+			/* ALC AGC Left On */
+			regmap_update_bits(rk3308->regmap, RK3308_ALC_L_DIG_CON09(grp),
+					   RK3308_AGC_FUNC_SEL_MSK,
+					   RK3308_AGC_FUNC_SEL_EN);
+			regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON11(grp),
+					   RK3308_ADC_ALCL_CON_GAIN_PGAL_MSK,
+					   RK3308_ADC_ALCL_CON_GAIN_PGAL_EN);
+
+			rk3308->agc_l[e->reg] = 1;
+		}
+	} else {
+		/* ALC AGC Off */
+		if (e->shift_l) {
+			/* ALC AGC Right Off */
+			regmap_update_bits(rk3308->regmap, RK3308_ALC_R_DIG_CON09(grp),
+					   RK3308_AGC_FUNC_SEL_MSK,
+					   RK3308_AGC_FUNC_SEL_DIS);
+			regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON11(grp),
+					   RK3308_ADC_ALCR_CON_GAIN_PGAR_MSK,
+					   RK3308_ADC_ALCR_CON_GAIN_PGAR_DIS);
+
+			rk3308->agc_r[e->reg] = 0;
+		} else {
+			/* ALC AGC Left Off */
+			regmap_update_bits(rk3308->regmap, RK3308_ALC_L_DIG_CON09(grp),
+					   RK3308_AGC_FUNC_SEL_MSK,
+					   RK3308_AGC_FUNC_SEL_DIS);
+			regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON11(grp),
+					   RK3308_ADC_ALCL_CON_GAIN_PGAL_MSK,
+					   RK3308_ADC_ALCL_CON_GAIN_PGAL_DIS);
+
+			rk3308->agc_l[e->reg] = 0;
+		}
+	}
+
+	return 0;
+}
+
+static int rk3308_codec_agc_asr_get(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	struct rk3308_codec_priv *rk3308 = snd_soc_component_get_drvdata(component);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	unsigned int value;
+	int grp = e->reg;
+
+	if (e->reg < 0 || e->reg > ADC_LR_GROUP_MAX - 1) {
+		dev_err(rk3308->plat_dev,
+			"%s: Invalid ADC grp: %d\n", __func__, e->reg);
+		return -EINVAL;
+	}
+
+	if (e->shift_l) {
+		regmap_read(rk3308->regmap, RK3308_ALC_R_DIG_CON04(grp), &value);
+		rk3308->agc_asr_r[e->reg] = value >> RK3308_AGC_APPROX_RATE_SFT;
+		ucontrol->value.integer.value[0] = rk3308->agc_asr_r[e->reg];
+	} else {
+		regmap_read(rk3308->regmap, RK3308_ALC_L_DIG_CON04(grp), &value);
+		rk3308->agc_asr_l[e->reg] = value >> RK3308_AGC_APPROX_RATE_SFT;
+		ucontrol->value.integer.value[0] = rk3308->agc_asr_l[e->reg];
+	}
+
+	return 0;
+}
+
+static int rk3308_codec_agc_asr_put(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	struct rk3308_codec_priv *rk3308 = snd_soc_component_get_drvdata(component);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	unsigned int value;
+	int grp = e->reg;
+
+	if (e->reg < 0 || e->reg > ADC_LR_GROUP_MAX - 1) {
+		dev_err(rk3308->plat_dev,
+			"%s: Invalid ADC grp: %d\n", __func__, e->reg);
+		return -EINVAL;
+	}
+
+	value = ucontrol->value.integer.value[0] << RK3308_AGC_APPROX_RATE_SFT;
+
+	if (e->shift_l) {
+		/* ALC AGC Right Approximate Sample Rate */
+		regmap_update_bits(rk3308->regmap, RK3308_ALC_R_DIG_CON04(grp),
+				   RK3308_AGC_APPROX_RATE_MSK,
+				   value);
+		rk3308->agc_asr_r[e->reg] = ucontrol->value.integer.value[0];
+	} else {
+		/* ALC AGC Left Approximate Sample Rate */
+		regmap_update_bits(rk3308->regmap, RK3308_ALC_L_DIG_CON04(grp),
+				   RK3308_AGC_APPROX_RATE_MSK,
+				   value);
+		rk3308->agc_asr_l[e->reg] = ucontrol->value.integer.value[0];
+	}
+
+	return 0;
+}
+
+static int rk3308_codec_mic_mute_get(struct snd_kcontrol *kcontrol,
+				     struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	struct rk3308_codec_priv *rk3308 = snd_soc_component_get_drvdata(component);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	unsigned int value;
+	int grp = e->reg;
+
+	if (e->reg < 0 || e->reg > ADC_LR_GROUP_MAX - 1) {
+		dev_err(rk3308->plat_dev,
+			"%s: Invalid ADC grp: %d\n", __func__, e->reg);
+		return -EINVAL;
+	}
+
+	if (e->shift_l) {
+		/* ADC MIC Right Mute/Work Infos */
+		regmap_read(rk3308->regmap, RK3308_ADC_DIG_CON03(grp), &value);
+		rk3308->mic_mute_r[e->reg] = (value & RK3308_ADC_R_CH_BIST_SINE) >>
+					     RK3308_ADC_R_CH_BIST_SFT;
+		ucontrol->value.integer.value[0] = rk3308->mic_mute_r[e->reg];
+	} else {
+		/* ADC MIC Left Mute/Work Infos */
+		regmap_read(rk3308->regmap, RK3308_ADC_DIG_CON03(grp), &value);
+		rk3308->mic_mute_l[e->reg] = (value & RK3308_ADC_L_CH_BIST_SINE) >>
+					     RK3308_ADC_L_CH_BIST_SFT;
+		ucontrol->value.integer.value[0] = rk3308->mic_mute_l[e->reg];
+	}
+
+	return 0;
+}
+
+static int rk3308_codec_mic_mute_put(struct snd_kcontrol *kcontrol,
+				     struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	struct rk3308_codec_priv *rk3308 = snd_soc_component_get_drvdata(component);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	unsigned int value;
+	int grp = e->reg;
+
+	if (e->reg < 0 || e->reg > ADC_LR_GROUP_MAX - 1) {
+		dev_err(rk3308->plat_dev,
+			"%s: Invalid ADC grp: %d\n", __func__, e->reg);
+		return -EINVAL;
+	}
+
+	if (e->shift_l) {
+		/* ADC MIC Right Mute/Work Configuration */
+		value = ucontrol->value.integer.value[0] << RK3308_ADC_R_CH_BIST_SFT;
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_DIG_CON03(grp),
+				   RK3308_ADC_R_CH_BIST_SINE,
+				   value);
+		rk3308->mic_mute_r[e->reg] = ucontrol->value.integer.value[0];
+	} else {
+		/* ADC MIC Left Mute/Work Configuration */
+		value = ucontrol->value.integer.value[0] << RK3308_ADC_L_CH_BIST_SFT;
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_DIG_CON03(grp),
+				   RK3308_ADC_L_CH_BIST_SINE,
+				   value);
+		rk3308->mic_mute_l[e->reg] = ucontrol->value.integer.value[0];
+	}
+
+	return 0;
+}
+
+static int rk3308_codec_micbias_volts_get(struct snd_kcontrol *kcontrol,
+					  struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	struct rk3308_codec_priv *rk3308 = snd_soc_component_get_drvdata(component);
+
+	ucontrol->value.integer.value[0] = rk3308->micbias_volt;
+
+	return 0;
+}
+
+static int rk3308_codec_micbias_volts_put(struct snd_kcontrol *kcontrol,
+					  struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	struct rk3308_codec_priv *rk3308 = snd_soc_component_get_drvdata(component);
+	unsigned int volt = ucontrol->value.integer.value[0];
+	int ret;
+
+	ret = check_micbias(volt);
+	if (ret < 0) {
+		dev_err(rk3308->plat_dev, "The invalid micbias volt: %d\n",
+			volt);
+		return ret;
+	}
+
+	regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON07(0),
+			   RK3308_ADC_LEVEL_RANGE_MICBIAS_MSK,
+			   volt);
+
+	rk3308->micbias_volt = volt;
+
+	return 0;
+}
+
+static int rk3308_codec_main_micbias_get(struct snd_kcontrol *kcontrol,
+					 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	struct rk3308_codec_priv *rk3308 = snd_soc_component_get_drvdata(component);
+
+	ucontrol->value.integer.value[0] = rk3308->enable_micbias;
+
+	return 0;
+}
+
+static int rk3308_codec_main_micbias_put(struct snd_kcontrol *kcontrol,
+					 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	struct rk3308_codec_priv *rk3308 = snd_soc_component_get_drvdata(component);
+	unsigned int on = ucontrol->value.integer.value[0];
+
+	if (on) {
+		if (!rk3308->enable_micbias)
+			rk3308_codec_micbias_enable(rk3308, rk3308->micbias_volt);
+	} else {
+		if (rk3308->enable_micbias)
+			rk3308_codec_micbias_disable(rk3308);
+	}
+
+	return 0;
+}
+
+static int rk3308_codec_mic_gain_get(struct snd_kcontrol *kcontrol,
+				     struct snd_ctl_elem_value *ucontrol)
+{
+	return snd_soc_get_volsw_range(kcontrol, ucontrol);
+}
+
+static int rk3308_codec_mic_gain_put(struct snd_kcontrol *kcontrol,
+				     struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	struct rk3308_codec_priv *rk3308 = snd_soc_component_get_drvdata(component);
+	unsigned int gain = ucontrol->value.integer.value[0];
+
+	if (gain > RK3308_ADC_CH1_MIC_GAIN_MAX) {
+		dev_err(rk3308->plat_dev, "%s: invalid mic gain: %d\n",
+			__func__, gain);
+		return -EINVAL;
+	}
+
+	if (rk3308->codec_ver == ACODEC_VERSION_A) {
+		/*
+		 * From the TRM, there are only suupport 0dB(gain==0) and
+		 * 20dB(gain==3) on the codec version A.
+		 */
+		if (!(gain == 0 || gain == RK3308_ADC_CH1_MIC_GAIN_MAX)) {
+			dev_err(rk3308->plat_dev,
+				"version A doesn't supported: %d, expect: 0,%d\n",
+				gain, RK3308_ADC_CH1_MIC_GAIN_MAX);
+			return 0;
+		}
+	}
+
+	return snd_soc_put_volsw_range(kcontrol, ucontrol);
+}
+
+static int rk3308_codec_hpf_get(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	struct rk3308_codec_priv *rk3308 = snd_soc_component_get_drvdata(component);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	unsigned int value;
+
+	if (e->reg < 0 || e->reg > ADC_LR_GROUP_MAX - 1) {
+		dev_err(rk3308->plat_dev,
+			"%s: Invalid ADC grp: %d\n", __func__, e->reg);
+		return -EINVAL;
+	}
+
+	regmap_read(rk3308->regmap, RK3308_ADC_DIG_CON04(e->reg), &value);
+	if (value & RK3308_ADC_HPF_PATH_MSK)
+		rk3308->hpf_cutoff[e->reg] = 0;
+	else
+		rk3308->hpf_cutoff[e->reg] = 1;
+
+	ucontrol->value.integer.value[0] = rk3308->hpf_cutoff[e->reg];
+
+	return 0;
+}
+
+static int rk3308_codec_hpf_put(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	struct rk3308_codec_priv *rk3308 = snd_soc_component_get_drvdata(component);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	unsigned int value = ucontrol->value.integer.value[0];
+
+	if (e->reg < 0 || e->reg > ADC_LR_GROUP_MAX - 1) {
+		dev_err(rk3308->plat_dev,
+			"%s: Invalid ADC grp: %d\n", __func__, e->reg);
+		return -EINVAL;
+	}
+
+	if (value) {
+		/* Enable high pass filter for ADCs */
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_DIG_CON04(e->reg),
+				   RK3308_ADC_HPF_PATH_MSK,
+				   RK3308_ADC_HPF_PATH_EN);
+	} else {
+		/* Disable high pass filter for ADCs. */
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_DIG_CON04(e->reg),
+				   RK3308_ADC_HPF_PATH_MSK,
+				   RK3308_ADC_HPF_PATH_DIS);
+	}
+
+	rk3308->hpf_cutoff[e->reg] = value;
+
+	return 0;
+}
+
+static int rk3308_codec_hpout_l_get_tlv(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol)
+{
+	return snd_soc_get_volsw_range(kcontrol, ucontrol);
+}
+
+static int rk3308_codec_hpout_l_put_tlv(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	struct rk3308_codec_priv *rk3308 = snd_soc_component_get_drvdata(component);
+	unsigned int dgain = ucontrol->value.integer.value[0];
+
+	if (dgain > RK3308_DAC_L_HPOUT_GAIN_MAX) {
+		dev_err(rk3308->plat_dev, "%s: invalid l_dgain: %d\n",
+			__func__, dgain);
+		return -EINVAL;
+	}
+
+	rk3308->hpout_l_dgain = dgain;
+
+	return snd_soc_put_volsw_range(kcontrol, ucontrol);
+}
+
+static int rk3308_codec_hpout_r_get_tlv(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol)
+{
+	return snd_soc_get_volsw_range(kcontrol, ucontrol);
+}
+
+static int rk3308_codec_hpout_r_put_tlv(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	struct rk3308_codec_priv *rk3308 = snd_soc_component_get_drvdata(component);
+	unsigned int dgain = ucontrol->value.integer.value[0];
+
+	if (dgain > RK3308_DAC_R_HPOUT_GAIN_MAX) {
+		dev_err(rk3308->plat_dev, "%s: invalid r_dgain: %d\n",
+			__func__, dgain);
+		return -EINVAL;
+	}
+
+	rk3308->hpout_r_dgain = dgain;
+
+	return snd_soc_put_volsw_range(kcontrol, ucontrol);
+}
+
+static u32 to_mapped_grp(struct rk3308_codec_priv *rk3308, int idx)
+{
+	return rk3308->i2s_sdis[idx];
+}
+
+static bool adc_for_each_grp(struct rk3308_codec_priv *rk3308,
+			     int type, int idx, u32 *grp)
+{
+	if (type == ADC_TYPE_NORMAL) {
+		u32 mapped_grp = to_mapped_grp(rk3308, idx);
+		int max_grps;
+
+		if (rk3308->enable_all_adcs)
+			max_grps = ADC_LR_GROUP_MAX;
+		else
+			max_grps = rk3308->used_adc_grps;
+
+		if (idx >= max_grps)
+			return false;
+
+		if ((!rk3308->loopback_dacs_enabled) &&
+		    handle_loopback(rk3308) &&
+		    rk3308->loopback_grp == mapped_grp) {
+			/*
+			 * Ths loopback DACs are closed, and specify the
+			 * loopback ADCs.
+			 */
+			*grp = ADC_GRP_SKIP_MAGIC;
+		} else if (rk3308->en_always_grps_num &&
+			   rk3308->skip_grps[mapped_grp]) {
+			/* To set the skip flag if the ADC GRP is enabled. */
+			*grp = ADC_GRP_SKIP_MAGIC;
+		} else {
+			*grp = mapped_grp;
+		}
+
+		dev_dbg(rk3308->plat_dev,
+			"ADC_TYPE_NORMAL, idx: %d, mapped_grp: %d, get grp: %d,\n",
+			idx, mapped_grp, *grp);
+	} else if (type == ADC_TYPE_ALL) {
+		if (idx >= ADC_LR_GROUP_MAX)
+			return false;
+
+		*grp = idx;
+		dev_dbg(rk3308->plat_dev,
+			"ADC_TYPE_ALL, idx: %d, get grp: %d\n",
+			idx, *grp);
+	} else if (type == ADC_TYPE_DBG) {
+		if (idx >= ADC_LR_GROUP_MAX)
+			return false;
+
+		if (idx == (int)rk3308->cur_dbg_grp)
+			*grp = idx;
+		else
+			*grp = ADC_GRP_SKIP_MAGIC;
+
+		dev_dbg(rk3308->plat_dev,
+			"ADC_TYPE_DBG, idx: %d, get grp: %d\n",
+			idx, *grp);
+	} else {
+		if (idx >= 1)
+			return false;
+
+		*grp = rk3308->loopback_grp;
+		dev_dbg(rk3308->plat_dev,
+			"ADC_TYPE_LOOPBACK, idx: %d, get grp: %d\n",
+			idx, *grp);
+	}
+
+	return true;
+}
+
+static int rk3308_codec_get_dac_path_state(struct rk3308_codec_priv *rk3308)
+{
+	return rk3308->dac_path_state;
+}
+
+static void rk3308_codec_set_dac_path_state(struct rk3308_codec_priv *rk3308,
+					    int state)
+{
+	rk3308->dac_path_state = state;
+}
+
+static void rk3308_headphone_ctl(struct rk3308_codec_priv *rk3308, int on)
+{
+	if (rk3308->hp_ctl_gpio)
+		gpiod_direction_output(rk3308->hp_ctl_gpio, on);
+}
+
+static void rk3308_speaker_ctl(struct rk3308_codec_priv *rk3308, int on)
+{
+	if (on) {
+		if (rk3308->pa_drv_gpio) {
+			gpiod_direction_output(rk3308->pa_drv_gpio, on);
+			msleep(rk3308->delay_pa_drv_ms);
+		}
+
+		if (rk3308->spk_ctl_gpio)
+			gpiod_direction_output(rk3308->spk_ctl_gpio, on);
+	} else {
+		if (rk3308->spk_ctl_gpio)
+			gpiod_direction_output(rk3308->spk_ctl_gpio, on);
+
+		if (rk3308->pa_drv_gpio) {
+			msleep(rk3308->delay_pa_drv_ms);
+			gpiod_direction_output(rk3308->pa_drv_gpio, on);
+		}
+	}
+}
+
+static int rk3308_codec_reset(struct snd_soc_component *component)
+{
+	struct rk3308_codec_priv *rk3308 = snd_soc_component_get_drvdata(component);
+
+	reset_control_assert(rk3308->reset);
+	usleep_range(2000, 2500);	/* estimated value */
+	reset_control_deassert(rk3308->reset);
+
+	regmap_write(rk3308->regmap, RK3308_GLB_CON, 0x00);
+	usleep_range(200, 300);		/* estimated value */
+	regmap_write(rk3308->regmap, RK3308_GLB_CON,
+		     RK3308_SYS_WORK |
+		     RK3308_DAC_DIG_WORK |
+		     RK3308_ADC_DIG_WORK);
+
+	return 0;
+}
+
+static int rk3308_codec_adc_dig_reset(struct rk3308_codec_priv *rk3308)
+{
+	regmap_update_bits(rk3308->regmap, RK3308_GLB_CON,
+			   RK3308_ADC_DIG_WORK,
+			   RK3308_ADC_DIG_RESET);
+	udelay(50);
+	regmap_update_bits(rk3308->regmap, RK3308_GLB_CON,
+			   RK3308_ADC_DIG_WORK,
+			   RK3308_ADC_DIG_WORK);
+
+	return 0;
+}
+
+static int rk3308_codec_dac_dig_reset(struct rk3308_codec_priv *rk3308)
+{
+	regmap_update_bits(rk3308->regmap, RK3308_GLB_CON,
+			   RK3308_DAC_DIG_WORK,
+			   RK3308_DAC_DIG_RESET);
+	udelay(50);
+	regmap_update_bits(rk3308->regmap, RK3308_GLB_CON,
+			   RK3308_DAC_DIG_WORK,
+			   RK3308_DAC_DIG_WORK);
+
+	return 0;
+}
+
+static int rk3308_set_bias_level(struct snd_soc_component *component,
+				 enum snd_soc_bias_level level)
+{
+	struct rk3308_codec_priv *rk3308 = snd_soc_component_get_drvdata(component);
+
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+		break;
+	case SND_SOC_BIAS_PREPARE:
+		break;
+	case SND_SOC_BIAS_STANDBY:
+		regcache_cache_only(rk3308->regmap, false);
+		regcache_sync(rk3308->regmap);
+		break;
+	case SND_SOC_BIAS_OFF:
+		break;
+	}
+
+	return 0;
+}
+
+static int rk3308_set_dai_fmt(struct snd_soc_dai *dai,
+			      unsigned int fmt)
+{
+	struct snd_soc_component *component = dai->component;
+	struct rk3308_codec_priv *rk3308 = snd_soc_component_get_drvdata(component);
+	unsigned int adc_aif1 = 0, adc_aif2 = 0, dac_aif1 = 0, dac_aif2 = 0;
+	int idx, grp, is_master;
+	int type = ADC_TYPE_ALL;
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		adc_aif2 |= RK3308_ADC_IO_MODE_SLAVE;
+		adc_aif2 |= RK3308_ADC_MODE_SLAVE;
+		dac_aif2 |= RK3308_DAC_IO_MODE_SLAVE;
+		dac_aif2 |= RK3308_DAC_MODE_SLAVE;
+		is_master = 0;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFM:
+		adc_aif2 |= RK3308_ADC_IO_MODE_MASTER;
+		adc_aif2 |= RK3308_ADC_MODE_MASTER;
+		dac_aif2 |= RK3308_DAC_IO_MODE_MASTER;
+		dac_aif2 |= RK3308_DAC_MODE_MASTER;
+		is_master = 1;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_DSP_A:
+		adc_aif1 |= RK3308_ADC_I2S_MODE_PCM;
+		dac_aif1 |= RK3308_DAC_I2S_MODE_PCM;
+		break;
+	case SND_SOC_DAIFMT_I2S:
+		adc_aif1 |= RK3308_ADC_I2S_MODE_I2S;
+		dac_aif1 |= RK3308_DAC_I2S_MODE_I2S;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		adc_aif1 |= RK3308_ADC_I2S_MODE_RJ;
+		dac_aif1 |= RK3308_DAC_I2S_MODE_RJ;
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		adc_aif1 |= RK3308_ADC_I2S_MODE_LJ;
+		dac_aif1 |= RK3308_DAC_I2S_MODE_LJ;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		adc_aif1 |= RK3308_ADC_I2S_LRC_POL_NORMAL;
+		adc_aif2 |= RK3308_ADC_I2S_BIT_CLK_POL_NORMAL;
+		dac_aif1 |= RK3308_DAC_I2S_LRC_POL_NORMAL;
+		dac_aif2 |= RK3308_DAC_I2S_BIT_CLK_POL_NORMAL;
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		adc_aif1 |= RK3308_ADC_I2S_LRC_POL_REVERSAL;
+		adc_aif2 |= RK3308_ADC_I2S_BIT_CLK_POL_REVERSAL;
+		dac_aif1 |= RK3308_DAC_I2S_LRC_POL_REVERSAL;
+		dac_aif2 |= RK3308_DAC_I2S_BIT_CLK_POL_REVERSAL;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		adc_aif1 |= RK3308_ADC_I2S_LRC_POL_NORMAL;
+		adc_aif2 |= RK3308_ADC_I2S_BIT_CLK_POL_REVERSAL;
+		dac_aif1 |= RK3308_DAC_I2S_LRC_POL_NORMAL;
+		dac_aif2 |= RK3308_DAC_I2S_BIT_CLK_POL_REVERSAL;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		adc_aif1 |= RK3308_ADC_I2S_LRC_POL_REVERSAL;
+		adc_aif2 |= RK3308_ADC_I2S_BIT_CLK_POL_NORMAL;
+		dac_aif1 |= RK3308_DAC_I2S_LRC_POL_REVERSAL;
+		dac_aif2 |= RK3308_DAC_I2S_BIT_CLK_POL_NORMAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/*
+	 * Hold ADC Digital registers start at master mode
+	 *
+	 * There are 8 ADCs and use the same SCLK and LRCK internal for master
+	 * mode, We need to make sure that they are in effect at the same time,
+	 * otherwise they will cause the abnormal clocks.
+	 */
+	if (is_master)
+		regmap_update_bits(rk3308->regmap, RK3308_GLB_CON,
+				   RK3308_ADC_DIG_WORK,
+				   RK3308_ADC_DIG_RESET);
+
+	for (idx = 0; adc_for_each_grp(rk3308, type, idx, &grp); idx++) {
+		if (grp < 0 || grp > ADC_LR_GROUP_MAX - 1)
+			continue;
+
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_DIG_CON01(grp),
+				   RK3308_ADC_I2S_LRC_POL_MSK |
+				   RK3308_ADC_I2S_MODE_MSK,
+				   adc_aif1);
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_DIG_CON02(grp),
+				   RK3308_ADC_IO_MODE_MSK |
+				   RK3308_ADC_MODE_MSK |
+				   RK3308_ADC_I2S_BIT_CLK_POL_MSK,
+				   adc_aif2);
+	}
+
+	/* Hold ADC Digital registers end at master mode */
+	if (is_master)
+		regmap_update_bits(rk3308->regmap, RK3308_GLB_CON,
+				   RK3308_ADC_DIG_WORK,
+				   RK3308_ADC_DIG_WORK);
+
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_DIG_CON01,
+			   RK3308_DAC_I2S_LRC_POL_MSK |
+			   RK3308_DAC_I2S_MODE_MSK,
+			   dac_aif1);
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_DIG_CON02,
+			   RK3308_DAC_IO_MODE_MSK |
+			   RK3308_DAC_MODE_MSK |
+			   RK3308_DAC_I2S_BIT_CLK_POL_MSK,
+			   dac_aif2);
+
+	return 0;
+}
+
+static int rk3308_codec_dac_dig_config(struct rk3308_codec_priv *rk3308,
+				       struct snd_pcm_hw_params *params)
+{
+	unsigned int dac_aif1 = 0, dac_aif2 = 0;
+
+	/* Clear the status of DAC DIG Digital reigisters */
+	rk3308_codec_dac_dig_reset(rk3308);
+
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		dac_aif1 |= RK3308_DAC_I2S_VALID_LEN_16BITS;
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+		dac_aif1 |= RK3308_DAC_I2S_VALID_LEN_20BITS;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		dac_aif1 |= RK3308_DAC_I2S_VALID_LEN_24BITS;
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		dac_aif1 |= RK3308_DAC_I2S_VALID_LEN_32BITS;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	dac_aif1 |= RK3308_DAC_I2S_LR_NORMAL;
+	dac_aif2 |= RK3308_DAC_I2S_WORK;
+
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_DIG_CON01,
+			   RK3308_DAC_I2S_VALID_LEN_MSK |
+			   RK3308_DAC_I2S_LR_MSK,
+			   dac_aif1);
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_DIG_CON02,
+			   RK3308_DAC_I2S_MSK,
+			   dac_aif2);
+
+	return 0;
+}
+
+static int rk3308_codec_adc_dig_config(struct rk3308_codec_priv *rk3308,
+				       struct snd_pcm_hw_params *params)
+{
+	unsigned int adc_aif1 = 0, adc_aif2 = 0;
+	int type = ADC_TYPE_NORMAL;
+	int idx, grp;
+
+	/* Clear the status of ADC DIG Digital reigisters */
+	rk3308_codec_adc_dig_reset(rk3308);
+
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		adc_aif1 |= RK3308_ADC_I2S_VALID_LEN_16BITS;
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+		adc_aif1 |= RK3308_ADC_I2S_VALID_LEN_20BITS;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		adc_aif1 |= RK3308_ADC_I2S_VALID_LEN_24BITS;
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		adc_aif1 |= RK3308_ADC_I2S_VALID_LEN_32BITS;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (params_channels(params)) {
+	case 1:
+		adc_aif1 |= RK3308_ADC_I2S_MONO;
+		break;
+	case 2:
+	case 4:
+	case 6:
+	case 8:
+		adc_aif1 |= RK3308_ADC_I2S_STEREO;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	adc_aif1 |= RK3308_ADC_I2S_LR_NORMAL;
+	adc_aif2 |= RK3308_ADC_I2S_WORK;
+
+	for (idx = 0; adc_for_each_grp(rk3308, type, idx, &grp); idx++) {
+		if (grp < 0 || grp > ADC_LR_GROUP_MAX - 1)
+			continue;
+
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_DIG_CON01(grp),
+				   RK3308_ADC_I2S_VALID_LEN_MSK |
+				   RK3308_ADC_I2S_LR_MSK |
+				   RK3308_ADC_I2S_TYPE_MSK,
+				   adc_aif1);
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_DIG_CON02(grp),
+				   RK3308_ADC_I2S_MSK,
+				   adc_aif2);
+	}
+
+	return 0;
+}
+
+static int rk3308_codec_update_adc_grps(struct rk3308_codec_priv *rk3308,
+					struct snd_pcm_hw_params *params)
+{
+	switch (params_channels(params)) {
+	case 1:
+		rk3308->used_adc_grps = 1;
+		break;
+	case 2:
+	case 4:
+	case 6:
+	case 8:
+		rk3308->used_adc_grps = params_channels(params) / 2;
+		break;
+	default:
+		dev_err(rk3308->plat_dev, "Invalid channels: %d\n",
+			params_channels(params));
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int rk3308_mute_stream(struct snd_soc_dai *dai, int mute, int stream)
+{
+	struct snd_soc_component *component = dai->component;
+	struct rk3308_codec_priv *rk3308 = snd_soc_component_get_drvdata(component);
+
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		int dgain;
+
+		if (mute) {
+			for (dgain = 0x2; dgain <= 0x7; dgain++) {
+				/*
+				 * Keep the max -> min digital CIC interpolation
+				 * filter gain step by step.
+				 *
+				 * loud: 0x2; whisper: 0x7
+				 */
+				regmap_update_bits(rk3308->regmap,
+						   RK3308_DAC_DIG_CON04,
+						   RK3308_DAC_CIC_IF_GAIN_MSK,
+						   dgain);
+				usleep_range(200, 300);  /* estimated value */
+			}
+
+#if !DEBUG_POP_ALWAYS
+			rk3308_headphone_ctl(rk3308, 0);
+			rk3308_speaker_ctl(rk3308, 0);
+#endif
+		} else {
+#if !DEBUG_POP_ALWAYS
+			if (rk3308->dac_output == DAC_LINEOUT)
+				rk3308_speaker_ctl(rk3308, 1);
+			else if (rk3308->dac_output == DAC_HPOUT)
+				rk3308_headphone_ctl(rk3308, 1);
+
+			if (rk3308->delay_start_play_ms)
+				msleep(rk3308->delay_start_play_ms);
+#endif
+			for (dgain = 0x7; dgain >= 0x2; dgain--) {
+				/*
+				 * Keep the min -> max digital CIC interpolation
+				 * filter gain step by step
+				 *
+				 * loud: 0x2; whisper: 0x7
+				 */
+				regmap_update_bits(rk3308->regmap,
+						   RK3308_DAC_DIG_CON04,
+						   RK3308_DAC_CIC_IF_GAIN_MSK,
+						   dgain);
+				usleep_range(200, 300);  /* estimated value */
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int rk3308_codec_digital_fadein(struct rk3308_codec_priv *rk3308)
+{
+	unsigned int dgain, dgain_ref;
+
+	if (rk3308->hpout_l_dgain != rk3308->hpout_r_dgain) {
+		pr_warn("HPOUT l_dgain: 0x%x != r_dgain: 0x%x\n",
+			rk3308->hpout_l_dgain, rk3308->hpout_r_dgain);
+		dgain_ref = min(rk3308->hpout_l_dgain, rk3308->hpout_r_dgain);
+	} else {
+		dgain_ref = rk3308->hpout_l_dgain;
+	}
+
+	/*
+	 * We'd better change the gain of the left and right channels
+	 * at the same time to avoid different listening
+	 */
+	for (dgain = RK3308_DAC_L_HPOUT_GAIN_NDB_39;
+	     dgain <= dgain_ref; dgain++) {
+		/* Step 02 decrease dgains for de-pop */
+		regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON05,
+				   RK3308_DAC_L_HPOUT_GAIN_MSK,
+				   dgain);
+
+		/* Step 02 decrease dgains for de-pop */
+		regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON06,
+				   RK3308_DAC_R_HPOUT_GAIN_MSK,
+				   dgain);
+	}
+
+	return 0;
+}
+
+static int rk3308_codec_digital_fadeout(struct rk3308_codec_priv *rk3308)
+{
+	unsigned int l_dgain, r_dgain;
+
+	/*
+	 * Note. In the step2, adjusting the register step by step to
+	 * the appropriate value and taking 20ms as time step
+	 */
+	regmap_read(rk3308->regmap, RK3308_DAC_ANA_CON05, &l_dgain);
+	l_dgain &= RK3308_DAC_L_HPOUT_GAIN_MSK;
+
+	regmap_read(rk3308->regmap, RK3308_DAC_ANA_CON06, &r_dgain);
+	r_dgain &= RK3308_DAC_R_HPOUT_GAIN_MSK;
+
+	if (l_dgain != r_dgain) {
+		pr_warn("HPOUT l_dgain: 0x%x != r_dgain: 0x%x\n",
+			l_dgain, r_dgain);
+		l_dgain = min(l_dgain, r_dgain);
+	}
+
+	/*
+	 * We'd better change the gain of the left and right channels
+	 * at the same time to avoid different listening
+	 */
+	while (l_dgain >= RK3308_DAC_L_HPOUT_GAIN_NDB_39) {
+		/* Step 02 decrease dgains for de-pop */
+		regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON05,
+				   RK3308_DAC_L_HPOUT_GAIN_MSK,
+				   l_dgain);
+
+		/* Step 02 decrease dgains for de-pop */
+		regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON06,
+				   RK3308_DAC_R_HPOUT_GAIN_MSK,
+				   l_dgain);
+
+		usleep_range(200, 300);  /* estimated value */
+
+		if (l_dgain == RK3308_DAC_L_HPOUT_GAIN_NDB_39)
+			break;
+
+		l_dgain--;
+	}
+
+	return 0;
+}
+
+static int rk3308_codec_dac_lineout_enable(struct rk3308_codec_priv *rk3308)
+{
+	if (rk3308->codec_ver == ACODEC_VERSION_B) {
+		/* Step 04 */
+		regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON15,
+				   RK3308_DAC_LINEOUT_POP_SOUND_L_MSK |
+				   RK3308_DAC_LINEOUT_POP_SOUND_R_MSK,
+				   RK3308_DAC_L_SEL_DC_FROM_INTERNAL |
+				   RK3308_DAC_R_SEL_DC_FROM_INTERNAL);
+	}
+
+	/* Step 07 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON04,
+			   RK3308_DAC_L_LINEOUT_EN |
+			   RK3308_DAC_R_LINEOUT_EN,
+			   RK3308_DAC_L_LINEOUT_EN |
+			   RK3308_DAC_R_LINEOUT_EN);
+
+	udelay(20);
+
+	if (rk3308->codec_ver == ACODEC_VERSION_B) {
+		/* Step 10 */
+		regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON15,
+				   RK3308_DAC_LINEOUT_POP_SOUND_L_MSK |
+				   RK3308_DAC_LINEOUT_POP_SOUND_R_MSK,
+				   RK3308_DAC_L_SEL_LINEOUT_FROM_INTERNAL |
+				   RK3308_DAC_R_SEL_LINEOUT_FROM_INTERNAL);
+
+		udelay(20);
+	}
+
+	/* Step 19 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON04,
+			   RK3308_DAC_L_LINEOUT_UNMUTE |
+			   RK3308_DAC_R_LINEOUT_UNMUTE,
+			   RK3308_DAC_L_LINEOUT_UNMUTE |
+			   RK3308_DAC_R_LINEOUT_UNMUTE);
+	udelay(20);
+
+	return 0;
+}
+
+static int rk3308_codec_dac_lineout_disable(struct rk3308_codec_priv *rk3308)
+{
+	/* Step 08 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON04,
+			   RK3308_DAC_L_LINEOUT_UNMUTE |
+			   RK3308_DAC_R_LINEOUT_UNMUTE,
+			   RK3308_DAC_L_LINEOUT_MUTE |
+			   RK3308_DAC_R_LINEOUT_MUTE);
+
+	/* Step 09 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON04,
+			   RK3308_DAC_L_LINEOUT_EN |
+			   RK3308_DAC_R_LINEOUT_EN,
+			   RK3308_DAC_L_LINEOUT_DIS |
+			   RK3308_DAC_R_LINEOUT_DIS);
+
+	return 0;
+}
+
+static int rk3308_codec_dac_hpout_enable(struct rk3308_codec_priv *rk3308)
+{
+	/* Step 03 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON01,
+			   RK3308_DAC_HPOUT_POP_SOUND_L_MSK |
+			   RK3308_DAC_HPOUT_POP_SOUND_R_MSK,
+			   RK3308_DAC_HPOUT_POP_SOUND_L_WORK |
+			   RK3308_DAC_HPOUT_POP_SOUND_R_WORK);
+
+	udelay(20);
+
+	/* Step 07 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON03,
+			   RK3308_DAC_L_HPOUT_EN |
+			   RK3308_DAC_R_HPOUT_EN,
+			   RK3308_DAC_L_HPOUT_EN |
+			   RK3308_DAC_R_HPOUT_EN);
+
+	udelay(20);
+
+	/* Step 08 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON03,
+			   RK3308_DAC_L_HPOUT_WORK |
+			   RK3308_DAC_R_HPOUT_WORK,
+			   RK3308_DAC_L_HPOUT_WORK |
+			   RK3308_DAC_R_HPOUT_WORK);
+
+	udelay(20);
+
+	/* Step 16 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON03,
+			   RK3308_DAC_L_HPOUT_UNMUTE |
+			   RK3308_DAC_R_HPOUT_UNMUTE,
+			   RK3308_DAC_L_HPOUT_UNMUTE |
+			   RK3308_DAC_R_HPOUT_UNMUTE);
+
+	udelay(20);
+
+	return 0;
+}
+
+static int rk3308_codec_dac_hpout_disable(struct rk3308_codec_priv *rk3308)
+{
+	/* Step 03 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON01,
+			   RK3308_DAC_HPOUT_POP_SOUND_L_MSK |
+			   RK3308_DAC_HPOUT_POP_SOUND_R_MSK,
+			   RK3308_DAC_HPOUT_POP_SOUND_L_INIT |
+			   RK3308_DAC_HPOUT_POP_SOUND_R_INIT);
+
+	/* Step 07 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON03,
+			   RK3308_DAC_L_HPOUT_EN |
+			   RK3308_DAC_R_HPOUT_EN,
+			   RK3308_DAC_L_HPOUT_DIS |
+			   RK3308_DAC_R_HPOUT_DIS);
+
+	/* Step 08 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON03,
+			   RK3308_DAC_L_HPOUT_WORK |
+			   RK3308_DAC_R_HPOUT_WORK,
+			   RK3308_DAC_L_HPOUT_INIT |
+			   RK3308_DAC_R_HPOUT_INIT);
+
+	/* Step 16 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON03,
+			   RK3308_DAC_L_HPOUT_UNMUTE |
+			   RK3308_DAC_R_HPOUT_UNMUTE,
+			   RK3308_DAC_L_HPOUT_MUTE |
+			   RK3308_DAC_R_HPOUT_MUTE);
+
+	return 0;
+}
+
+static int rk3308_codec_dac_switch(struct rk3308_codec_priv *rk3308,
+				   int dac_output)
+{	int ret = 0;
+
+	if (rk3308->dac_output == dac_output) {
+		dev_info(rk3308->plat_dev,
+			 "Don't need to change dac_output: %d\n", dac_output);
+		goto out;
+	}
+
+	switch (dac_output) {
+	case DAC_LINEOUT:
+	case DAC_HPOUT:
+	case DAC_LINEOUT_HPOUT:
+		break;
+	default:
+		dev_err(rk3308->plat_dev, "Unknown value: %d\n", dac_output);
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if (rk3308_codec_get_dac_path_state(rk3308) == PATH_BUSY) {
+		/*
+		 * We can only switch the audio path to LINEOUT or HPOUT on
+		 * codec during playbacking, otherwise, just update the
+		 * dac_output flag.
+		 */
+		switch (dac_output) {
+		case DAC_LINEOUT:
+			rk3308_headphone_ctl(rk3308, 0);
+			rk3308_speaker_ctl(rk3308, 1);
+			rk3308_codec_dac_hpout_disable(rk3308);
+			rk3308_codec_dac_lineout_enable(rk3308);
+			break;
+		case DAC_HPOUT:
+			rk3308_speaker_ctl(rk3308, 0);
+			rk3308_headphone_ctl(rk3308, 1);
+			rk3308_codec_dac_lineout_disable(rk3308);
+			rk3308_codec_dac_hpout_enable(rk3308);
+			break;
+		case DAC_LINEOUT_HPOUT:
+			rk3308_speaker_ctl(rk3308, 1);
+			rk3308_headphone_ctl(rk3308, 1);
+			rk3308_codec_dac_lineout_enable(rk3308);
+			rk3308_codec_dac_hpout_enable(rk3308);
+			break;
+		default:
+			break;
+		}
+	}
+
+	rk3308->dac_output = dac_output;
+out:
+	dev_dbg(rk3308->plat_dev, "switch dac_output to: %d\n",
+		rk3308->dac_output);
+
+	return ret;
+}
+
+static int rk3308_codec_dac_enable(struct rk3308_codec_priv *rk3308)
+{
+	/*
+	 * Note1. If the ACODEC_DAC_ANA_CON12[6] or ACODEC_DAC_ANA_CON12[2]
+	 * is set to 0x1, ignoring the step9~12.
+	 */
+
+	/*
+	 * Note2. If the ACODEC_ DAC_ANA_CON12[7] or ACODEC_DAC_ANA_CON12[3]
+	 * is set to 0x1, the ADC0 or ADC1 should be enabled firstly, and
+	 * please refer to Enable ADC Configuration Standard Usage Flow(expect
+	 * step7~step9,step14).
+	 */
+
+	/*
+	 * Note3. If no opening the line out, ignoring the step6, step17 and
+	 * step19.
+	 */
+
+	/*
+	 * Note4. If no opening the headphone out, ignoring the step3,step7~8,
+	 * step16 and step18.
+	 */
+
+	/*
+	 * Note5. In the step18, adjust the register step by step to the
+	 * appropriate value and taking 10ms as one time step
+	 */
+
+	/*
+	 * 1. Set the ACODEC_DAC_ANA_CON0[0] to 0x1, to enable the current
+	 * source of DAC
+	 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON00,
+			   RK3308_DAC_CURRENT_MSK,
+			   RK3308_DAC_CURRENT_EN);
+
+	udelay(20);
+
+	/*
+	 * 2. Set the ACODEC_DAC_ANA_CON1[6] and ACODEC_DAC_ANA_CON1[2] to 0x1,
+	 * to enable the reference voltage buffer
+	 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON01,
+			   RK3308_DAC_BUF_REF_L_MSK |
+			   RK3308_DAC_BUF_REF_R_MSK,
+			   RK3308_DAC_BUF_REF_L_EN |
+			   RK3308_DAC_BUF_REF_R_EN);
+
+	/* Waiting the stable reference voltage */
+	mdelay(1);
+
+	if (rk3308->dac_output == DAC_HPOUT ||
+	    rk3308->dac_output == DAC_LINEOUT_HPOUT) {
+		/* Step 03 */
+		regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON01,
+				   RK3308_DAC_HPOUT_POP_SOUND_L_MSK |
+				   RK3308_DAC_HPOUT_POP_SOUND_R_MSK,
+				   RK3308_DAC_HPOUT_POP_SOUND_L_WORK |
+				   RK3308_DAC_HPOUT_POP_SOUND_R_WORK);
+
+		udelay(20);
+	}
+
+	if (rk3308->codec_ver == ACODEC_VERSION_B &&
+	    (rk3308->dac_output == DAC_LINEOUT ||
+	     rk3308->dac_output == DAC_LINEOUT_HPOUT)) {
+		/* Step 04 */
+		regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON15,
+				   RK3308_DAC_LINEOUT_POP_SOUND_L_MSK |
+				   RK3308_DAC_LINEOUT_POP_SOUND_R_MSK,
+				   RK3308_DAC_L_SEL_DC_FROM_INTERNAL |
+				   RK3308_DAC_R_SEL_DC_FROM_INTERNAL);
+
+		udelay(20);
+	}
+
+	/* Step 05 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON13,
+			   RK3308_DAC_L_HPMIX_EN |
+			   RK3308_DAC_R_HPMIX_EN,
+			   RK3308_DAC_L_HPMIX_EN |
+			   RK3308_DAC_R_HPMIX_EN);
+
+	/* Waiting the stable HPMIX */
+	mdelay(1);
+
+	/* Step 06. Reset HPMIX and recover HPMIX gains */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON13,
+			   RK3308_DAC_L_HPMIX_WORK |
+			   RK3308_DAC_R_HPMIX_WORK,
+			   RK3308_DAC_L_HPMIX_INIT |
+			   RK3308_DAC_R_HPMIX_INIT);
+	udelay(50);
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON13,
+			   RK3308_DAC_L_HPMIX_WORK |
+			   RK3308_DAC_R_HPMIX_WORK,
+			   RK3308_DAC_L_HPMIX_WORK |
+			   RK3308_DAC_R_HPMIX_WORK);
+
+	udelay(20);
+
+	if (rk3308->dac_output == DAC_LINEOUT ||
+	    rk3308->dac_output == DAC_LINEOUT_HPOUT) {
+		/* Step 07 */
+		regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON04,
+				   RK3308_DAC_L_LINEOUT_EN |
+				   RK3308_DAC_R_LINEOUT_EN,
+				   RK3308_DAC_L_LINEOUT_EN |
+				   RK3308_DAC_R_LINEOUT_EN);
+
+		udelay(20);
+	}
+
+	if (rk3308->dac_output == DAC_HPOUT ||
+	    rk3308->dac_output == DAC_LINEOUT_HPOUT) {
+		/* Step 08 */
+		regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON03,
+				   RK3308_DAC_L_HPOUT_EN |
+				   RK3308_DAC_R_HPOUT_EN,
+				   RK3308_DAC_L_HPOUT_EN |
+				   RK3308_DAC_R_HPOUT_EN);
+
+		udelay(20);
+
+		/* Step 09 */
+		regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON03,
+				   RK3308_DAC_L_HPOUT_WORK |
+				   RK3308_DAC_R_HPOUT_WORK,
+				   RK3308_DAC_L_HPOUT_WORK |
+				   RK3308_DAC_R_HPOUT_WORK);
+
+		udelay(20);
+	}
+
+	if (rk3308->codec_ver == ACODEC_VERSION_B) {
+		/* Step 10 */
+		regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON15,
+				   RK3308_DAC_LINEOUT_POP_SOUND_L_MSK |
+				   RK3308_DAC_LINEOUT_POP_SOUND_R_MSK,
+				   RK3308_DAC_L_SEL_LINEOUT_FROM_INTERNAL |
+				   RK3308_DAC_R_SEL_LINEOUT_FROM_INTERNAL);
+
+		udelay(20);
+	}
+
+	/* Step 11 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON02,
+			   RK3308_DAC_L_REF_EN |
+			   RK3308_DAC_R_REF_EN,
+			   RK3308_DAC_L_REF_EN |
+			   RK3308_DAC_R_REF_EN);
+
+	udelay(20);
+
+	/* Step 12 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON02,
+			   RK3308_DAC_L_CLK_EN |
+			   RK3308_DAC_R_CLK_EN,
+			   RK3308_DAC_L_CLK_EN |
+			   RK3308_DAC_R_CLK_EN);
+
+	udelay(20);
+
+	/* Step 13 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON02,
+			   RK3308_DAC_L_DAC_EN |
+			   RK3308_DAC_R_DAC_EN,
+			   RK3308_DAC_L_DAC_EN |
+			   RK3308_DAC_R_DAC_EN);
+
+	udelay(20);
+
+	/* Step 14 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON02,
+			   RK3308_DAC_L_DAC_WORK |
+			   RK3308_DAC_R_DAC_WORK,
+			   RK3308_DAC_L_DAC_WORK |
+			   RK3308_DAC_R_DAC_WORK);
+
+	udelay(20);
+
+	/* Step 15 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON12,
+			   RK3308_DAC_L_HPMIX_SEL_MSK |
+			   RK3308_DAC_R_HPMIX_SEL_MSK,
+			   RK3308_DAC_L_HPMIX_I2S |
+			   RK3308_DAC_R_HPMIX_I2S);
+
+	udelay(20);
+
+	/* Step 16 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON13,
+			   RK3308_DAC_L_HPMIX_UNMUTE |
+			   RK3308_DAC_R_HPMIX_UNMUTE,
+			   RK3308_DAC_L_HPMIX_UNMUTE |
+			   RK3308_DAC_R_HPMIX_UNMUTE);
+
+	udelay(20);
+
+	/* Step 17: Put configuration HPMIX Gain to DAPM */
+
+	if (rk3308->dac_output == DAC_HPOUT ||
+	    rk3308->dac_output == DAC_LINEOUT_HPOUT) {
+		/* Step 18 */
+		regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON03,
+				   RK3308_DAC_L_HPOUT_UNMUTE |
+				   RK3308_DAC_R_HPOUT_UNMUTE,
+				   RK3308_DAC_L_HPOUT_UNMUTE |
+				   RK3308_DAC_R_HPOUT_UNMUTE);
+
+		udelay(20);
+	}
+
+	if (rk3308->dac_output == DAC_LINEOUT ||
+	    rk3308->dac_output == DAC_LINEOUT_HPOUT) {
+		/* Step 19 */
+		regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON04,
+				   RK3308_DAC_L_LINEOUT_UNMUTE |
+				   RK3308_DAC_R_LINEOUT_UNMUTE,
+				   RK3308_DAC_L_LINEOUT_UNMUTE |
+				   RK3308_DAC_R_LINEOUT_UNMUTE);
+		udelay(20);
+	}
+
+	/* Step 20, put configuration HPOUT gain to DAPM control */
+	/* Step 21, put configuration LINEOUT gain to DAPM control */
+
+	if (rk3308->dac_output == DAC_HPOUT ||
+	    rk3308->dac_output == DAC_LINEOUT_HPOUT) {
+		/* Just for HPOUT */
+		rk3308_codec_digital_fadein(rk3308);
+	}
+
+	rk3308->dac_endisable = true;
+
+	/* TODO: TRY TO TEST DRIVE STRENGTH */
+
+	return 0;
+}
+
+static int rk3308_codec_dac_disable(struct rk3308_codec_priv *rk3308)
+{
+	/*
+	 * Step 00 skipped. Keep the DAC channel work and input the mute signal.
+	 */
+
+	/* Step 01 skipped. May set the min gain for LINEOUT. */
+
+	/* Step 02 skipped. May set the min gain for HPOUT. */
+
+	if (rk3308->dac_output == DAC_HPOUT ||
+	    rk3308->dac_output == DAC_LINEOUT_HPOUT) {
+		/* Just for HPOUT */
+		rk3308_codec_digital_fadeout(rk3308);
+	}
+
+	/* Step 03 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON13,
+			   RK3308_DAC_L_HPMIX_UNMUTE |
+			   RK3308_DAC_R_HPMIX_UNMUTE,
+			   RK3308_DAC_L_HPMIX_UNMUTE |
+			   RK3308_DAC_R_HPMIX_UNMUTE);
+
+	/* Step 04 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON12,
+			   RK3308_DAC_L_HPMIX_SEL_MSK |
+			   RK3308_DAC_R_HPMIX_SEL_MSK,
+			   RK3308_DAC_L_HPMIX_NONE |
+			   RK3308_DAC_R_HPMIX_NONE);
+	/* Step 05 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON03,
+			   RK3308_DAC_L_HPOUT_UNMUTE |
+			   RK3308_DAC_R_HPOUT_UNMUTE,
+			   RK3308_DAC_L_HPOUT_MUTE |
+			   RK3308_DAC_R_HPOUT_MUTE);
+
+	/* Step 06 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON02,
+			   RK3308_DAC_L_DAC_WORK |
+			   RK3308_DAC_R_DAC_WORK,
+			   RK3308_DAC_L_DAC_INIT |
+			   RK3308_DAC_R_DAC_INIT);
+
+	/* Step 07 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON03,
+			   RK3308_DAC_L_HPOUT_EN |
+			   RK3308_DAC_R_HPOUT_EN,
+			   RK3308_DAC_L_HPOUT_DIS |
+			   RK3308_DAC_R_HPOUT_DIS);
+
+	/* Step 08 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON04,
+			   RK3308_DAC_L_LINEOUT_UNMUTE |
+			   RK3308_DAC_R_LINEOUT_UNMUTE,
+			   RK3308_DAC_L_LINEOUT_MUTE |
+			   RK3308_DAC_R_LINEOUT_MUTE);
+
+	/* Step 09 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON04,
+			   RK3308_DAC_L_LINEOUT_EN |
+			   RK3308_DAC_R_LINEOUT_EN,
+			   RK3308_DAC_L_LINEOUT_DIS |
+			   RK3308_DAC_R_LINEOUT_DIS);
+
+	/* Step 10 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON13,
+			   RK3308_DAC_L_HPMIX_EN |
+			   RK3308_DAC_R_HPMIX_EN,
+			   RK3308_DAC_L_HPMIX_DIS |
+			   RK3308_DAC_R_HPMIX_DIS);
+
+	/* Step 11 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON02,
+			   RK3308_DAC_L_DAC_EN |
+			   RK3308_DAC_R_DAC_EN,
+			   RK3308_DAC_L_DAC_DIS |
+			   RK3308_DAC_R_DAC_DIS);
+
+	/* Step 12 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON02,
+			   RK3308_DAC_L_CLK_EN |
+			   RK3308_DAC_R_CLK_EN,
+			   RK3308_DAC_L_CLK_DIS |
+			   RK3308_DAC_R_CLK_DIS);
+
+	/* Step 13 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON02,
+			   RK3308_DAC_L_REF_EN |
+			   RK3308_DAC_R_REF_EN,
+			   RK3308_DAC_L_REF_DIS |
+			   RK3308_DAC_R_REF_DIS);
+
+	/* Step 14 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON01,
+			   RK3308_DAC_HPOUT_POP_SOUND_L_MSK |
+			   RK3308_DAC_HPOUT_POP_SOUND_R_MSK,
+			   RK3308_DAC_HPOUT_POP_SOUND_L_INIT |
+			   RK3308_DAC_HPOUT_POP_SOUND_R_INIT);
+
+	/* Step 15 */
+	if (rk3308->codec_ver == ACODEC_VERSION_B &&
+	    (rk3308->dac_output == DAC_LINEOUT ||
+	     rk3308->dac_output == DAC_LINEOUT_HPOUT)) {
+		regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON15,
+				   RK3308_DAC_LINEOUT_POP_SOUND_L_MSK |
+				   RK3308_DAC_LINEOUT_POP_SOUND_R_MSK,
+				   RK3308_DAC_L_SEL_DC_FROM_VCM |
+				   RK3308_DAC_R_SEL_DC_FROM_VCM);
+	}
+
+	/* Step 16 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON01,
+			   RK3308_DAC_BUF_REF_L_EN |
+			   RK3308_DAC_BUF_REF_R_EN,
+			   RK3308_DAC_BUF_REF_L_DIS |
+			   RK3308_DAC_BUF_REF_R_DIS);
+
+	/* Step 17 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON00,
+			   RK3308_DAC_CURRENT_EN,
+			   RK3308_DAC_CURRENT_DIS);
+
+	/* Step 18 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON03,
+			   RK3308_DAC_L_HPOUT_WORK |
+			   RK3308_DAC_R_HPOUT_WORK,
+			   RK3308_DAC_L_HPOUT_INIT |
+			   RK3308_DAC_R_HPOUT_INIT);
+
+	/* Step 19 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON13,
+			   RK3308_DAC_L_HPMIX_WORK |
+			   RK3308_DAC_R_HPMIX_WORK,
+			   RK3308_DAC_L_HPMIX_WORK |
+			   RK3308_DAC_R_HPMIX_WORK);
+
+	/* Step 20 skipped, may set the min gain for HPOUT. */
+
+	/*
+	 * Note2. If the ACODEC_DAC_ANA_CON12[7] or ACODEC_DAC_ANA_CON12[3]
+	 * is set to 0x1, add the steps from the section Disable ADC
+	 * Configuration Standard Usage Flow after complete the step 19
+	 *
+	 * IF USING LINE-IN
+	 * rk3308_codec_adc_ana_disable(rk3308, type);
+	 */
+
+	rk3308->dac_endisable = false;
+
+	return 0;
+}
+
+static int rk3308_codec_power_on(struct rk3308_codec_priv *rk3308)
+{
+	unsigned int v;
+
+	/* 0. Supply the power of digital part and reset the Audio Codec */
+	/* Do nothing */
+
+	/*
+	 * 1. Configure ACODEC_DAC_ANA_CON1[1:0] and ACODEC_DAC_ANA_CON1[5:4]
+	 *    to 0x1, to setup dc voltage of the DAC channel output.
+	 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON01,
+			   RK3308_DAC_HPOUT_POP_SOUND_L_MSK,
+			   RK3308_DAC_HPOUT_POP_SOUND_L_INIT);
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON01,
+			   RK3308_DAC_HPOUT_POP_SOUND_R_MSK,
+			   RK3308_DAC_HPOUT_POP_SOUND_R_INIT);
+
+	if (rk3308->codec_ver == ACODEC_VERSION_B) {
+		/*
+		 * 2. Configure ACODEC_DAC_ANA_CON15[1:0] and
+		 *    ACODEC_DAC_ANA_CON15[5:4] to 0x1, to setup dc voltage of
+		 *    the DAC channel output.
+		 */
+		regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON15,
+				   RK3308_DAC_LINEOUT_POP_SOUND_L_MSK,
+				   RK3308_DAC_L_SEL_DC_FROM_VCM);
+		regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON15,
+				   RK3308_DAC_LINEOUT_POP_SOUND_R_MSK,
+				   RK3308_DAC_R_SEL_DC_FROM_VCM);
+	}
+
+	/*
+	 * 3. Configure the register ACODEC_ADC_ANA_CON10[3:0] to 7b000_0001.
+	 */
+	regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON10(0),
+			   RK3308_ADC_CURRENT_CHARGE_MSK,
+			   RK3308_ADC_SEL_I(0x1));
+
+	if (rk3308->codec_ver == ACODEC_VERSION_B) {
+		/*
+		 * 4. Configure the register ACODEC_ADC_ANA_CON14[3:0] to
+		 *    4b0001.
+		 */
+		regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON14,
+				   RK3308_DAC_CURRENT_CHARGE_MSK,
+				   RK3308_DAC_SEL_I(0x1));
+	}
+
+	/* 5. Supply the power of the analog part(AVDD,AVDDRV) */
+
+	/*
+	 * 6. Configure the register ACODEC_ADC_ANA_CON10[7] to 0x1 to setup
+	 *    reference voltage
+	 */
+	regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON10(0),
+			   RK3308_ADC_REF_EN, RK3308_ADC_REF_EN);
+
+	if (rk3308->codec_ver == ACODEC_VERSION_B) {
+		/*
+		 * 7. Configure the register ACODEC_ADC_ANA_CON14[4] to 0x1 to
+		 *    setup reference voltage
+		 */
+		regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON14,
+				   RK3308_DAC_VCM_LINEOUT_EN,
+				   RK3308_DAC_VCM_LINEOUT_EN);
+	}
+
+	/*
+	 * 8. Change the register ACODEC_ADC_ANA_CON10[6:0] from the 0x1 to
+	 *    0x7f step by step or configure the ACODEC_ADC_ANA_CON10[6:0] to
+	 *    0x7f directly. Here the slot time of the step is 200us.
+	 */
+	for (v = 0x1; v <= 0x7f; v++) {
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON10(0),
+				   RK3308_ADC_CURRENT_CHARGE_MSK,
+				   v);
+		udelay(200);
+	}
+
+	if (rk3308->codec_ver == ACODEC_VERSION_B) {
+		/*
+		 * 9. Change the register ACODEC_ADC_ANA_CON14[3:0] from the 0x1
+		 *    to 0xf step by step or configure the
+		 *    ACODEC_ADC_ANA_CON14[3:0] to 0xf directly. Here the slot
+		 *    time of the step is 200us.
+		 */
+		for (v = 0x1; v <= 0xf; v++) {
+			regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON14,
+					   RK3308_DAC_CURRENT_CHARGE_MSK,
+					   v);
+			udelay(200);
+		}
+	}
+
+	/* 10. Wait until the voltage of VCM keeps stable at the AVDD/2 */
+	msleep(20);	/* estimated value */
+
+	/*
+	 * 11. Configure the register ACODEC_ADC_ANA_CON10[6:0] to the
+	 *     appropriate value(expect 0x0) for reducing power.
+	 */
+	regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON10(0),
+			   RK3308_ADC_CURRENT_CHARGE_MSK, 0x7c);
+
+	if (rk3308->codec_ver == ACODEC_VERSION_B) {
+		/*
+		 * 12. Configure the register ACODEC_DAC_ANA_CON14[6:0] to the
+		 *     appropriate value(expect 0x0) for reducing power.
+		 */
+		regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON14,
+				   RK3308_DAC_CURRENT_CHARGE_MSK, 0xf);
+	}
+
+	return 0;
+}
+
+static int rk3308_codec_power_off(struct rk3308_codec_priv *rk3308)
+{
+	unsigned int v;
+
+	/*
+	 * 0. Keep the power on and disable the DAC and ADC path according to
+	 *    the section power on configuration standard usage flow.
+	 */
+
+	/*
+	 * 1. Configure the register ACODEC_ADC_ANA_CON10[6:0] to 7b000_0001.
+	 */
+	regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON10(0),
+			   RK3308_ADC_CURRENT_CHARGE_MSK,
+			   RK3308_ADC_SEL_I(0x1));
+
+	if (rk3308->codec_ver == ACODEC_VERSION_B) {
+		/*
+		 * 2. Configure the register ACODEC_DAC_ANA_CON14[3:0] to
+		 *    4b0001.
+		 */
+		regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON14,
+				   RK3308_DAC_CURRENT_CHARGE_MSK,
+				   RK3308_DAC_SEL_I(0x1));
+	}
+
+	/* 3. Configure the register ACODEC_ADC_ANA_CON10[7] to 0x0 */
+	regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON10(0),
+			   RK3308_ADC_REF_EN,
+			   RK3308_ADC_REF_DIS);
+
+	if (rk3308->codec_ver == ACODEC_VERSION_B) {
+		/* 4. Configure the register ACODEC_DAC_ANA_CON14[7] to 0x0 */
+		regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON14,
+				   RK3308_DAC_VCM_LINEOUT_EN,
+				   RK3308_DAC_VCM_LINEOUT_DIS);
+	}
+
+	/*
+	 * 5. Change the register ACODEC_ADC_ANA_CON10[6:0] from the 0x1 to 0x7f
+	 *    step by step or configure the ACODEC_ADC_ANA_CON10[6:0] to 0x7f
+	 *    directly. Here the slot time of the step is 200us.
+	 */
+	for (v = 0x1; v <= 0x7f; v++) {
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON10(0),
+				   RK3308_ADC_CURRENT_CHARGE_MSK,
+				   v);
+		udelay(200);
+	}
+
+	if (rk3308->codec_ver == ACODEC_VERSION_B) {
+		/*
+		 * 6. Change the register ACODEC_DAC_ANA_CON14[3:0] from the 0x1
+		 *    to 0xf step by step or configure the
+		 *    ACODEC_DAC_ANA_CON14[3:0] to 0xf directly. Here the slot
+		 *    time of the step is 200us.
+		 */
+		for (v = 0x1; v <= 0x7f; v++) {
+			regmap_update_bits(rk3308->regmap,
+					   RK3308_ADC_ANA_CON10(0),
+					   RK3308_ADC_CURRENT_CHARGE_MSK,
+					   v);
+			udelay(200);
+		}
+	}
+
+	/* 7. Wait until the voltage of VCM keeps stable at the AGND */
+	msleep(20);	/* estimated value */
+
+	/* 8. Power off the analog power supply */
+	/* 9. Power off the digital power supply */
+
+	/* Do something via hardware */
+
+	return 0;
+}
+
+static int rk3308_codec_headset_detect_enable(struct rk3308_codec_priv *rk3308)
+{
+	/*
+	 * Set ACODEC_DAC_ANA_CON0[1] to 0x1, to enable the headset insert
+	 * detection
+	 *
+	 * Note. When the voltage of PAD HPDET> 8*AVDD/9, the output value of
+	 * the pin_hpdet will be set to 0x1 and assert a interrupt
+	 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON00,
+			   RK3308_DAC_HEADPHONE_DET_MSK,
+			   RK3308_DAC_HEADPHONE_DET_EN);
+
+	return 0;
+}
+
+static int rk3308_codec_headset_detect_disable(struct rk3308_codec_priv *rk3308)
+{
+	/*
+	 * Set ACODEC_DAC_ANA_CON0[1] to 0x0, to disable the headset insert
+	 * detection
+	 */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON00,
+			   RK3308_DAC_HEADPHONE_DET_MSK,
+			   RK3308_DAC_HEADPHONE_DET_DIS);
+
+	return 0;
+}
+
+static int rk3308_codec_check_i2s_sdis(struct rk3308_codec_priv *rk3308,
+				       int num)
+{
+	int i, j, ret = 0;
+
+	switch (num) {
+	case 1:
+		rk3308->which_i2s = ACODEC_TO_I2S1_2CH;
+		break;
+	case 2:
+		rk3308->which_i2s = ACODEC_TO_I2S3_4CH;
+		break;
+	case 4:
+		rk3308->which_i2s = ACODEC_TO_I2S2_8CH;
+		break;
+	default:
+		dev_err(rk3308->plat_dev, "Invalid i2s sdis num: %d\n", num);
+		ret = -EINVAL;
+		goto err;
+	}
+
+	for (i = 0; i < num; i++) {
+		if (rk3308->i2s_sdis[i] > ADC_LR_GROUP_MAX - 1) {
+			dev_err(rk3308->plat_dev,
+				"i2s_sdis[%d]: %d is overflow\n",
+				i, rk3308->i2s_sdis[i]);
+			ret = -EINVAL;
+			goto err;
+		}
+
+		for (j = 0; j < num; j++) {
+			if (i == j)
+				continue;
+
+			if (rk3308->i2s_sdis[i] == rk3308->i2s_sdis[j]) {
+				dev_err(rk3308->plat_dev,
+					"Invalid i2s_sdis: [%d]%d == [%d]%d\n",
+					i, rk3308->i2s_sdis[i],
+					j, rk3308->i2s_sdis[j]);
+				ret = -EINVAL;
+				goto err;
+			}
+		}
+	}
+
+err:
+	return ret;
+}
+
+static int rk3308_codec_adc_grps_route_config(struct rk3308_codec_priv *rk3308)
+{
+	int idx = 0;
+
+	if (rk3308->which_i2s == ACODEC_TO_I2S2_8CH) {
+		for (idx = 0; idx < rk3308->to_i2s_grps; idx++) {
+			regmap_write(rk3308->grf, GRF_SOC_CON1,
+				     GRF_I2S2_8CH_SDI(idx, rk3308->i2s_sdis[idx]));
+		}
+	} else if (rk3308->which_i2s == ACODEC_TO_I2S3_4CH) {
+		for (idx = 0; idx < rk3308->to_i2s_grps; idx++) {
+			regmap_write(rk3308->grf, GRF_SOC_CON1,
+				     GRF_I2S3_4CH_SDI(idx, rk3308->i2s_sdis[idx]));
+		}
+	} else if (rk3308->which_i2s == ACODEC_TO_I2S1_2CH) {
+		regmap_write(rk3308->grf, GRF_SOC_CON1,
+			     GRF_I2S1_2CH_SDI(rk3308->i2s_sdis[idx]));
+	}
+
+	return 0;
+}
+
+/* Put default one-to-one mapping */
+static int rk3308_codec_adc_grps_route_default(struct rk3308_codec_priv *rk3308)
+{
+	unsigned int idx;
+
+	/*
+	 * The GRF values may be kept the previous status after hot reboot,
+	 * if the property 'rockchip,adc-grps-route' is not set, we need to
+	 * recover default the order of sdi/sdo for i2s2_8ch/i2s3_8ch/i2s1_2ch.
+	 */
+	regmap_write(rk3308->grf, GRF_SOC_CON1,
+		     GRF_I2S1_2CH_SDI(0));
+
+	for (idx = 0; idx < 2; idx++) {
+		regmap_write(rk3308->grf, GRF_SOC_CON1,
+			     GRF_I2S3_4CH_SDI(idx, idx));
+	}
+
+	/* Using i2s2_8ch by default. */
+	rk3308->which_i2s = ACODEC_TO_I2S2_8CH;
+	rk3308->to_i2s_grps = ADC_LR_GROUP_MAX;
+
+	for (idx = 0; idx < ADC_LR_GROUP_MAX; idx++) {
+		rk3308->i2s_sdis[idx] = idx;
+		regmap_write(rk3308->grf, GRF_SOC_CON1,
+			     GRF_I2S2_8CH_SDI(idx, idx));
+	}
+
+	return 0;
+}
+
+static int rk3308_codec_adc_grps_route(struct rk3308_codec_priv *rk3308,
+				       struct device_node *np)
+{
+	int num, ret;
+
+	num = of_count_phandle_with_args(np, "rockchip,adc-grps-route", NULL);
+	if (num < 0) {
+		if (num == -ENOENT) {
+			/* Not use 'rockchip,adc-grps-route' property here */
+			rk3308_codec_adc_grps_route_default(rk3308);
+			ret = 0;
+		} else {
+			dev_err(rk3308->plat_dev,
+				"Failed to read 'rockchip,adc-grps-route' num: %d\n",
+				num);
+			ret = num;
+		}
+		return ret;
+	}
+
+	ret = of_property_read_u32_array(np, "rockchip,adc-grps-route",
+					 rk3308->i2s_sdis, num);
+	if (ret < 0) {
+		dev_err(rk3308->plat_dev,
+			"Failed to read 'rockchip,adc-grps-route': %d\n",
+			ret);
+		return ret;
+	}
+
+	ret = rk3308_codec_check_i2s_sdis(rk3308, num);
+	if (ret < 0) {
+		dev_err(rk3308->plat_dev,
+			"Failed to check i2s_sdis: %d\n", ret);
+		return ret;
+	}
+
+	rk3308->to_i2s_grps = num;
+
+	rk3308_codec_adc_grps_route_config(rk3308);
+
+	return 0;
+}
+
+static int check_micbias(int micbias)
+{
+	switch (micbias) {
+	case RK3308_ADC_MICBIAS_VOLT_0_85:
+	case RK3308_ADC_MICBIAS_VOLT_0_8:
+	case RK3308_ADC_MICBIAS_VOLT_0_75:
+	case RK3308_ADC_MICBIAS_VOLT_0_7:
+	case RK3308_ADC_MICBIAS_VOLT_0_65:
+	case RK3308_ADC_MICBIAS_VOLT_0_6:
+	case RK3308_ADC_MICBIAS_VOLT_0_55:
+	case RK3308_ADC_MICBIAS_VOLT_0_5:
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+static bool handle_loopback(struct rk3308_codec_priv *rk3308)
+{
+	/* The version B doesn't need to handle loopback. */
+	if (rk3308->codec_ver == ACODEC_VERSION_B)
+		return false;
+
+	switch (rk3308->loopback_grp) {
+	case 0:
+	case 1:
+	case 2:
+	case 3:
+		return true;
+	}
+
+	return false;
+}
+
+static bool has_en_always_grps(struct rk3308_codec_priv *rk3308)
+{
+	int idx;
+
+	if (rk3308->en_always_grps_num) {
+		for (idx = 0; idx < ADC_LR_GROUP_MAX; idx++) {
+			if (rk3308->en_always_grps[idx] >= 0 &&
+			    rk3308->en_always_grps[idx] <= ADC_LR_GROUP_MAX - 1)
+				return true;
+		}
+	}
+
+	return false;
+}
+
+static int rk3308_codec_micbias_enable(struct rk3308_codec_priv *rk3308,
+				       int micbias)
+{
+	int ret;
+
+	if (rk3308->ext_micbias != EXT_MICBIAS_NONE)
+		return 0;
+
+	/* 0. Power up the ACODEC and keep the AVDDH stable */
+
+	/* Step 1. Configure ACODEC_ADC_ANA_CON7[2:0] to the certain value */
+	ret = check_micbias(micbias);
+	if (ret < 0) {
+		dev_err(rk3308->plat_dev, "This is an invalid micbias: %d\n",
+			micbias);
+		return ret;
+	}
+
+	/*
+	 * Note: Only the reg (ADC_ANA_CON7+0x0)[2:0] represent the level range
+	 * control signal of MICBIAS voltage
+	 */
+	regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON07(0),
+			   RK3308_ADC_LEVEL_RANGE_MICBIAS_MSK,
+			   micbias);
+
+	/* Step 2. Wait until the VCMH keep stable */
+	msleep(20);	/* estimated value */
+
+	/*
+	 * Step 3. Configure ACODEC_ADC_ANA_CON8[4] to 0x1
+	 *
+	 * Note: Only the reg (ADC_ANA_CON8+0x0)[4] represent the enable
+	 * signal of current source for MICBIAS
+	 */
+	regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON08(0),
+			   RK3308_ADC_MICBIAS_CURRENT_MSK,
+			   RK3308_ADC_MICBIAS_CURRENT_EN);
+
+	/*
+	 * Step 4. Configure the (ADC_ANA_CON7+0x40)[3] or
+	 * (ADC_ANA_CON7+0x80)[3] to 0x1.
+	 *
+	 * (ADC_ANA_CON7+0x40)[3] used to control the MICBIAS1, and
+	 * (ADC_ANA_CON7+0x80)[3] used to control the MICBIAS2
+	 */
+	if (rk3308->micbias1)
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON07(1),
+				   RK3308_ADC_MIC_BIAS_BUF_EN,
+				   RK3308_ADC_MIC_BIAS_BUF_EN);
+
+	if (rk3308->micbias2)
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON07(2),
+				   RK3308_ADC_MIC_BIAS_BUF_EN,
+				   RK3308_ADC_MIC_BIAS_BUF_EN);
+
+	/* waiting micbias stabled*/
+	mdelay(50);
+
+	rk3308->enable_micbias = true;
+
+	return 0;
+}
+
+static int rk3308_codec_micbias_disable(struct rk3308_codec_priv *rk3308)
+{
+	if (rk3308->ext_micbias != EXT_MICBIAS_NONE)
+		return 0;
+
+	/* Step 0. Enable the MICBIAS and keep the Audio Codec stable */
+	/* Do nothing */
+
+	/*
+	 * Step 1. Configure the (ADC_ANA_CON7+0x40)[3] or
+	 * (ADC_ANA_CON7+0x80)[3] to 0x0
+	 */
+	regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON07(1),
+			   RK3308_ADC_MIC_BIAS_BUF_EN,
+			   RK3308_ADC_MIC_BIAS_BUF_DIS);
+	regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON07(2),
+			   RK3308_ADC_MIC_BIAS_BUF_EN,
+			   RK3308_ADC_MIC_BIAS_BUF_DIS);
+
+	/*
+	 * Step 2. Configure ACODEC_ADC_ANA_CON8[4] to 0x0
+	 *
+	 * Note: Only the reg (ADC_ANA_CON8+0x0)[4] represent the enable
+	 * signal of current source for MICBIAS
+	 */
+	regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON08(0),
+			   RK3308_ADC_MICBIAS_CURRENT_MSK,
+			   RK3308_ADC_MICBIAS_CURRENT_DIS);
+
+	rk3308->enable_micbias = false;
+
+	return 0;
+}
+
+static int rk3308_codec_adc_reinit_mics(struct rk3308_codec_priv *rk3308,
+					int type)
+{
+	int idx, grp;
+
+	for (idx = 0; adc_for_each_grp(rk3308, type, idx, &grp); idx++) {
+		if (grp < 0 || grp > ADC_LR_GROUP_MAX - 1)
+			continue;
+
+		/* vendor step 1 */
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON05(grp),
+				   RK3308_ADC_CH1_ADC_WORK |
+				   RK3308_ADC_CH2_ADC_WORK,
+				   RK3308_ADC_CH1_ADC_INIT |
+				   RK3308_ADC_CH2_ADC_INIT);
+	}
+
+	for (idx = 0; adc_for_each_grp(rk3308, type, idx, &grp); idx++) {
+		if (grp < 0 || grp > ADC_LR_GROUP_MAX - 1)
+			continue;
+
+		/* vendor step 2 */
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON02(grp),
+				   RK3308_ADC_CH1_ALC_WORK |
+				   RK3308_ADC_CH2_ALC_WORK,
+				   RK3308_ADC_CH1_ALC_INIT |
+				   RK3308_ADC_CH2_ALC_INIT);
+	}
+
+	for (idx = 0; adc_for_each_grp(rk3308, type, idx, &grp); idx++) {
+		if (grp < 0 || grp > ADC_LR_GROUP_MAX - 1)
+			continue;
+
+		/* vendor step 3 */
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON00(grp),
+				   RK3308_ADC_CH1_MIC_WORK |
+				   RK3308_ADC_CH2_MIC_WORK,
+				   RK3308_ADC_CH1_MIC_INIT |
+				   RK3308_ADC_CH2_MIC_INIT);
+	}
+
+	usleep_range(200, 250);	/* estimated value */
+
+	for (idx = 0; adc_for_each_grp(rk3308, type, idx, &grp); idx++) {
+		if (grp < 0 || grp > ADC_LR_GROUP_MAX - 1)
+			continue;
+
+		/* vendor step 1 */
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON05(grp),
+				   RK3308_ADC_CH1_ADC_WORK |
+				   RK3308_ADC_CH2_ADC_WORK,
+				   RK3308_ADC_CH1_ADC_WORK |
+				   RK3308_ADC_CH2_ADC_WORK);
+	}
+
+	for (idx = 0; adc_for_each_grp(rk3308, type, idx, &grp); idx++) {
+		if (grp < 0 || grp > ADC_LR_GROUP_MAX - 1)
+			continue;
+
+		/* vendor step 2 */
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON02(grp),
+				   RK3308_ADC_CH1_ALC_WORK |
+				   RK3308_ADC_CH2_ALC_WORK,
+				   RK3308_ADC_CH1_ALC_WORK |
+				   RK3308_ADC_CH2_ALC_WORK);
+	}
+
+	for (idx = 0; adc_for_each_grp(rk3308, type, idx, &grp); idx++) {
+		if (grp < 0 || grp > ADC_LR_GROUP_MAX - 1)
+			continue;
+
+		/* vendor step 3 */
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON00(grp),
+				   RK3308_ADC_CH1_MIC_WORK |
+				   RK3308_ADC_CH2_MIC_WORK,
+				   RK3308_ADC_CH1_MIC_WORK |
+				   RK3308_ADC_CH2_MIC_WORK);
+	}
+
+	return 0;
+}
+
+static int rk3308_codec_adc_ana_enable(struct rk3308_codec_priv *rk3308,
+				       int type)
+{
+	unsigned int agc_func_en;
+	int idx, grp;
+
+	/*
+	 * 1. Set the ACODEC_ADC_ANA_CON7[7:6] and ACODEC_ADC_ANA_CON7[5:4],
+	 * to select the line-in or microphone as input of ADC
+	 *
+	 * Note1. Please ignore the step1 for enabling ADC3, ADC4, ADC5,
+	 * ADC6, ADC7, and ADC8
+	 */
+	if (rk3308->adc_grp0_using_linein) {
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON07(0),
+				   RK3308_ADC_CH1_IN_SEL_MSK |
+				   RK3308_ADC_CH2_IN_SEL_MSK,
+				   RK3308_ADC_CH1_IN_LINEIN |
+				   RK3308_ADC_CH2_IN_LINEIN);
+
+		/* Keep other ADCs as MIC-IN */
+		for (idx = 0; adc_for_each_grp(rk3308, type, idx, &grp); idx++) {
+			/* The groups without line-in are >= 1 */
+			if (grp < 1 || grp > ADC_LR_GROUP_MAX - 1)
+				continue;
+
+			regmap_update_bits(rk3308->regmap,
+					   RK3308_ADC_ANA_CON07(grp),
+					   RK3308_ADC_CH1_IN_SEL_MSK |
+					   RK3308_ADC_CH2_IN_SEL_MSK,
+					   RK3308_ADC_CH1_IN_MIC |
+					   RK3308_ADC_CH2_IN_MIC);
+		}
+	} else {
+		for (idx = 0; adc_for_each_grp(rk3308, type, idx, &grp); idx++) {
+			if (grp < 0 || grp > ADC_LR_GROUP_MAX - 1)
+				continue;
+
+			regmap_update_bits(rk3308->regmap,
+					   RK3308_ADC_ANA_CON07(grp),
+					   RK3308_ADC_CH1_IN_SEL_MSK |
+					   RK3308_ADC_CH2_IN_SEL_MSK,
+					   RK3308_ADC_CH1_IN_MIC |
+					   RK3308_ADC_CH2_IN_MIC);
+		}
+	}
+
+	/*
+	 * 2. Set ACODEC_ADC_ANA_CON0[7] and [3] to 0x1, to end the mute station
+	 * of ADC, to enable the MIC module, to enable the reference voltage
+	 * buffer, and to end the initialization of MIC
+	 */
+	for (idx = 0; adc_for_each_grp(rk3308, type, idx, &grp); idx++) {
+		if (grp < 0 || grp > ADC_LR_GROUP_MAX - 1)
+			continue;
+
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON00(grp),
+				   RK3308_ADC_CH1_MIC_UNMUTE |
+				   RK3308_ADC_CH2_MIC_UNMUTE,
+				   RK3308_ADC_CH1_MIC_UNMUTE |
+				   RK3308_ADC_CH2_MIC_UNMUTE);
+	}
+
+	/*
+	 * 3. Set ACODEC_ADC_ANA_CON6[0] to 0x1, to enable the current source
+	 * of audio
+	 */
+	for (idx = 0; adc_for_each_grp(rk3308, type, idx, &grp); idx++) {
+		if (grp < 0 || grp > ADC_LR_GROUP_MAX - 1)
+			continue;
+
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON06(grp),
+				   RK3308_ADC_CURRENT_MSK,
+				   RK3308_ADC_CURRENT_EN);
+	}
+
+	/*
+	 * This is mainly used for BIST mode that wait ADCs are stable.
+	 *
+	 * By tested results, the type delay is >40us, but we need to leave
+	 * enough delay margin.
+	 */
+	usleep_range(400, 500);
+
+	/* vendor step 4*/
+	for (idx = 0; adc_for_each_grp(rk3308, type, idx, &grp); idx++) {
+		if (grp < 0 || grp > ADC_LR_GROUP_MAX - 1)
+			continue;
+
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON00(grp),
+				   RK3308_ADC_CH1_BUF_REF_EN |
+				   RK3308_ADC_CH2_BUF_REF_EN,
+				   RK3308_ADC_CH1_BUF_REF_EN |
+				   RK3308_ADC_CH2_BUF_REF_EN);
+	}
+
+	/* vendor step 5 */
+	for (idx = 0; adc_for_each_grp(rk3308, type, idx, &grp); idx++) {
+		if (grp < 0 || grp > ADC_LR_GROUP_MAX - 1)
+			continue;
+
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON00(grp),
+				   RK3308_ADC_CH1_MIC_EN |
+				   RK3308_ADC_CH2_MIC_EN,
+				   RK3308_ADC_CH1_MIC_EN |
+				   RK3308_ADC_CH2_MIC_EN);
+	}
+
+	/* vendor step 6 */
+	for (idx = 0; adc_for_each_grp(rk3308, type, idx, &grp); idx++) {
+		if (grp < 0 || grp > ADC_LR_GROUP_MAX - 1)
+			continue;
+
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON02(grp),
+				   RK3308_ADC_CH1_ALC_EN |
+				   RK3308_ADC_CH2_ALC_EN,
+				   RK3308_ADC_CH1_ALC_EN |
+				   RK3308_ADC_CH2_ALC_EN);
+	}
+
+	/* vendor step 7 */
+	for (idx = 0; adc_for_each_grp(rk3308, type, idx, &grp); idx++) {
+		if (grp < 0 || grp > ADC_LR_GROUP_MAX - 1)
+			continue;
+
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON05(grp),
+				   RK3308_ADC_CH1_CLK_EN |
+				   RK3308_ADC_CH2_CLK_EN,
+				   RK3308_ADC_CH1_CLK_EN |
+				   RK3308_ADC_CH2_CLK_EN);
+	}
+
+	/* vendor step 8 */
+	for (idx = 0; adc_for_each_grp(rk3308, type, idx, &grp); idx++) {
+		if (grp < 0 || grp > ADC_LR_GROUP_MAX - 1)
+			continue;
+
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON05(grp),
+				   RK3308_ADC_CH1_ADC_EN |
+				   RK3308_ADC_CH2_ADC_EN,
+				   RK3308_ADC_CH1_ADC_EN |
+				   RK3308_ADC_CH2_ADC_EN);
+	}
+
+	/* vendor step 9 */
+	for (idx = 0; adc_for_each_grp(rk3308, type, idx, &grp); idx++) {
+		if (grp < 0 || grp > ADC_LR_GROUP_MAX - 1)
+			continue;
+
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON05(grp),
+				   RK3308_ADC_CH1_ADC_WORK |
+				   RK3308_ADC_CH2_ADC_WORK,
+				   RK3308_ADC_CH1_ADC_WORK |
+				   RK3308_ADC_CH2_ADC_WORK);
+	}
+
+	/* vendor step 10 */
+	for (idx = 0; adc_for_each_grp(rk3308, type, idx, &grp); idx++) {
+		if (grp < 0 || grp > ADC_LR_GROUP_MAX - 1)
+			continue;
+
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON02(grp),
+				   RK3308_ADC_CH1_ALC_WORK |
+				   RK3308_ADC_CH2_ALC_WORK,
+				   RK3308_ADC_CH1_ALC_WORK |
+				   RK3308_ADC_CH2_ALC_WORK);
+	}
+
+	/* vendor step 11 */
+	for (idx = 0; adc_for_each_grp(rk3308, type, idx, &grp); idx++) {
+		if (grp < 0 || grp > ADC_LR_GROUP_MAX - 1)
+			continue;
+
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON00(grp),
+				   RK3308_ADC_CH1_MIC_WORK |
+				   RK3308_ADC_CH2_MIC_WORK,
+				   RK3308_ADC_CH1_MIC_WORK |
+				   RK3308_ADC_CH2_MIC_WORK);
+	}
+
+	/* vendor step 12 */
+
+	/* vendor step 13 */
+
+	/* vendor step 14 */
+	for (idx = 0; adc_for_each_grp(rk3308, type, idx, &grp); idx++) {
+		if (grp < 0 || grp > ADC_LR_GROUP_MAX - 1)
+			continue;
+
+		regmap_read(rk3308->regmap, RK3308_ALC_L_DIG_CON09(grp),
+			    &agc_func_en);
+		if (rk3308->adc_zerocross ||
+		    agc_func_en & RK3308_AGC_FUNC_SEL_EN) {
+			regmap_update_bits(rk3308->regmap,
+					   RK3308_ADC_ANA_CON02(grp),
+					   RK3308_ADC_CH1_ZEROCROSS_DET_EN,
+					   RK3308_ADC_CH1_ZEROCROSS_DET_EN);
+		}
+		regmap_read(rk3308->regmap, RK3308_ALC_R_DIG_CON09(grp),
+			    &agc_func_en);
+		if (rk3308->adc_zerocross ||
+		    agc_func_en & RK3308_AGC_FUNC_SEL_EN) {
+			regmap_update_bits(rk3308->regmap,
+					   RK3308_ADC_ANA_CON02(grp),
+					   RK3308_ADC_CH2_ZEROCROSS_DET_EN,
+					   RK3308_ADC_CH2_ZEROCROSS_DET_EN);
+		}
+	}
+
+	for (idx = 0; adc_for_each_grp(rk3308, type, idx, &grp); idx++) {
+		if (grp < 0 || grp > ADC_LR_GROUP_MAX - 1)
+			continue;
+
+		rk3308->adc_grps_endisable[grp] = true;
+	}
+
+	return 0;
+}
+
+static int rk3308_codec_adc_ana_disable(struct rk3308_codec_priv *rk3308,
+					int type)
+{
+	int idx, grp;
+
+	for (idx = 0; adc_for_each_grp(rk3308, type, idx, &grp); idx++) {
+		if (grp < 0 || grp > ADC_LR_GROUP_MAX - 1)
+			continue;
+
+		/* vendor step 1 */
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON02(grp),
+				   RK3308_ADC_CH1_ZEROCROSS_DET_EN |
+				   RK3308_ADC_CH2_ZEROCROSS_DET_EN,
+				   RK3308_ADC_CH1_ZEROCROSS_DET_DIS |
+				   RK3308_ADC_CH2_ZEROCROSS_DET_DIS);
+	}
+
+	for (idx = 0; adc_for_each_grp(rk3308, type, idx, &grp); idx++) {
+		if (grp < 0 || grp > ADC_LR_GROUP_MAX - 1)
+			continue;
+
+		/* vendor step 2 */
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON05(grp),
+				   RK3308_ADC_CH1_ADC_EN |
+				   RK3308_ADC_CH2_ADC_EN,
+				   RK3308_ADC_CH1_ADC_DIS |
+				   RK3308_ADC_CH2_ADC_DIS);
+	}
+
+	for (idx = 0; adc_for_each_grp(rk3308, type, idx, &grp); idx++) {
+		if (grp < 0 || grp > ADC_LR_GROUP_MAX - 1)
+			continue;
+
+		/* vendor step 3 */
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON05(grp),
+				   RK3308_ADC_CH1_CLK_EN |
+				   RK3308_ADC_CH2_CLK_EN,
+				   RK3308_ADC_CH1_CLK_DIS |
+				   RK3308_ADC_CH2_CLK_DIS);
+	}
+
+	for (idx = 0; adc_for_each_grp(rk3308, type, idx, &grp); idx++) {
+		if (grp < 0 || grp > ADC_LR_GROUP_MAX - 1)
+			continue;
+
+		/* vendor step 4 */
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON02(grp),
+				   RK3308_ADC_CH1_ALC_EN |
+				   RK3308_ADC_CH2_ALC_EN,
+				   RK3308_ADC_CH1_ALC_DIS |
+				   RK3308_ADC_CH2_ALC_DIS);
+	}
+
+	for (idx = 0; adc_for_each_grp(rk3308, type, idx, &grp); idx++) {
+		if (grp < 0 || grp > ADC_LR_GROUP_MAX - 1)
+			continue;
+
+		/* vendor step 5 */
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON00(grp),
+				   RK3308_ADC_CH1_MIC_EN |
+				   RK3308_ADC_CH2_MIC_EN,
+				   RK3308_ADC_CH1_MIC_DIS |
+				   RK3308_ADC_CH2_MIC_DIS);
+	}
+
+	for (idx = 0; adc_for_each_grp(rk3308, type, idx, &grp); idx++) {
+		if (grp < 0 || grp > ADC_LR_GROUP_MAX - 1)
+			continue;
+
+		/* vendor step 6 */
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON00(grp),
+				   RK3308_ADC_CH1_BUF_REF_EN |
+				   RK3308_ADC_CH2_BUF_REF_EN,
+				   RK3308_ADC_CH1_BUF_REF_DIS |
+				   RK3308_ADC_CH2_BUF_REF_DIS);
+	}
+
+	for (idx = 0; adc_for_each_grp(rk3308, type, idx, &grp); idx++) {
+		if (grp < 0 || grp > ADC_LR_GROUP_MAX - 1)
+			continue;
+
+		/* vendor step 7 */
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON06(grp),
+				   RK3308_ADC_CURRENT_MSK,
+				   RK3308_ADC_CURRENT_DIS);
+	}
+
+	for (idx = 0; adc_for_each_grp(rk3308, type, idx, &grp); idx++) {
+		if (grp < 0 || grp > ADC_LR_GROUP_MAX - 1)
+			continue;
+
+		/* vendor step 8 */
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON05(grp),
+				   RK3308_ADC_CH1_ADC_WORK |
+				   RK3308_ADC_CH2_ADC_WORK,
+				   RK3308_ADC_CH1_ADC_INIT |
+				   RK3308_ADC_CH2_ADC_INIT);
+	}
+
+	for (idx = 0; adc_for_each_grp(rk3308, type, idx, &grp); idx++) {
+		if (grp < 0 || grp > ADC_LR_GROUP_MAX - 1)
+			continue;
+
+		/* vendor step 9 */
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON02(grp),
+				   RK3308_ADC_CH1_ALC_WORK |
+				   RK3308_ADC_CH2_ALC_WORK,
+				   RK3308_ADC_CH1_ALC_INIT |
+				   RK3308_ADC_CH2_ALC_INIT);
+	}
+
+	for (idx = 0; adc_for_each_grp(rk3308, type, idx, &grp); idx++) {
+		if (grp < 0 || grp > ADC_LR_GROUP_MAX - 1)
+			continue;
+
+		/* vendor step 10 */
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON00(grp),
+				   RK3308_ADC_CH1_MIC_WORK |
+				   RK3308_ADC_CH2_MIC_WORK,
+				   RK3308_ADC_CH1_MIC_INIT |
+				   RK3308_ADC_CH2_MIC_INIT);
+	}
+
+	for (idx = 0; adc_for_each_grp(rk3308, type, idx, &grp); idx++) {
+		if (grp < 0 || grp > ADC_LR_GROUP_MAX - 1)
+			continue;
+
+		rk3308->adc_grps_endisable[grp] = false;
+	}
+
+	return 0;
+}
+
+static int rk3308_codec_open_capture(struct rk3308_codec_priv *rk3308)
+{
+	int idx, grp = 0;
+	int type = ADC_TYPE_NORMAL;
+
+	rk3308_codec_adc_ana_enable(rk3308, type);
+	rk3308_codec_adc_reinit_mics(rk3308, type);
+
+	if (rk3308->adc_grp0_using_linein) {
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_DIG_CON03(0),
+				   RK3308_ADC_L_CH_BIST_MSK,
+				   RK3308_ADC_L_CH_NORMAL_RIGHT);
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_DIG_CON03(0),
+				   RK3308_ADC_R_CH_BIST_MSK,
+				   RK3308_ADC_R_CH_NORMAL_LEFT);
+	} else {
+		for (idx = 0; adc_for_each_grp(rk3308, type, idx, &grp); idx++) {
+			if (handle_loopback(rk3308) &&
+			    idx == rk3308->loopback_grp &&
+			    grp == ADC_GRP_SKIP_MAGIC) {
+				/*
+				 * Switch to dummy BIST mode (BIST keep reset
+				 * now) to keep the zero input data in I2S bus.
+				 *
+				 * It may cause the glitch if we hold the ADC
+				 * digtital i2s module in codec.
+				 *
+				 * Then, the grp which is set from loopback_grp.
+				 */
+				regmap_update_bits(rk3308->regmap,
+						   RK3308_ADC_DIG_CON03(rk3308->loopback_grp),
+						   RK3308_ADC_L_CH_BIST_MSK,
+						   RK3308_ADC_L_CH_BIST_SINE);
+				regmap_update_bits(rk3308->regmap,
+						   RK3308_ADC_DIG_CON03(rk3308->loopback_grp),
+						   RK3308_ADC_R_CH_BIST_MSK,
+						   RK3308_ADC_R_CH_BIST_SINE);
+			} else {
+				if (grp < 0 || grp > ADC_LR_GROUP_MAX - 1)
+					continue;
+
+				regmap_update_bits(rk3308->regmap,
+						   RK3308_ADC_DIG_CON03(grp),
+						   RK3308_ADC_L_CH_BIST_MSK,
+						   RK3308_ADC_L_CH_NORMAL_LEFT);
+				regmap_update_bits(rk3308->regmap,
+						   RK3308_ADC_DIG_CON03(grp),
+						   RK3308_ADC_R_CH_BIST_MSK,
+						   RK3308_ADC_R_CH_NORMAL_RIGHT);
+			}
+		}
+	}
+
+	return 0;
+}
+
+static void rk3308_codec_adc_mclk_disable(struct rk3308_codec_priv *rk3308)
+{
+	regmap_update_bits(rk3308->regmap, RK3308_GLB_CON,
+			   RK3308_ADC_MCLK_MSK,
+			   RK3308_ADC_MCLK_DIS);
+}
+
+static void rk3308_codec_adc_mclk_enable(struct rk3308_codec_priv *rk3308)
+{
+	regmap_update_bits(rk3308->regmap, RK3308_GLB_CON,
+			   RK3308_ADC_MCLK_MSK,
+			   RK3308_ADC_MCLK_EN);
+	udelay(20);
+}
+
+static void rk3308_codec_dac_mclk_disable(struct rk3308_codec_priv *rk3308)
+{
+	regmap_update_bits(rk3308->regmap, RK3308_GLB_CON,
+			   RK3308_DAC_MCLK_MSK,
+			   RK3308_DAC_MCLK_DIS);
+}
+
+static void rk3308_codec_dac_mclk_enable(struct rk3308_codec_priv *rk3308)
+{
+	regmap_update_bits(rk3308->regmap, RK3308_GLB_CON,
+			   RK3308_DAC_MCLK_MSK,
+			   RK3308_DAC_MCLK_EN);
+	udelay(20);
+}
+
+static int rk3308_codec_open_dbg_capture(struct rk3308_codec_priv *rk3308)
+{
+	rk3308_codec_adc_ana_enable(rk3308, ADC_TYPE_DBG);
+
+	return 0;
+}
+
+static int rk3308_codec_close_dbg_capture(struct rk3308_codec_priv *rk3308)
+{
+	rk3308_codec_adc_ana_disable(rk3308, ADC_TYPE_DBG);
+
+	return 0;
+}
+
+static int rk3308_codec_close_all_capture(struct rk3308_codec_priv *rk3308)
+{
+	rk3308_codec_adc_ana_disable(rk3308, ADC_TYPE_ALL);
+
+	return 0;
+}
+
+static int rk3308_codec_close_capture(struct rk3308_codec_priv *rk3308)
+{
+	rk3308_codec_adc_ana_disable(rk3308, ADC_TYPE_NORMAL);
+
+	return 0;
+}
+
+static int rk3308_codec_open_playback(struct rk3308_codec_priv *rk3308)
+{
+	rk3308_codec_dac_enable(rk3308);
+
+	return 0;
+}
+
+static int rk3308_codec_close_playback(struct rk3308_codec_priv *rk3308)
+{
+	rk3308_codec_dac_disable(rk3308);
+
+	return 0;
+}
+
+static int rk3308_codec_llp_down(struct rk3308_codec_priv *rk3308)
+{
+	rk3308_codec_adc_mclk_disable(rk3308);
+	rk3308_codec_dac_mclk_disable(rk3308);
+
+	return 0;
+}
+
+static int rk3308_codec_llp_up(struct rk3308_codec_priv *rk3308)
+{
+	rk3308_codec_adc_mclk_enable(rk3308);
+	rk3308_codec_dac_mclk_enable(rk3308);
+
+	return 0;
+}
+
+static int rk3308_codec_dlp_down(struct rk3308_codec_priv *rk3308)
+{
+	rk3308_codec_micbias_disable(rk3308);
+	rk3308_codec_power_off(rk3308);
+
+	return 0;
+}
+
+static int rk3308_codec_dlp_up(struct rk3308_codec_priv *rk3308)
+{
+	rk3308_codec_power_on(rk3308);
+	rk3308_codec_micbias_enable(rk3308, rk3308->micbias_volt);
+
+	return 0;
+}
+
+/* Just used for debug and trace power state */
+static void rk3308_codec_set_pm_state(struct rk3308_codec_priv *rk3308,
+				      int pm_state)
+{
+	int ret;
+
+	switch (pm_state) {
+	case PM_LLP_DOWN:
+		rk3308_codec_llp_down(rk3308);
+		break;
+	case PM_LLP_UP:
+		rk3308_codec_llp_up(rk3308);
+		break;
+	case PM_DLP_DOWN:
+		rk3308_codec_dlp_down(rk3308);
+		break;
+	case PM_DLP_UP:
+		rk3308_codec_dlp_up(rk3308);
+		break;
+	case PM_DLP_DOWN2:
+		clk_disable_unprepare(rk3308->mclk_rx);
+		clk_disable_unprepare(rk3308->mclk_tx);
+		clk_disable_unprepare(rk3308->pclk);
+		break;
+	case PM_DLP_UP2:
+		ret = clk_prepare_enable(rk3308->pclk);
+		if (ret < 0) {
+			dev_err(rk3308->plat_dev,
+				"Failed to enable acodec pclk: %d\n", ret);
+			goto err;
+		}
+
+		ret = clk_prepare_enable(rk3308->mclk_rx);
+		if (ret < 0) {
+			dev_err(rk3308->plat_dev,
+				"Failed to enable i2s mclk_rx: %d\n", ret);
+			goto err;
+		}
+
+		ret = clk_prepare_enable(rk3308->mclk_tx);
+		if (ret < 0) {
+			dev_err(rk3308->plat_dev,
+				"Failed to enable i2s mclk_tx: %d\n", ret);
+			goto err;
+		}
+		break;
+	default:
+		dev_err(rk3308->plat_dev, "Invalid pm_state: %d\n", pm_state);
+		goto err;
+	}
+
+	rk3308->pm_state = pm_state;
+
+err:
+	return;
+}
+
+static void rk3308_codec_update_adcs_status(struct rk3308_codec_priv *rk3308,
+					    int state)
+{
+	int idx, grp;
+
+	/* Update skip_grps flags if the ADCs need to be enabled always. */
+	if (state == PATH_BUSY) {
+		for (idx = 0; idx < rk3308->used_adc_grps; idx++) {
+			u32 mapped_grp = to_mapped_grp(rk3308, idx);
+
+			for (grp = 0; grp < rk3308->en_always_grps_num; grp++) {
+				u32 en_always_grp = rk3308->en_always_grps[grp];
+
+				if (mapped_grp == en_always_grp)
+					rk3308->skip_grps[en_always_grp] = 1;
+			}
+		}
+	}
+}
+
+static int rk3308_hw_params(struct snd_pcm_substream *substream,
+			    struct snd_pcm_hw_params *params,
+			    struct snd_soc_dai *dai)
+{
+	struct snd_soc_component *component = dai->component;
+	struct rk3308_codec_priv *rk3308 = snd_soc_component_get_drvdata(component);
+	struct snd_pcm_str *playback_str =
+			&substream->pcm->streams[SNDRV_PCM_STREAM_PLAYBACK];
+	int type = ADC_TYPE_LOOPBACK;
+	int idx, grp;
+	int ret;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		/* DAC only supports 2 channels */
+		rk3308_codec_dac_mclk_enable(rk3308);
+		rk3308_codec_open_playback(rk3308);
+		rk3308_codec_dac_dig_config(rk3308, params);
+		rk3308_codec_set_dac_path_state(rk3308, PATH_BUSY);
+	} else {
+		if (rk3308->micbias_num &&
+		    !rk3308->enable_micbias)
+			rk3308_codec_micbias_enable(rk3308, rk3308->micbias_volt);
+
+		rk3308_codec_adc_mclk_enable(rk3308);
+		ret = rk3308_codec_update_adc_grps(rk3308, params);
+		if (ret < 0)
+			return ret;
+
+		if (handle_loopback(rk3308)) {
+			if (rk3308->micbias_num &&
+			    (params_channels(params) == 2) &&
+			    to_mapped_grp(rk3308, 0) == rk3308->loopback_grp)
+				rk3308_codec_micbias_disable(rk3308);
+
+			/* Check the DACs are opened */
+			if (playback_str->substream_opened) {
+				rk3308->loopback_dacs_enabled = true;
+				for (idx = 0; adc_for_each_grp(rk3308, type, idx, &grp); idx++) {
+					if (grp < 0 || grp > ADC_LR_GROUP_MAX - 1)
+						continue;
+
+					regmap_update_bits(rk3308->regmap,
+							   RK3308_ADC_DIG_CON03(grp),
+							   RK3308_ADC_L_CH_BIST_MSK,
+							   RK3308_ADC_L_CH_NORMAL_LEFT);
+					regmap_update_bits(rk3308->regmap,
+							   RK3308_ADC_DIG_CON03(grp),
+							   RK3308_ADC_R_CH_BIST_MSK,
+							   RK3308_ADC_R_CH_NORMAL_RIGHT);
+				}
+			} else {
+				rk3308->loopback_dacs_enabled = false;
+				for (idx = 0; adc_for_each_grp(rk3308, type, idx, &grp); idx++) {
+					if (grp < 0 || grp > ADC_LR_GROUP_MAX - 1)
+						continue;
+
+					regmap_update_bits(rk3308->regmap,
+							   RK3308_ADC_DIG_CON03(grp),
+							   RK3308_ADC_L_CH_BIST_MSK,
+							   RK3308_ADC_L_CH_BIST_SINE);
+					regmap_update_bits(rk3308->regmap,
+							   RK3308_ADC_DIG_CON03(grp),
+							   RK3308_ADC_R_CH_BIST_MSK,
+							   RK3308_ADC_R_CH_BIST_SINE);
+				}
+			}
+		}
+
+		rk3308_codec_open_capture(rk3308);
+		rk3308_codec_adc_dig_config(rk3308, params);
+		rk3308_codec_update_adcs_status(rk3308, PATH_BUSY);
+	}
+
+	return 0;
+}
+
+static int rk3308_pcm_trigger(struct snd_pcm_substream *substream,
+			      int cmd, struct snd_soc_dai *dai)
+{
+	struct snd_soc_component *component = dai->component;
+	struct rk3308_codec_priv *rk3308 = snd_soc_component_get_drvdata(component);
+	int type = ADC_TYPE_LOOPBACK;
+	int idx, grp;
+
+	if (handle_loopback(rk3308) &&
+	    rk3308->dac_output == DAC_LINEOUT &&
+	    substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		if (cmd == SNDRV_PCM_TRIGGER_START) {
+			struct snd_pcm_str *capture_str =
+				&substream->pcm->streams[SNDRV_PCM_STREAM_CAPTURE];
+
+			if (capture_str->substream_opened)
+				queue_delayed_work(system_power_efficient_wq,
+						   &rk3308->loopback_work,
+						   msecs_to_jiffies(rk3308->delay_loopback_handle_ms));
+		} else if (cmd == SNDRV_PCM_TRIGGER_STOP) {
+			/*
+			 * Switch to dummy bist mode to kick the glitch during disable
+			 * ADCs and keep zero input data
+			 */
+			for (idx = 0; adc_for_each_grp(rk3308, type, idx, &grp); idx++) {
+				if (grp < 0 || grp > ADC_LR_GROUP_MAX - 1)
+					continue;
+
+				regmap_update_bits(rk3308->regmap,
+						   RK3308_ADC_DIG_CON03(grp),
+						   RK3308_ADC_L_CH_BIST_MSK,
+						   RK3308_ADC_L_CH_BIST_SINE);
+				regmap_update_bits(rk3308->regmap,
+						   RK3308_ADC_DIG_CON03(grp),
+						   RK3308_ADC_R_CH_BIST_MSK,
+						   RK3308_ADC_R_CH_BIST_SINE);
+			}
+			rk3308_codec_adc_ana_disable(rk3308, ADC_TYPE_LOOPBACK);
+		}
+	}
+
+	return 0;
+}
+
+static void rk3308_pcm_shutdown(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	struct snd_soc_component *component = dai->component;
+	struct rk3308_codec_priv *rk3308 = snd_soc_component_get_drvdata(component);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		rk3308_codec_close_playback(rk3308);
+		rk3308_codec_dac_mclk_disable(rk3308);
+		regcache_cache_only(rk3308->regmap, false);
+		regcache_sync(rk3308->regmap);
+		rk3308_codec_set_dac_path_state(rk3308, PATH_IDLE);
+	} else {
+		rk3308_codec_close_capture(rk3308);
+		if (!has_en_always_grps(rk3308)) {
+			rk3308_codec_adc_mclk_disable(rk3308);
+			rk3308_codec_update_adcs_status(rk3308, PATH_IDLE);
+			if (rk3308->micbias_num &&
+			    rk3308->enable_micbias)
+				rk3308_codec_micbias_disable(rk3308);
+		}
+
+		regcache_cache_only(rk3308->regmap, false);
+		regcache_sync(rk3308->regmap);
+	}
+}
+
+static struct snd_soc_dai_ops rk3308_dai_ops = {
+	.hw_params = rk3308_hw_params,
+	.set_fmt = rk3308_set_dai_fmt,
+	.mute_stream = rk3308_mute_stream,
+	.trigger = rk3308_pcm_trigger,
+	.shutdown = rk3308_pcm_shutdown,
+};
+
+static struct snd_soc_dai_driver rk3308_dai[] = {
+	{
+		.name = "rk3308-hifi",
+		.id = RK3308_HIFI,
+		.playback = {
+			.stream_name = "HiFi Playback",
+			.channels_min = 2,
+			.channels_max = 2,
+			.rates = SNDRV_PCM_RATE_8000_192000,
+			.formats = (SNDRV_PCM_FMTBIT_S16_LE |
+				    SNDRV_PCM_FMTBIT_S20_3LE |
+				    SNDRV_PCM_FMTBIT_S24_LE |
+				    SNDRV_PCM_FMTBIT_S32_LE),
+		},
+		.capture = {
+			.stream_name = "HiFi Capture",
+			.channels_min = 1,
+			.channels_max = 8,
+			.rates = SNDRV_PCM_RATE_8000_192000,
+			.formats = (SNDRV_PCM_FMTBIT_S16_LE |
+				    SNDRV_PCM_FMTBIT_S20_3LE |
+				    SNDRV_PCM_FMTBIT_S24_LE |
+				    SNDRV_PCM_FMTBIT_S32_LE),
+		},
+		.ops = &rk3308_dai_ops,
+	},
+};
+
+static int rk3308_suspend(struct snd_soc_component *component)
+{
+	struct rk3308_codec_priv *rk3308 = snd_soc_component_get_drvdata(component);
+
+	if (rk3308->no_deep_low_power)
+		goto out;
+
+	rk3308_codec_dlp_down(rk3308);
+	clk_disable_unprepare(rk3308->mclk_rx);
+	clk_disable_unprepare(rk3308->mclk_tx);
+	clk_disable_unprepare(rk3308->pclk);
+
+out:
+	rk3308_set_bias_level(component, SND_SOC_BIAS_OFF);
+	return 0;
+}
+
+static int rk3308_resume(struct snd_soc_component *component)
+{
+	struct rk3308_codec_priv *rk3308 = snd_soc_component_get_drvdata(component);
+	int ret = 0;
+
+	if (rk3308->no_deep_low_power)
+		goto out;
+
+	ret = clk_prepare_enable(rk3308->pclk);
+	if (ret < 0) {
+		dev_err(rk3308->plat_dev,
+			"Failed to enable acodec pclk: %d\n", ret);
+		goto out;
+	}
+
+	ret = clk_prepare_enable(rk3308->mclk_rx);
+	if (ret < 0) {
+		dev_err(rk3308->plat_dev,
+			"Failed to enable i2s mclk_rx: %d\n", ret);
+		goto out;
+	}
+
+	ret = clk_prepare_enable(rk3308->mclk_tx);
+	if (ret < 0) {
+		dev_err(rk3308->plat_dev,
+			"Failed to enable i2s mclk_tx: %d\n", ret);
+		goto out;
+	}
+
+	rk3308_codec_dlp_up(rk3308);
+out:
+	rk3308_set_bias_level(component, SND_SOC_BIAS_STANDBY);
+	return ret;
+}
+
+static int rk3308_codec_default_gains(struct rk3308_codec_priv *rk3308)
+{
+	int grp;
+
+	/* Prepare ADC gains */
+	/* vendor step 12, set MIC PGA default gains */
+	for (grp = 0; grp < ADC_LR_GROUP_MAX; grp++) {
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON01(grp),
+				   RK3308_ADC_CH1_MIC_GAIN_MSK |
+				   RK3308_ADC_CH2_MIC_GAIN_MSK,
+				   RK3308_ADC_CH1_MIC_GAIN_0DB |
+				   RK3308_ADC_CH2_MIC_GAIN_0DB);
+	}
+
+	/* vendor step 13, set ALC default gains */
+	for (grp = 0; grp < ADC_LR_GROUP_MAX; grp++) {
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON03(grp),
+				   RK3308_ADC_CH1_ALC_GAIN_MSK,
+				   RK3308_ADC_CH1_ALC_GAIN_0DB);
+		regmap_update_bits(rk3308->regmap, RK3308_ADC_ANA_CON04(grp),
+				   RK3308_ADC_CH2_ALC_GAIN_MSK,
+				   RK3308_ADC_CH2_ALC_GAIN_0DB);
+	}
+
+	/* Prepare DAC gains */
+	/* Step 15, set HPMIX default gains */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON12,
+			   RK3308_DAC_L_HPMIX_GAIN_MSK |
+			   RK3308_DAC_R_HPMIX_GAIN_MSK,
+			   RK3308_DAC_L_HPMIX_GAIN_NDB_6 |
+			   RK3308_DAC_R_HPMIX_GAIN_NDB_6);
+
+	/* Step 18, set HPOUT default gains */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON05,
+			   RK3308_DAC_L_HPOUT_GAIN_MSK,
+			   RK3308_DAC_L_HPOUT_GAIN_NDB_39);
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON06,
+			   RK3308_DAC_R_HPOUT_GAIN_MSK,
+			   RK3308_DAC_R_HPOUT_GAIN_NDB_39);
+
+	/* Using the same gain to HPOUT LR channels */
+	rk3308->hpout_l_dgain = RK3308_DAC_L_HPOUT_GAIN_NDB_39;
+
+	/* Step 19, set LINEOUT default gains */
+	regmap_update_bits(rk3308->regmap, RK3308_DAC_ANA_CON04,
+			   RK3308_DAC_L_LINEOUT_GAIN_MSK |
+			   RK3308_DAC_R_LINEOUT_GAIN_MSK,
+			   RK3308_DAC_L_LINEOUT_GAIN_NDB_6 |
+			   RK3308_DAC_R_LINEOUT_GAIN_NDB_6);
+
+	return 0;
+}
+
+static int rk3308_codec_setup_en_always_adcs(struct rk3308_codec_priv *rk3308,
+					     struct device_node *np)
+{
+	int num, ret;
+
+	num = of_count_phandle_with_args(np, "rockchip,en-always-grps", NULL);
+	if (num < 0) {
+		if (num == -ENOENT) {
+			/*
+			 * If there is note use 'rockchip,en-always-grps'
+			 * property, return 0 is also right.
+			 */
+			ret = 0;
+		} else {
+			dev_err(rk3308->plat_dev,
+				"Failed to read 'rockchip,adc-grps-route' num: %d\n",
+				num);
+			ret = num;
+		}
+
+		rk3308->en_always_grps_num = 0;
+		return ret;
+	}
+
+	rk3308->en_always_grps_num = num;
+
+	ret = of_property_read_u32_array(np, "rockchip,en-always-grps",
+					 rk3308->en_always_grps, num);
+	if (ret < 0) {
+		dev_err(rk3308->plat_dev,
+			"Failed to read 'rockchip,en-always-grps': %d\n",
+			ret);
+		return ret;
+	}
+
+	/* Clear all of skip_grps flags. */
+	for (num = 0; num < ADC_LR_GROUP_MAX; num++)
+		rk3308->skip_grps[num] = 0;
+
+	/* The loopback grp should not be enabled always. */
+	for (num = 0; num < rk3308->en_always_grps_num; num++) {
+		if (rk3308->en_always_grps[num] == rk3308->loopback_grp) {
+			dev_err(rk3308->plat_dev,
+				"loopback_grp: %d should not be enabled always!\n",
+				rk3308->loopback_grp);
+			ret = -EINVAL;
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int rk3308_codec_dapm_mic_gains(struct rk3308_codec_priv *rk3308)
+{
+	int ret;
+
+	if (rk3308->codec_ver == ACODEC_VERSION_B) {
+		ret = snd_soc_add_component_controls(rk3308->component,
+						 mic_gains_b,
+						 ARRAY_SIZE(mic_gains_b));
+		if (ret) {
+			dev_err(rk3308->plat_dev,
+				"%s: add mic_gains_b failed: %d\n",
+				__func__, ret);
+			return ret;
+		}
+	} else {
+		ret = snd_soc_add_component_controls(rk3308->component,
+						 mic_gains_a,
+						 ARRAY_SIZE(mic_gains_a));
+		if (ret) {
+			dev_err(rk3308->plat_dev,
+				"%s: add mic_gains_a failed: %d\n",
+				__func__, ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int rk3308_codec_check_micbias(struct rk3308_codec_priv *rk3308,
+				      struct device_node *np)
+{
+	struct device *dev = (struct device *)rk3308->plat_dev;
+	int num = 0, ret;
+
+	/* Check internal micbias */
+	rk3308->micbias1 =
+		of_property_read_bool(np, "rockchip,micbias1");
+	if (rk3308->micbias1)
+		num++;
+
+	rk3308->micbias2 =
+		of_property_read_bool(np, "rockchip,micbias2");
+	if (rk3308->micbias2)
+		num++;
+
+	rk3308->micbias_volt = RK3308_ADC_MICBIAS_VOLT_0_85; /* by default */
+	rk3308->micbias_num = num;
+
+	/* Check external micbias */
+	rk3308->ext_micbias = EXT_MICBIAS_NONE;
+
+	rk3308->micbias_en_gpio = devm_gpiod_get_optional(dev,
+							  "micbias-en",
+							  GPIOD_IN);
+	if (!rk3308->micbias_en_gpio) {
+		dev_info(dev, "Don't need micbias-en gpio\n");
+	} else if (IS_ERR(rk3308->micbias_en_gpio)) {
+		ret = PTR_ERR(rk3308->micbias_en_gpio);
+		dev_err(dev, "Unable to claim gpio micbias-en\n");
+		return ret;
+	} else if (gpiod_get_value(rk3308->micbias_en_gpio)) {
+		rk3308->ext_micbias = EXT_MICBIAS_FUNC1;
+	}
+
+	rk3308->vcc_micbias = devm_regulator_get_optional(dev,
+							  "vmicbias");
+	if (IS_ERR(rk3308->vcc_micbias)) {
+		if (PTR_ERR(rk3308->vcc_micbias) == -EPROBE_DEFER)
+			return -EPROBE_DEFER;
+		dev_info(dev, "no vmicbias regulator found\n");
+	} else {
+		ret = regulator_enable(rk3308->vcc_micbias);
+		if (ret) {
+			dev_err(dev, "Can't enable vmicbias: %d\n", ret);
+			return ret;
+		}
+		rk3308->ext_micbias = EXT_MICBIAS_FUNC2;
+	}
+
+	dev_info(dev, "Check ext_micbias: %d\n", rk3308->ext_micbias);
+
+	return 0;
+}
+
+static int rk3308_codec_dapm_controls_prepare(struct rk3308_codec_priv *rk3308)
+{
+	int grp;
+
+	for (grp = 0; grp < ADC_LR_GROUP_MAX; grp++) {
+		rk3308->hpf_cutoff[grp] = 0;
+		rk3308->agc_l[grp] = 0;
+		rk3308->agc_r[grp] = 0;
+		rk3308->agc_asr_l[grp] = AGC_ASR_96KHZ;
+		rk3308->agc_asr_r[grp] = AGC_ASR_96KHZ;
+	}
+
+	rk3308_codec_dapm_mic_gains(rk3308);
+
+	return 0;
+}
+
+static int rk3308_codec_prepare(struct rk3308_codec_priv *rk3308)
+{
+	/* Clear registers for ADC and DAC */
+	rk3308_codec_close_playback(rk3308);
+	rk3308_codec_close_all_capture(rk3308);
+	rk3308_codec_default_gains(rk3308);
+	rk3308_codec_llp_down(rk3308);
+	rk3308_codec_dapm_controls_prepare(rk3308);
+
+	return 0;
+}
+
+static int rk3308_probe(struct snd_soc_component *component)
+{
+	struct rk3308_codec_priv *rk3308 = snd_soc_component_get_drvdata(component);
+	int ext_micbias;
+
+	rk3308->component = component;
+	rk3308_codec_set_dac_path_state(rk3308, PATH_IDLE);
+
+	rk3308_codec_reset(component);
+	rk3308_codec_power_on(rk3308);
+
+	/* From vendor recommend, disable micbias at first. */
+	ext_micbias = rk3308->ext_micbias;
+	rk3308->ext_micbias = EXT_MICBIAS_NONE;
+	rk3308_codec_micbias_disable(rk3308);
+	rk3308->ext_micbias = ext_micbias;
+
+	rk3308_codec_prepare(rk3308);
+	if (!rk3308->no_hp_det)
+		rk3308_codec_headset_detect_enable(rk3308);
+
+	regcache_cache_only(rk3308->regmap, false);
+	regcache_sync(rk3308->regmap);
+
+	return 0;
+}
+
+static void rk3308_remove(struct snd_soc_component *component)
+{
+	struct rk3308_codec_priv *rk3308 = snd_soc_component_get_drvdata(component);
+
+	rk3308_headphone_ctl(rk3308, 0);
+	rk3308_speaker_ctl(rk3308, 0);
+	if (!rk3308->no_hp_det)
+		rk3308_codec_headset_detect_disable(rk3308);
+	rk3308_codec_micbias_disable(rk3308);
+	rk3308_codec_power_off(rk3308);
+
+	rk3308_codec_set_dac_path_state(rk3308, PATH_IDLE);
+
+	regcache_cache_only(rk3308->regmap, false);
+	regcache_sync(rk3308->regmap);
+
+}
+
+static const struct snd_soc_component_driver soc_codec_dev_rk3308_component = {
+	.probe					= rk3308_probe,
+	.remove					= rk3308_remove,
+	.resume         = rk3308_resume,
+	.suspend        = rk3308_suspend,
+	.set_bias_level	= rk3308_set_bias_level,
+	.controls				= rk3308_codec_dapm_controls,
+	.num_controls		= ARRAY_SIZE(rk3308_codec_dapm_controls),
+	// .dapm_widgets		= rk3308_dapm_widgets,
+	// .num_dapm_widgets	= ARRAY_SIZE(rk3308_dapm_widgets),
+	// .dapm_routes		= rk3308_dapm_routes,
+	// .num_dapm_routes	= ARRAY_SIZE(rk3308_dapm_routes),
+	// .suspend_bias_off	= 1,
+	// .idle_bias_on		= 1,
+	// .use_pmdown_time	= 1,
+	.endianness		= 1,
+	.non_legacy_dai_naming	= 1,
+};
+
+static const struct reg_default rk3308_codec_reg_defaults[] = {
+	{ RK3308_GLB_CON, 0x07 },
+};
+
+static bool rk3308_codec_write_read_reg(struct device *dev, unsigned int reg)
+{
+	/* All registers can be read / write */
+	return true;
+}
+
+static bool rk3308_codec_volatile_reg(struct device *dev, unsigned int reg)
+{
+	return true;
+}
+
+static void rk3308_codec_hpdetect_work(struct work_struct *work)
+{
+	struct rk3308_codec_priv *rk3308 =
+		container_of(work, struct rk3308_codec_priv, hpdet_work.work);
+	unsigned int val;
+	int need_poll = 0, need_irq = 0;
+	int need_report = 0, report_type = 0;
+	int dac_output = DAC_LINEOUT;
+
+	if (rk3308->codec_ver == ACODEC_VERSION_B) {
+		/* Check headphone plugged/unplugged directly. */
+		regmap_read(rk3308->detect_grf,
+			    DETECT_GRF_ACODEC_HPDET_STATUS, &val);
+		regmap_write(rk3308->detect_grf,
+			     DETECT_GRF_ACODEC_HPDET_STATUS_CLR, val);
+
+		if (rk3308->hp_jack_reversed) {
+			switch (val) {
+			case 0x0:
+			case 0x2:
+				dac_output = DAC_HPOUT;
+				report_type = SND_JACK_HEADPHONE;
+				break;
+			default:
+				break;
+			}
+		} else {
+			switch (val) {
+			case 0x1:
+				dac_output = DAC_HPOUT;
+				report_type = SND_JACK_HEADPHONE;
+				break;
+			default:
+				/* Includes val == 2 or others. */
+				break;
+			}
+		}
+
+		rk3308_codec_dac_switch(rk3308, dac_output);
+		if (rk3308->hpdet_jack)
+			snd_soc_jack_report(rk3308->hpdet_jack,
+					    report_type,
+					    SND_JACK_HEADPHONE);
+
+		enable_irq(rk3308->irq);
+
+		return;
+	}
+
+	/* Check headphone unplugged via poll. */
+	regmap_read(rk3308->regmap, RK3308_DAC_DIG_CON14, &val);
+
+	if (rk3308->hp_jack_reversed) {
+		if (!val) {
+			rk3308->hp_plugged = true;
+			report_type = SND_JACK_HEADPHONE;
+
+			need_report = 1;
+			need_irq = 1;
+		} else {
+			if (rk3308->hp_plugged) {
+				rk3308->hp_plugged = false;
+				need_report = 1;
+			}
+			need_poll = 1;
+		}
+	} else {
+		if (!val) {
+			rk3308->hp_plugged = false;
+
+			need_report = 1;
+			need_irq = 1;
+		} else {
+			if (!rk3308->hp_plugged) {
+				rk3308->hp_plugged = true;
+				report_type = SND_JACK_HEADPHONE;
+				need_report = 1;
+			}
+			need_poll = 1;
+		}
+	}
+
+	if (need_poll)
+		queue_delayed_work(system_power_efficient_wq,
+				   &rk3308->hpdet_work,
+				   msecs_to_jiffies(HPDET_POLL_MS));
+
+	if (need_report) {
+		if (report_type)
+			dac_output = DAC_HPOUT;
+
+		rk3308_codec_dac_switch(rk3308, dac_output);
+
+		if (rk3308->hpdet_jack)
+			snd_soc_jack_report(rk3308->hpdet_jack,
+					    report_type,
+					    SND_JACK_HEADPHONE);
+	}
+
+	if (need_irq)
+		enable_irq(rk3308->irq);
+}
+
+static void rk3308_codec_loopback_work(struct work_struct *work)
+{
+	struct rk3308_codec_priv *rk3308 =
+		container_of(work, struct rk3308_codec_priv, loopback_work.work);
+	int type = ADC_TYPE_LOOPBACK;
+	int idx, grp;
+
+	/* Prepare loopback ADCs */
+	rk3308_codec_adc_ana_enable(rk3308, type);
+
+	/* Waiting ADCs are stable */
+	msleep(ADC_STABLE_MS);
+
+	/* Recover normal mode after enable ADCs */
+	for (idx = 0; adc_for_each_grp(rk3308, type, idx, &grp); idx++) {
+		if (grp < 0 || grp > ADC_LR_GROUP_MAX - 1)
+			continue;
+
+		regmap_update_bits(rk3308->regmap,
+				   RK3308_ADC_DIG_CON03(grp),
+				   RK3308_ADC_L_CH_BIST_MSK,
+				   RK3308_ADC_L_CH_NORMAL_LEFT);
+		regmap_update_bits(rk3308->regmap,
+				   RK3308_ADC_DIG_CON03(grp),
+				   RK3308_ADC_R_CH_BIST_MSK,
+				   RK3308_ADC_R_CH_NORMAL_RIGHT);
+	}
+}
+
+static irqreturn_t rk3308_codec_hpdet_isr(int irq, void *data)
+{
+	struct rk3308_codec_priv *rk3308 = data;
+
+	/*
+	 * For the high level irq trigger, disable irq and avoid a lot of
+	 * repeated irq handlers entry.
+	 */
+	disable_irq_nosync(rk3308->irq);
+	queue_delayed_work(system_power_efficient_wq,
+			   &rk3308->hpdet_work, msecs_to_jiffies(10));
+
+	return IRQ_HANDLED;
+}
+
+void (*rk3308_codec_set_jack_detect_cb)(struct snd_soc_component *component,
+					struct snd_soc_jack *hpdet_jack);
+EXPORT_SYMBOL_GPL(rk3308_codec_set_jack_detect_cb);
+
+void rk3308_codec_set_jack_detect(struct snd_soc_component *component,
+				  struct snd_soc_jack *hpdet_jack)
+{
+	struct rk3308_codec_priv *rk3308 = snd_soc_component_get_drvdata(component);
+
+	rk3308->hpdet_jack = hpdet_jack;
+
+	/* To detect jack once during startup */
+	disable_irq_nosync(rk3308->irq);
+	queue_delayed_work(system_power_efficient_wq,
+			   &rk3308->hpdet_work, msecs_to_jiffies(10));
+
+	dev_info(rk3308->plat_dev, "%s: Request detect hp jack once\n",
+		 __func__);
+}
+
+static const struct regmap_config rk3308_codec_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = RK3308_DAC_ANA_CON15,
+	.writeable_reg = rk3308_codec_write_read_reg,
+	.readable_reg = rk3308_codec_write_read_reg,
+	.volatile_reg = rk3308_codec_volatile_reg,
+	.reg_defaults = rk3308_codec_reg_defaults,
+	.num_reg_defaults = ARRAY_SIZE(rk3308_codec_reg_defaults),
+	.cache_type = REGCACHE_FLAT,
+};
+
+static ssize_t pm_state_show(struct device *dev,
+			     struct device_attribute *attr,
+			     char *buf)
+{
+	struct rk3308_codec_priv *rk3308 =
+		container_of(dev, struct rk3308_codec_priv, dev);
+
+	return sprintf(buf, "pm_state: %d\n", rk3308->pm_state);
+}
+
+static ssize_t pm_state_store(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buf, size_t count)
+{
+	struct rk3308_codec_priv *rk3308 =
+		container_of(dev, struct rk3308_codec_priv, dev);
+	unsigned long pm_state;
+	int ret = kstrtoul(buf, 10, &pm_state);
+
+	if (ret < 0) {
+		dev_err(dev, "Invalid pm_state: %ld, ret: %d\n",
+			pm_state, ret);
+		return -EINVAL;
+	}
+
+	rk3308_codec_set_pm_state(rk3308, pm_state);
+
+	dev_info(dev, "Store pm_state: %d\n", rk3308->pm_state);
+
+	return count;
+}
+
+static ssize_t adc_grps_show(struct device *dev,
+			     struct device_attribute *attr,
+			     char *buf)
+{
+	struct rk3308_codec_priv *rk3308 =
+		container_of(dev, struct rk3308_codec_priv, dev);
+	u32 grp;
+	int type = ADC_TYPE_NORMAL, count = 0;
+	int idx;
+
+	count += sprintf(buf + count, "current used adc_grps:\n");
+	count += sprintf(buf + count, "- normal:");
+	for (idx = 0; adc_for_each_grp(rk3308, type, idx, &grp); idx++)
+		count += sprintf(buf + count, " %d", grp);
+	count += sprintf(buf + count, "\n");
+	count += sprintf(buf + count, "- loopback: %d\n",
+			 rk3308->loopback_grp);
+
+	return count;
+}
+
+static ssize_t adc_grps_store(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buf, size_t count)
+{
+	struct rk3308_codec_priv *rk3308 =
+		container_of(dev, struct rk3308_codec_priv, dev);
+	char adc_type;
+	int grps, ret;
+
+	ret = sscanf(buf, "%c,%d", &adc_type, &grps);
+	if (ret != 2) {
+		dev_err(rk3308->plat_dev, "%s sscanf failed: %d\n",
+			__func__, ret);
+		return -EFAULT;
+	}
+
+	if (adc_type == 'n')
+		rk3308->used_adc_grps = grps;
+	else if (adc_type == 'l')
+		rk3308->loopback_grp = grps;
+
+	return count;
+}
+
+static ssize_t adc_grps_route_show(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	struct rk3308_codec_priv *rk3308 =
+		container_of(dev, struct rk3308_codec_priv, dev);
+	char which_i2s[32] = {0};
+	int count = 0;
+	u32 grp;
+
+	switch (rk3308->which_i2s) {
+	case ACODEC_TO_I2S1_2CH:
+		strcpy(which_i2s, "i2s1_2ch");
+		break;
+	case ACODEC_TO_I2S3_4CH:
+		strcpy(which_i2s, "i2s3_4ch");
+		break;
+	default:
+		strcpy(which_i2s, "i2s2_8ch");
+		break;
+	}
+
+	count += sprintf(buf + count, "%s from acodec route mapping:\n",
+			 which_i2s);
+	for (grp = 0; grp < rk3308->to_i2s_grps; grp++) {
+		count += sprintf(buf + count, "* sdi_%d <-- sdo_%d\n",
+				 grp, rk3308->i2s_sdis[grp]);
+	}
+
+	return count;
+}
+
+static ssize_t adc_grps_route_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	struct rk3308_codec_priv *rk3308 =
+		container_of(dev, struct rk3308_codec_priv, dev);
+	int which_i2s, idx, i2s_sdis[ADC_LR_GROUP_MAX];
+	int ret;
+
+	ret = sscanf(buf, "%d,%d,%d,%d,%d", &which_i2s,
+		     &i2s_sdis[0], &i2s_sdis[1], &i2s_sdis[2], &i2s_sdis[3]);
+	if (ret != 5) {
+		dev_err(rk3308->plat_dev, "%s sscanf failed: %d\n",
+			__func__, ret);
+		goto err;
+	}
+
+	if (which_i2s < ACODEC_TO_I2S2_8CH ||
+	    which_i2s > ACODEC_TO_I2S1_2CH) {
+		dev_err(rk3308->plat_dev, "Invalid i2s type: %d\n", which_i2s);
+		goto err;
+	}
+
+	rk3308->which_i2s = which_i2s;
+
+	switch (rk3308->which_i2s) {
+	case ACODEC_TO_I2S1_2CH:
+		rk3308->to_i2s_grps = 1;
+		break;
+	case ACODEC_TO_I2S3_4CH:
+		rk3308->to_i2s_grps = 2;
+		break;
+	default:
+		rk3308->to_i2s_grps = 4;
+		break;
+	}
+
+	for (idx = 0; idx < rk3308->to_i2s_grps; idx++)
+		rk3308->i2s_sdis[idx] = i2s_sdis[idx];
+
+	rk3308_codec_adc_grps_route_config(rk3308);
+
+err:
+	return count;
+}
+
+static ssize_t adc_grp0_in_show(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	struct rk3308_codec_priv *rk3308 =
+		container_of(dev, struct rk3308_codec_priv, dev);
+
+	return sprintf(buf, "adc ch0 using: %s\n",
+		       rk3308->adc_grp0_using_linein ? "line in" : "mic in");
+}
+
+static ssize_t adc_grp0_in_store(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t count)
+{
+	struct rk3308_codec_priv *rk3308 =
+		container_of(dev, struct rk3308_codec_priv, dev);
+	unsigned long using_linein;
+	int ret = kstrtoul(buf, 10, &using_linein);
+
+	if (ret < 0 || using_linein > 1) {
+		dev_err(dev, "Invalid input status: %ld, ret: %d\n",
+			using_linein, ret);
+		return -EINVAL;
+	}
+
+	rk3308->adc_grp0_using_linein = using_linein;
+
+	dev_info(dev, "store using_linein: %d\n",
+		 rk3308->adc_grp0_using_linein);
+
+	return count;
+}
+
+static ssize_t adc_zerocross_show(struct device *dev,
+				  struct device_attribute *attr,
+				  char *buf)
+{
+	struct rk3308_codec_priv *rk3308 =
+		container_of(dev, struct rk3308_codec_priv, dev);
+
+	return sprintf(buf, "adc zerocross: %s\n",
+		       rk3308->adc_zerocross ? "enabled" : "disabled");
+}
+
+static ssize_t adc_zerocross_store(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t count)
+{
+	struct rk3308_codec_priv *rk3308 =
+		container_of(dev, struct rk3308_codec_priv, dev);
+	unsigned long zerocross;
+	int ret = kstrtoul(buf, 10, &zerocross);
+
+	if (ret < 0 || zerocross > 1) {
+		dev_err(dev, "Invalid zerocross: %ld, ret: %d\n",
+			zerocross, ret);
+		return -EINVAL;
+	}
+
+	rk3308->adc_zerocross = zerocross;
+
+	dev_info(dev, "store adc zerocross: %d\n", rk3308->adc_zerocross);
+
+	return count;
+}
+
+static ssize_t adc_grps_endisable_show(struct device *dev,
+				    struct device_attribute *attr,
+				    char *buf)
+{
+	struct rk3308_codec_priv *rk3308 =
+		container_of(dev, struct rk3308_codec_priv, dev);
+	int count = 0, i;
+
+	count += sprintf(buf + count, "enabled adc grps:");
+	for (i = 0; i < ADC_LR_GROUP_MAX; i++)
+		count += sprintf(buf + count, "%d ",
+				 rk3308->adc_grps_endisable[i]);
+
+	count += sprintf(buf + count, "\n");
+	return count;
+}
+
+static ssize_t adc_grps_endisable_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	struct rk3308_codec_priv *rk3308 =
+		container_of(dev, struct rk3308_codec_priv, dev);
+	int grp, endisable, ret;
+
+	ret = sscanf(buf, "%d,%d", &grp, &endisable);
+	if (ret != 2) {
+		dev_err(rk3308->plat_dev, "%s sscanf failed: %d\n",
+			__func__, ret);
+		return -EFAULT;
+	}
+
+	rk3308->cur_dbg_grp = grp;
+
+	if (endisable)
+		rk3308_codec_open_dbg_capture(rk3308);
+	else
+		rk3308_codec_close_dbg_capture(rk3308);
+
+	dev_info(dev, "ADC grp %d endisable: %d\n", grp, endisable);
+
+	return count;
+}
+
+static ssize_t dac_endisable_show(struct device *dev,
+				    struct device_attribute *attr,
+				    char *buf)
+{
+	struct rk3308_codec_priv *rk3308 =
+		container_of(dev, struct rk3308_codec_priv, dev);
+
+	return sprintf(buf, "%d\n", rk3308->dac_endisable);
+}
+
+static ssize_t dac_endisable_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	struct rk3308_codec_priv *rk3308 =
+		container_of(dev, struct rk3308_codec_priv, dev);
+	unsigned long endisable;
+	int ret = kstrtoul(buf, 10, &endisable);
+
+	if (ret < 0) {
+		dev_err(dev, "Invalid endisable: %ld, ret: %d\n",
+			endisable, ret);
+		return -EINVAL;
+	}
+
+	if (endisable)
+		rk3308_codec_open_playback(rk3308);
+	else
+		rk3308_codec_close_playback(rk3308);
+
+	dev_info(dev, "DAC endisable: %ld\n", endisable);
+
+	return count;
+}
+
+static ssize_t dac_output_show(struct device *dev,
+			       struct device_attribute *attr,
+			       char *buf)
+{
+	struct rk3308_codec_priv *rk3308 =
+		container_of(dev, struct rk3308_codec_priv, dev);
+	ssize_t ret = 0;
+
+	switch (rk3308->dac_output) {
+	case DAC_LINEOUT:
+		ret = sprintf(buf, "dac path: %s\n", "line out");
+		break;
+	case DAC_HPOUT:
+		ret = sprintf(buf, "dac path: %s\n", "hp out");
+		break;
+	case DAC_LINEOUT_HPOUT:
+		ret = sprintf(buf, "dac path: %s\n",
+			      "both line out and hp out");
+		break;
+	default:
+		pr_err("Invalid dac path: %d ?\n", rk3308->dac_output);
+		break;
+	}
+
+	return ret;
+}
+
+static ssize_t dac_output_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	struct rk3308_codec_priv *rk3308 =
+		container_of(dev, struct rk3308_codec_priv, dev);
+	unsigned long dac_output;
+	int ret = kstrtoul(buf, 10, &dac_output);
+
+	if (ret < 0) {
+		dev_err(dev, "Invalid input status: %ld, ret: %d\n",
+			dac_output, ret);
+		return -EINVAL;
+	}
+
+	rk3308_codec_dac_switch(rk3308, dac_output);
+
+	dev_info(dev, "Store dac_output: %d\n", rk3308->dac_output);
+
+	return count;
+}
+
+static ssize_t enable_all_adcs_show(struct device *dev,
+				    struct device_attribute *attr,
+				    char *buf)
+{
+	struct rk3308_codec_priv *rk3308 =
+		container_of(dev, struct rk3308_codec_priv, dev);
+
+	return sprintf(buf, "%d\n", rk3308->enable_all_adcs);
+}
+
+static ssize_t enable_all_adcs_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	struct rk3308_codec_priv *rk3308 =
+		container_of(dev, struct rk3308_codec_priv, dev);
+	unsigned long enable;
+	int ret = kstrtoul(buf, 10, &enable);
+
+	if (ret < 0) {
+		dev_err(dev, "Invalid enable value: %ld, ret: %d\n",
+			enable, ret);
+		return -EINVAL;
+	}
+
+	rk3308->enable_all_adcs = enable;
+
+	return count;
+}
+
+static const struct device_attribute acodec_attrs[] = {
+	__ATTR_RW(adc_grps),
+	__ATTR_RW(adc_grps_endisable),
+	__ATTR_RW(adc_grps_route),
+	__ATTR_RW(adc_grp0_in),
+	__ATTR_RW(adc_zerocross),
+	__ATTR_RW(dac_endisable),
+	__ATTR_RW(dac_output),
+	__ATTR_RW(enable_all_adcs),
+	__ATTR_RW(pm_state),
+};
+
+static void rk3308_codec_device_release(struct device *dev)
+{
+	/* Do nothing */
+}
+
+static int rk3308_codec_sysfs_init(struct platform_device *pdev,
+				   struct rk3308_codec_priv *rk3308)
+{
+	struct device *dev = &rk3308->dev;
+	int i;
+
+	dev->release = rk3308_codec_device_release;
+	dev->parent = &pdev->dev;
+	set_dev_node(dev, dev_to_node(&pdev->dev));
+	dev_set_name(dev, "rk3308-acodec-dev");
+
+	if (device_register(dev)) {
+		dev_err(&pdev->dev,
+			"Register 'rk3308-acodec-dev' failed\n");
+		dev->parent = NULL;
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(acodec_attrs); i++) {
+		if (device_create_file(dev, &acodec_attrs[i])) {
+			dev_err(&pdev->dev,
+				"Create 'rk3308-acodec-dev' attr failed\n");
+			device_unregister(dev);
+			return -ENOMEM;
+		}
+	}
+
+	return 0;
+}
+
+#if defined(CONFIG_DEBUG_FS)
+static int rk3308_codec_debugfs_reg_show(struct seq_file *s, void *v)
+{
+	struct rk3308_codec_priv *rk3308 = s->private;
+	unsigned int i;
+	unsigned int val;
+
+	for (i = RK3308_GLB_CON; i <= RK3308_DAC_ANA_CON13; i += 4) {
+		regmap_read(rk3308->regmap, i, &val);
+		if (!(i % 16))
+			seq_printf(s, "\nR:%04x: ", i);
+		seq_printf(s, "%08x ", val);
+	}
+
+	seq_puts(s, "\n");
+
+	return 0;
+}
+
+static ssize_t rk3308_codec_debugfs_reg_operate(struct file *file,
+						const char __user *buf,
+						size_t count, loff_t *ppos)
+{
+	struct rk3308_codec_priv *rk3308 =
+		((struct seq_file *)file->private_data)->private;
+	unsigned int reg, val;
+	char op;
+	char kbuf[32];
+	int ret;
+
+	if (count >= sizeof(kbuf))
+		return -EINVAL;
+
+	if (copy_from_user(kbuf, buf, count))
+		return -EFAULT;
+	kbuf[count] = '\0';
+
+	ret = sscanf(kbuf, "%c,%x,%x", &op, &reg, &val);
+	if (ret != 3) {
+		pr_err("sscanf failed: %d\n", ret);
+		return -EFAULT;
+	}
+
+	if (op == 'w') {
+		pr_info("Write reg: 0x%04x with val: 0x%08x\n", reg, val);
+		regmap_write(rk3308->regmap, reg, val);
+		regcache_cache_only(rk3308->regmap, false);
+		regcache_sync(rk3308->regmap);
+		pr_info("Read back reg: 0x%04x with val: 0x%08x\n", reg, val);
+	} else if (op == 'r') {
+		regmap_read(rk3308->regmap, reg, &val);
+		pr_info("Read reg: 0x%04x with val: 0x%08x\n", reg, val);
+	} else {
+		pr_err("This is an invalid operation: %c\n", op);
+	}
+
+	return count;
+}
+
+static int rk3308_codec_debugfs_open(struct inode *inode, struct file *file)
+{
+	return single_open(file,
+			   rk3308_codec_debugfs_reg_show, inode->i_private);
+}
+
+static const struct file_operations rk3308_codec_reg_debugfs_fops = {
+	.owner = THIS_MODULE,
+	.open = rk3308_codec_debugfs_open,
+	.read = seq_read,
+	.write = rk3308_codec_debugfs_reg_operate,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+#endif /* CONFIG_DEBUG_FS */
+
+static int rk3308_codec_get_version(struct rk3308_codec_priv *rk3308)
+{
+	unsigned int chip_id;
+
+	regmap_read(rk3308->grf, GRF_CHIP_ID, &chip_id);
+	switch (chip_id) {
+	case 3306:
+		rk3308->codec_ver = ACODEC_VERSION_A;
+		break;
+	case 0x3308:
+		rk3308->codec_ver = ACODEC_VERSION_B;
+		break;
+	default:
+		pr_err("Unknown chip_id: %d / 0x%x\n", chip_id, chip_id);
+		return -EFAULT;
+	}
+
+	pr_info("The acodec version is: %x\n", rk3308->codec_ver);
+	return 0;
+}
+
+static int rk3308_platform_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct rk3308_codec_priv *rk3308;
+	struct resource *res;
+	void __iomem *base;
+	int ret;
+
+	rk3308 = devm_kzalloc(&pdev->dev, sizeof(*rk3308), GFP_KERNEL);
+	if (!rk3308)
+		return -ENOMEM;
+
+	rk3308->grf = syscon_regmap_lookup_by_phandle(np, "rockchip,grf");
+	if (IS_ERR(rk3308->grf)) {
+		dev_err(&pdev->dev,
+			"Missing 'rockchip,grf' property\n");
+		return PTR_ERR(rk3308->grf);
+	}
+
+	ret = rk3308_codec_sysfs_init(pdev, rk3308);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Sysfs init failed\n");
+		return ret;
+	}
+
+#if defined(CONFIG_DEBUG_FS)
+	rk3308->dbg_codec = debugfs_create_dir(CODEC_DRV_NAME, NULL);
+	if (IS_ERR(rk3308->dbg_codec))
+		dev_err(&pdev->dev,
+			"Failed to create debugfs dir for rk3308!\n");
+	else
+		debugfs_create_file("reg", 0644, rk3308->dbg_codec,
+				    rk3308, &rk3308_codec_reg_debugfs_fops);
+#endif
+	rk3308->plat_dev = &pdev->dev;
+
+	rk3308->reset = devm_reset_control_get(&pdev->dev, "acodec-reset");
+	if (IS_ERR(rk3308->reset)) {
+		ret = PTR_ERR(rk3308->reset);
+		if (ret != -ENOENT)
+			return ret;
+
+		dev_dbg(&pdev->dev, "No reset control found\n");
+		rk3308->reset = NULL;
+	}
+
+	rk3308->hp_ctl_gpio = devm_gpiod_get_optional(&pdev->dev, "hp-ctl",
+						       GPIOD_OUT_LOW);
+	if (!rk3308->hp_ctl_gpio) {
+		dev_info(&pdev->dev, "Don't need hp-ctl gpio\n");
+	} else if (IS_ERR(rk3308->hp_ctl_gpio)) {
+		ret = PTR_ERR(rk3308->hp_ctl_gpio);
+		dev_err(&pdev->dev, "Unable to claim gpio hp-ctl\n");
+		return ret;
+	}
+
+	rk3308->spk_ctl_gpio = devm_gpiod_get_optional(&pdev->dev, "spk-ctl",
+						       GPIOD_OUT_LOW);
+
+	if (!rk3308->spk_ctl_gpio) {
+		dev_info(&pdev->dev, "Don't need spk-ctl gpio\n");
+	} else if (IS_ERR(rk3308->spk_ctl_gpio)) {
+		ret = PTR_ERR(rk3308->spk_ctl_gpio);
+		dev_err(&pdev->dev, "Unable to claim gpio spk-ctl\n");
+		return ret;
+	}
+
+	rk3308->pa_drv_gpio = devm_gpiod_get_optional(&pdev->dev, "pa-drv",
+						       GPIOD_OUT_LOW);
+
+	if (!rk3308->pa_drv_gpio) {
+		dev_info(&pdev->dev, "Don't need pa-drv gpio\n");
+	} else if (IS_ERR(rk3308->pa_drv_gpio)) {
+		ret = PTR_ERR(rk3308->pa_drv_gpio);
+		dev_err(&pdev->dev, "Unable to claim gpio pa-drv\n");
+		return ret;
+	}
+
+	if (rk3308->pa_drv_gpio) {
+		rk3308->delay_pa_drv_ms = PA_DRV_MS;
+		ret = of_property_read_u32(np, "rockchip,delay-pa-drv-ms",
+					   &rk3308->delay_pa_drv_ms);
+	}
+
+#if DEBUG_POP_ALWAYS
+	dev_info(&pdev->dev, "Enable all ctl gpios always for debugging pop\n");
+	rk3308_headphone_ctl(rk3308, 1);
+	rk3308_speaker_ctl(rk3308, 1);
+#else
+	dev_info(&pdev->dev, "De-pop as much as possible\n");
+	rk3308_headphone_ctl(rk3308, 0);
+	rk3308_speaker_ctl(rk3308, 0);
+#endif
+
+	rk3308->pclk = devm_clk_get(&pdev->dev, "acodec");
+	if (IS_ERR(rk3308->pclk)) {
+		dev_err(&pdev->dev, "Can't get acodec pclk\n");
+		return PTR_ERR(rk3308->pclk);
+	}
+
+	rk3308->mclk_rx = devm_clk_get(&pdev->dev, "mclk_rx");
+	if (IS_ERR(rk3308->mclk_rx)) {
+		dev_err(&pdev->dev, "Can't get acodec mclk_rx\n");
+		return PTR_ERR(rk3308->mclk_rx);
+	}
+
+	rk3308->mclk_tx = devm_clk_get(&pdev->dev, "mclk_tx");
+	if (IS_ERR(rk3308->mclk_tx)) {
+		dev_err(&pdev->dev, "Can't get acodec mclk_tx\n");
+		return PTR_ERR(rk3308->mclk_tx);
+	}
+
+	ret = clk_prepare_enable(rk3308->pclk);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Failed to enable acodec pclk: %d\n", ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(rk3308->mclk_rx);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Failed to enable i2s mclk_rx: %d\n", ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(rk3308->mclk_tx);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Failed to enable i2s mclk_tx: %d\n", ret);
+		return ret;
+	}
+
+	rk3308_codec_check_micbias(rk3308, np);
+
+	rk3308->enable_all_adcs =
+		of_property_read_bool(np, "rockchip,enable-all-adcs");
+
+	rk3308->hp_jack_reversed =
+		of_property_read_bool(np, "rockchip,hp-jack-reversed");
+
+	rk3308->no_deep_low_power =
+		of_property_read_bool(np, "rockchip,no-deep-low-power");
+
+	rk3308->no_hp_det =
+		of_property_read_bool(np, "rockchip,no-hp-det");
+
+	rk3308->delay_loopback_handle_ms = LOOPBACK_HANDLE_MS;
+	ret = of_property_read_u32(np, "rockchip,delay-loopback-handle-ms",
+				   &rk3308->delay_loopback_handle_ms);
+
+	rk3308->delay_start_play_ms = 0;
+	ret = of_property_read_u32(np, "rockchip,delay-start-play-ms",
+				   &rk3308->delay_start_play_ms);
+
+	rk3308->loopback_grp = NOT_USED;
+	ret = of_property_read_u32(np, "rockchip,loopback-grp",
+				   &rk3308->loopback_grp);
+	/*
+	 * If there is no loopback on some board, the -EINVAL indicates that
+	 * we don't need add the node, and it is not an error.
+	 */
+	if (ret < 0 && ret != -EINVAL) {
+		dev_err(&pdev->dev, "Failed to read loopback property: %d\n",
+			ret);
+		return ret;
+	}
+
+	ret = rk3308_codec_adc_grps_route(rk3308, np);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Failed to route ADC groups: %d\n",
+			ret);
+		return ret;
+	}
+
+	ret = rk3308_codec_setup_en_always_adcs(rk3308, np);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Failed to setup enabled always ADCs: %d\n",
+			ret);
+		return ret;
+	}
+
+	ret = rk3308_codec_get_version(rk3308);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Failed to get acodec version: %d\n",
+			ret);
+		return ret;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(base)) {
+		ret = PTR_ERR(base);
+		dev_err(&pdev->dev, "Failed to ioremap resource\n");
+		goto failed;
+	}
+
+	rk3308->regmap = devm_regmap_init_mmio(&pdev->dev, base,
+					       &rk3308_codec_regmap_config);
+	if (IS_ERR(rk3308->regmap)) {
+		ret = PTR_ERR(rk3308->regmap);
+		dev_err(&pdev->dev, "Failed to regmap mmio\n");
+		goto failed;
+	}
+
+	if (!rk3308->no_hp_det) {
+		int index = 0;
+
+		if (rk3308->codec_ver == ACODEC_VERSION_B)
+			index = 1;
+
+		rk3308->irq = platform_get_irq(pdev, index);
+		if (rk3308->irq < 0) {
+			dev_err(&pdev->dev, "Can not get codec irq\n");
+			goto failed;
+		}
+
+		INIT_DELAYED_WORK(&rk3308->hpdet_work, rk3308_codec_hpdetect_work);
+
+		ret = devm_request_irq(&pdev->dev, rk3308->irq,
+				       rk3308_codec_hpdet_isr,
+				       0,
+				       "acodec-hpdet",
+				       rk3308);
+		if (ret < 0) {
+			dev_err(&pdev->dev, "Failed to request IRQ: %d\n", ret);
+			goto failed;
+		}
+
+		if (rk3308->codec_ver == ACODEC_VERSION_B) {
+			rk3308->detect_grf =
+				syscon_regmap_lookup_by_phandle(np, "rockchip,detect-grf");
+			if (IS_ERR(rk3308->detect_grf)) {
+				dev_err(&pdev->dev,
+					"Missing 'rockchip,detect-grf' property\n");
+				return PTR_ERR(rk3308->detect_grf);
+			}
+
+			/* Configure filter count and enable hpdet irq. */
+			regmap_write(rk3308->detect_grf,
+				     DETECT_GRF_ACODEC_HPDET_COUNTER,
+				     DEFAULT_HPDET_COUNT);
+			regmap_write(rk3308->detect_grf,
+				     DETECT_GRF_ACODEC_HPDET_CON,
+				     (HPDET_BOTH_NEG_POS << 16) |
+				      HPDET_BOTH_NEG_POS);
+		}
+
+		rk3308_codec_set_jack_detect_cb = rk3308_codec_set_jack_detect;
+	}
+
+	if (rk3308->codec_ver == ACODEC_VERSION_A)
+		INIT_DELAYED_WORK(&rk3308->loopback_work,
+				  rk3308_codec_loopback_work);
+
+	rk3308->adc_grp0_using_linein = ADC_GRP0_MICIN;
+	rk3308->dac_output = DAC_LINEOUT;
+	rk3308->adc_zerocross = 1;
+	rk3308->pm_state = PM_NORMAL;
+
+	platform_set_drvdata(pdev, rk3308);
+
+	ret = devm_snd_soc_register_component(&pdev->dev, &soc_codec_dev_rk3308_component,
+				     rk3308_dai, ARRAY_SIZE(rk3308_dai));
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Failed to register component: %d\n", ret);
+		goto failed;
+	}
+
+	return ret;
+
+failed:
+	clk_disable_unprepare(rk3308->mclk_rx);
+	clk_disable_unprepare(rk3308->mclk_tx);
+	clk_disable_unprepare(rk3308->pclk);
+	device_unregister(&rk3308->dev);
+
+	return ret;
+}
+
+static int rk3308_platform_remove(struct platform_device *pdev)
+{
+	struct rk3308_codec_priv *rk3308 =
+		(struct rk3308_codec_priv *)platform_get_drvdata(pdev);
+
+	clk_disable_unprepare(rk3308->mclk_rx);
+	clk_disable_unprepare(rk3308->mclk_tx);
+	clk_disable_unprepare(rk3308->pclk);
+	device_unregister(&rk3308->dev);
+
+	return 0;
+}
+
+static const struct of_device_id rk3308codec_of_match[] = {
+	{ .compatible = "rockchip,rk3308-codec", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, rk3308codec_of_match);
+
+static struct platform_driver rk3308_codec_driver = {
+	.driver = {
+		   .name = CODEC_DRV_NAME,
+		   .of_match_table = of_match_ptr(rk3308codec_of_match),
+	},
+	.probe = rk3308_platform_probe,
+	.remove = rk3308_platform_remove,
+};
+module_platform_driver(rk3308_codec_driver);
+
+MODULE_AUTHOR("Xing Zheng <zhengxing@rock-chips.com>");
+MODULE_DESCRIPTION("ASoC RK3308 Codec Driver");
+MODULE_LICENSE("GPL v2");
Index: linux-5.10.27/sound/soc/codecs/rk3308_codec.h
===================================================================
--- /dev/null
+++ linux-5.10.27/sound/soc/codecs/rk3308_codec.h
@@ -0,0 +1,1070 @@
+/*
+ * rk3308_codec.h -- RK3308 ALSA Soc Audio Driver
+ *
+ * Copyright (c) 2018, Fuzhou Rockchip Electronics Co., Ltd All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef __RK3308_CODEC_H__
+#define __RK3308_CODEC_H__
+
+#define ACODEC_RESET_CTL			0x00 /* REG 0x00 */
+
+/* ADC DIGITAL REGISTERS */
+#define ACODEC_ADC_I2S_CTL0			0x04 /* REG 0x01 */
+#define ACODEC_ADC_I2S_CTL1			0x08 /* REG 0x02 */
+#define ACODEC_ADC_BIST_MODE_SEL		0x0c /* REG 0x03 */
+#define ACODEC_ADC_HPF_PATH			0x10 /* REG 0x04 */
+/* Resevred REG 0x05 ~ 0x06 */
+#define ACODEC_ADC_DATA_PATH			0x1c /* REG 0x07 */
+/* Resevred REG 0x08 ~ 0x0f */
+
+/* REG 0x10 ~ 0x1c are used to configure AGC of Left channel (ALC1) */
+#define ACODEC_ADC_PGA_AGC_L_CTL0		0x40 /* REG 0x10 */
+#define ACODEC_ADC_PGA_AGC_L_CTL1		0x44 /* REG 0x11 */
+#define ACODEC_ADC_PGA_AGC_L_CTL2		0x48 /* REG 0x12 */
+#define ACODEC_ADC_PGA_AGC_L_CTL3		0x4c /* REG 0x13 */
+#define ACODEC_ADC_PGA_AGC_L_CTL4		0x50 /* REG 0x14 */
+#define ACODEC_ADC_PGA_AGC_L_LO_MAX		0x54 /* REG 0x15 */
+#define ACODEC_ADC_PGA_AGC_L_HI_MAX		0x58 /* REG 0x16 */
+#define ACODEC_ADC_PGA_AGC_L_LO_MIN		0x5c /* REG 0x17 */
+#define ACODEC_ADC_PGA_AGC_L_HI_MIN		0x60 /* REG 0x18 */
+#define ACODEC_ADC_PGA_AGC_L_CTL5		0x64 /* REG 0x19 */
+/* Resevred REG 0x1a ~ 0x1b */
+#define ACODEC_ADC_AGC_L_RO_GAIN		0x70 /* REG 0x1c */
+
+/* REG 0x20 ~ 0x2c are used to configure AGC of Right channel (ALC2) */
+#define ACODEC_ADC_PGA_AGC_R_CTL0		0x80 /* REG 0x20 */
+#define ACODEC_ADC_PGA_AGC_R_CTL1		0x84 /* REG 0x21 */
+#define ACODEC_ADC_PGA_AGC_R_CTL2		0x88 /* REG 0x22 */
+#define ACODEC_ADC_PGA_AGC_R_CTL3		0x8c /* REG 0x23 */
+#define ACODEC_ADC_PGA_AGC_R_CTL4		0x90 /* REG 0x24 */
+#define ACODEC_ADC_PGA_AGC_R_LO_MAX		0x94 /* REG 0x25 */
+#define ACODEC_ADC_PGA_AGC_R_HI_MAX		0x98 /* REG 0x26 */
+#define ACODEC_ADC_PGA_AGC_R_LO_MIN		0x9c /* REG 0x27 */
+#define ACODEC_ADC_PGA_AGC_R_HI_MIN		0xa0 /* REG 0x28 */
+#define ACODEC_ADC_PGA_AGC_R_CTL5		0xa4 /* REG 0x29 */
+/* Resevred REG 0x2a ~ 0x2b */
+#define ACODEC_ADC_AGC_R_RO_GAIN		0xb0 /* REG 0x2c */
+
+/* DAC DIGITAL REGISTERS */
+#define ACODEC_DAC_I2S_CTL0			0x04 /* REG 0x01 */
+#define ACODEC_DAC_I2S_CTL1			0x08 /* REG 0x02 */
+#define ACODEC_DAC_BIST_MODE_SEL		0x0c /* REG 0x03 */
+#define ACODEC_DAC_DIGITAL_GAIN			0x10 /* REG 0x04 */
+#define ACODEC_DAC_DATA_SEL			0x14 /* REG 0x05 */
+/* Resevred REG 0x06 ~ 0x09 */
+#define ACODEC_DAC_DATA_HI			0x28 /* REG 0x0a */
+#define ACODEC_DAC_DATA_LO			0x2c /* REG 0x0b */
+/* Resevred REG 0x0c */
+#define ACODEC_DAC_HPDET_DELAYTIME		0x34 /* REG 0x0d */
+#define ACODEC_DAC_HPDET_STATUS			0x38 /* REG 0x0e, Read-only */
+/* Resevred REG 0x0f */
+
+/* ADC ANALOG REGISTERS */
+#define ACODEC_ADC_ANA_MIC_CTL			0x00 /* REG 0x00 */
+#define ACODEC_ADC_ANA_MIC_GAIN			0x04 /* REG 0x01 */
+#define ACODEC_ADC_ANA_ALC_CTL			0x08 /* REG 0x02 */
+#define ACODEC_ADC_ANA_ALC_GAIN1		0x0c /* REG 0x03 */
+#define ACODEC_ADC_ANA_ALC_GAIN2		0x10 /* REG 0x04 */
+#define ACODEC_ADC_ANA_CTL0			0x14 /* REG 0x05 */
+#define ACODEC_ADC_ANA_CTL1			0x18 /* REG 0x06 */
+#define ACODEC_ADC_ANA_CTL2			0x1c /* REG 0x07 */
+#define ACODEC_ADC_ANA_CTL3			0x20 /* REG 0x08 */
+/* Resevred REG 0x09 */
+#define ACODEC_ADC_ANA_CTL4			0x28 /* REG 0x0a */
+#define ACODEC_ADC_ANA_ALC_PGA			0x2c /* REG 0x0b */
+/* Resevred REG 0x0c ~ 0x0f */
+
+/* DAC ANALOG REGISTERS */
+#define ACODEC_DAC_ANA_CTL0			0x00 /* REG 0x00 */
+#define ACODEC_DAC_ANA_POP_VOLT			0x04 /* REG 0x01 */
+#define ACODEC_DAC_ANA_CTL1			0x08 /* REG 0x02 */
+#define ACODEC_DAC_ANA_HPOUT			0x0c /* REG 0x03 */
+#define ACODEC_DAC_ANA_LINEOUT			0x10 /* REG 0x04 */
+#define ACODEC_DAC_ANA_L_HPOUT_GAIN		0x14 /* REG 0x05 */
+#define ACODEC_DAC_ANA_R_HPOUT_GAIN		0x18 /* REG 0x06 */
+#define ACODEC_DAC_ANA_DRV_HPOUT		0x1c /* REG 0x07 */
+#define ACODEC_DAC_ANA_DRV_LINEOUT		0x20 /* REG 0x08 */
+/* Resevred REG 0x07 ~ 0x0b */
+#define ACODEC_DAC_ANA_HPMIX_CTL0		0x30 /* REG 0x0c */
+#define ACODEC_DAC_ANA_HPMIX_CTL1		0x34 /* REG 0x0d */
+#define ACODEC_DAC_ANA_LINEOUT_CTL0		0x38 /* REG 0x0e */
+#define ACODEC_DAC_ANA_LINEOUT_CTL1		0x3c /* REG 0x0f */
+
+/*
+ * These registers are referenced by codec driver
+ */
+
+#define RK3308_GLB_CON				ACODEC_RESET_CTL
+
+/* ADC DIGITAL REGISTERS */
+
+/*
+ * The ADC group are 0 ~ 3, that control:
+ *
+ * CH0: left_0(ADC1) and right_0(ADC2)
+ * CH1: left_1(ADC3) and right_1(ADC4)
+ * CH2: left_2(ADC5) and right_2(ADC6)
+ * CH3: left_3(ADC7) and right_3(ADC8)
+ */
+#define RK3308_ADC_DIG_OFFSET(ch)		((ch & 0x3) * 0xc0 + 0x0)
+
+#define RK3308_ADC_DIG_CON01(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_I2S_CTL0)
+#define RK3308_ADC_DIG_CON02(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_I2S_CTL1)
+#define RK3308_ADC_DIG_CON03(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_BIST_MODE_SEL)
+#define RK3308_ADC_DIG_CON04(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_HPF_PATH)
+#define RK3308_ADC_DIG_CON07(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_DATA_PATH)
+
+#define RK3308_ALC_L_DIG_CON00(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_PGA_AGC_L_CTL0)
+#define RK3308_ALC_L_DIG_CON01(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_PGA_AGC_L_CTL1)
+#define RK3308_ALC_L_DIG_CON02(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_PGA_AGC_L_CTL2)
+#define RK3308_ALC_L_DIG_CON03(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_PGA_AGC_L_CTL3)
+#define RK3308_ALC_L_DIG_CON04(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_PGA_AGC_L_CTL4)
+#define RK3308_ALC_L_DIG_CON05(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_PGA_AGC_L_LO_MAX)
+#define RK3308_ALC_L_DIG_CON06(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_PGA_AGC_L_HI_MAX)
+#define RK3308_ALC_L_DIG_CON07(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_PGA_AGC_L_LO_MIN)
+#define RK3308_ALC_L_DIG_CON08(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_PGA_AGC_L_HI_MIN)
+#define RK3308_ALC_L_DIG_CON09(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_PGA_AGC_L_CTL5)
+#define RK3308_ALC_L_DIG_CON12(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_AGC_L_RO_GAIN)
+
+#define RK3308_ALC_R_DIG_CON00(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_PGA_AGC_R_CTL0)
+#define RK3308_ALC_R_DIG_CON01(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_PGA_AGC_R_CTL1)
+#define RK3308_ALC_R_DIG_CON02(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_PGA_AGC_R_CTL2)
+#define RK3308_ALC_R_DIG_CON03(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_PGA_AGC_R_CTL3)
+#define RK3308_ALC_R_DIG_CON04(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_PGA_AGC_R_CTL4)
+#define RK3308_ALC_R_DIG_CON05(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_PGA_AGC_R_LO_MAX)
+#define RK3308_ALC_R_DIG_CON06(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_PGA_AGC_R_HI_MAX)
+#define RK3308_ALC_R_DIG_CON07(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_PGA_AGC_R_LO_MIN)
+#define RK3308_ALC_R_DIG_CON08(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_PGA_AGC_R_HI_MIN)
+#define RK3308_ALC_R_DIG_CON09(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_PGA_AGC_R_CTL5)
+#define RK3308_ALC_R_DIG_CON12(ch)		(RK3308_ADC_DIG_OFFSET(ch) + ACODEC_ADC_AGC_R_RO_GAIN)
+
+/* DAC DIGITAL REGISTERS */
+#define RK3308_DAC_DIG_OFFSET			0x300
+
+#define RK3308_DAC_DIG_CON01			(RK3308_DAC_DIG_OFFSET + ACODEC_DAC_I2S_CTL0)
+#define RK3308_DAC_DIG_CON02			(RK3308_DAC_DIG_OFFSET + ACODEC_DAC_I2S_CTL1)
+#define RK3308_DAC_DIG_CON03			(RK3308_DAC_DIG_OFFSET + ACODEC_DAC_BIST_MODE_SEL)
+#define RK3308_DAC_DIG_CON04			(RK3308_DAC_DIG_OFFSET + ACODEC_DAC_DIGITAL_GAIN)
+#define RK3308_DAC_DIG_CON05			(RK3308_DAC_DIG_OFFSET + ACODEC_DAC_DATA_SEL)
+#define RK3308_DAC_DIG_CON10			(RK3308_DAC_DIG_OFFSET + ACODEC_DAC_DATA_HI)
+#define RK3308_DAC_DIG_CON11			(RK3308_DAC_DIG_OFFSET + ACODEC_DAC_DATA_LO)
+#define RK3308_DAC_DIG_CON13			(RK3308_DAC_DIG_OFFSET + ACODEC_DAC_HPDET_DELAYTIME)
+#define RK3308_DAC_DIG_CON14			(RK3308_DAC_DIG_OFFSET + ACODEC_DAC_HPDET_STATUS)
+
+/* ADC ANALOG REGISTERS */
+/*
+ * The ADC group are 0 ~ 3, that control:
+ *
+ * CH0: left_0(ADC1) and right_0(ADC2)
+ * CH1: left_1(ADC3) and right_1(ADC4)
+ * CH2: left_2(ADC5) and right_2(ADC6)
+ * CH3: left_3(ADC7) and right_3(ADC8)
+ */
+#define RK3308_ADC_ANA_OFFSET(ch)		((ch & 0x3) * 0x40 + 0x340)
+
+#define RK3308_ADC_ANA_CON00(ch)		(RK3308_ADC_ANA_OFFSET(ch) + ACODEC_ADC_ANA_MIC_CTL)
+#define RK3308_ADC_ANA_CON01(ch)		(RK3308_ADC_ANA_OFFSET(ch) + ACODEC_ADC_ANA_MIC_GAIN)
+#define RK3308_ADC_ANA_CON02(ch)		(RK3308_ADC_ANA_OFFSET(ch) + ACODEC_ADC_ANA_ALC_CTL)
+#define RK3308_ADC_ANA_CON03(ch)		(RK3308_ADC_ANA_OFFSET(ch) + ACODEC_ADC_ANA_ALC_GAIN1)
+#define RK3308_ADC_ANA_CON04(ch)		(RK3308_ADC_ANA_OFFSET(ch) + ACODEC_ADC_ANA_ALC_GAIN2)
+#define RK3308_ADC_ANA_CON05(ch)		(RK3308_ADC_ANA_OFFSET(ch) + ACODEC_ADC_ANA_CTL0)
+#define RK3308_ADC_ANA_CON06(ch)		(RK3308_ADC_ANA_OFFSET(ch) + ACODEC_ADC_ANA_CTL1)
+#define RK3308_ADC_ANA_CON07(ch)		(RK3308_ADC_ANA_OFFSET(ch) + ACODEC_ADC_ANA_CTL2)
+#define RK3308_ADC_ANA_CON08(ch)		(RK3308_ADC_ANA_OFFSET(ch) + ACODEC_ADC_ANA_CTL3)
+#define RK3308_ADC_ANA_CON10(ch)		(RK3308_ADC_ANA_OFFSET(ch) + ACODEC_ADC_ANA_CTL4)
+#define RK3308_ADC_ANA_CON11(ch)		(RK3308_ADC_ANA_OFFSET(ch) + ACODEC_ADC_ANA_ALC_PGA)
+
+/* DAC ANALOG REGISTERS */
+#define RK3308_DAC_ANA_OFFSET			0x440
+#define RK3308_DAC_ANA_CON00			(RK3308_DAC_ANA_OFFSET + ACODEC_DAC_ANA_CTL0)
+#define RK3308_DAC_ANA_CON01			(RK3308_DAC_ANA_OFFSET + ACODEC_DAC_ANA_POP_VOLT)
+#define RK3308_DAC_ANA_CON02			(RK3308_DAC_ANA_OFFSET + ACODEC_DAC_ANA_CTL1)
+#define RK3308_DAC_ANA_CON03			(RK3308_DAC_ANA_OFFSET + ACODEC_DAC_ANA_HPOUT)
+#define RK3308_DAC_ANA_CON04			(RK3308_DAC_ANA_OFFSET + ACODEC_DAC_ANA_LINEOUT)
+#define RK3308_DAC_ANA_CON05			(RK3308_DAC_ANA_OFFSET + ACODEC_DAC_ANA_L_HPOUT_GAIN)
+#define RK3308_DAC_ANA_CON06			(RK3308_DAC_ANA_OFFSET + ACODEC_DAC_ANA_R_HPOUT_GAIN)
+#define RK3308_DAC_ANA_CON07			(RK3308_DAC_ANA_OFFSET + ACODEC_DAC_ANA_DRV_HPOUT)
+#define RK3308_DAC_ANA_CON08			(RK3308_DAC_ANA_OFFSET + ACODEC_DAC_ANA_DRV_LINEOUT)
+#define RK3308_DAC_ANA_CON12			(RK3308_DAC_ANA_OFFSET + ACODEC_DAC_ANA_HPMIX_CTL0)
+#define RK3308_DAC_ANA_CON13			(RK3308_DAC_ANA_OFFSET + ACODEC_DAC_ANA_HPMIX_CTL1)
+#define RK3308_DAC_ANA_CON14			(RK3308_DAC_ANA_OFFSET + ACODEC_DAC_ANA_LINEOUT_CTL0)
+#define RK3308_DAC_ANA_CON15			(RK3308_DAC_ANA_OFFSET + ACODEC_DAC_ANA_LINEOUT_CTL1)
+
+/*
+ * These are the bits for registers
+ */
+
+/* RK3308_GLB_CON - REG: 0x0000 */
+#define RK3308_ADC_BIST_WORK			(1 << 7)
+#define RK3308_ADC_BIST_RESET			(0 << 7)
+#define RK3308_DAC_BIST_WORK			(1 << 6)
+#define RK3308_DAC_BIST_RESET			(0 << 6)
+#define RK3308_ADC_MCLK_MSK			(1 << 5)
+#define RK3308_ADC_MCLK_DIS			(1 << 5)
+#define RK3308_ADC_MCLK_EN			(0 << 5)
+#define RK3308_DAC_MCLK_MSK			(1 << 4)
+#define RK3308_DAC_MCLK_DIS			(1 << 4)
+#define RK3308_DAC_MCLK_EN			(0 << 4)
+#define RK3308_CODEC_RST_MSK			(0x7 << 0)
+#define RK3308_ADC_DIG_WORK			(1 << 2)
+#define RK3308_ADC_DIG_RESET			(0 << 2)
+#define RK3308_DAC_DIG_WORK			(1 << 1)
+#define RK3308_DAC_DIG_RESET			(0 << 1)
+#define RK3308_SYS_WORK				(1 << 0)
+#define RK3308_SYS_RESET			(0 << 0)
+
+/* RK3308_ADC_DIG_CON01 - REG: 0x0004 */
+#define RK3308_ADC_I2S_LRC_POL_MSK		(1 << 0)
+#define RK3308_ADC_I2S_LRC_POL_REVERSAL		(1 << 0)
+#define RK3308_ADC_I2S_LRC_POL_NORMAL		(0 << 0)
+#define RK3308_ADC_I2S_VALID_LEN_SFT		5
+#define RK3308_ADC_I2S_VALID_LEN_MSK		(0x3 << RK3308_ADC_I2S_VALID_LEN_SFT)
+#define RK3308_ADC_I2S_VALID_LEN_32BITS		(0x3 << RK3308_ADC_I2S_VALID_LEN_SFT)
+#define RK3308_ADC_I2S_VALID_LEN_24BITS		(0x2 << RK3308_ADC_I2S_VALID_LEN_SFT)
+#define RK3308_ADC_I2S_VALID_LEN_20BITS		(0x1 << RK3308_ADC_I2S_VALID_LEN_SFT)
+#define RK3308_ADC_I2S_VALID_LEN_16BITS		(0x0 << RK3308_ADC_I2S_VALID_LEN_SFT)
+#define RK3308_ADC_I2S_MODE_SFT			3
+#define RK3308_ADC_I2S_MODE_MSK			(0x3 << RK3308_ADC_I2S_MODE_SFT)
+#define RK3308_ADC_I2S_MODE_PCM			(0x3 << RK3308_ADC_I2S_MODE_SFT)
+#define RK3308_ADC_I2S_MODE_I2S			(0x2 << RK3308_ADC_I2S_MODE_SFT)
+#define RK3308_ADC_I2S_MODE_LJ			(0x1 << RK3308_ADC_I2S_MODE_SFT)
+#define RK3308_ADC_I2S_MODE_RJ			(0x0 << RK3308_ADC_I2S_MODE_SFT)
+#define RK3308_ADC_I2S_LR_MSK			(1 << 1)
+#define RK3308_ADC_I2S_LR_SWAP			(1 << 1)
+#define RK3308_ADC_I2S_LR_NORMAL		(0 << 1)
+#define RK3308_ADC_I2S_TYPE_MSK			(1 << 0)
+#define RK3308_ADC_I2S_MONO			(1 << 0)
+#define RK3308_ADC_I2S_STEREO			(0 << 0)
+
+/* RK3308_ADC_DIG_CON02 - REG: 0x0008 */
+#define RK3308_ADC_IO_MODE_MSK			(1 << 5)
+#define RK3308_ADC_IO_MODE_MASTER		(1 << 5)
+#define RK3308_ADC_IO_MODE_SLAVE		(0 << 5)
+#define RK3308_ADC_MODE_MSK			(1 << 4)
+#define RK3308_ADC_MODE_MASTER			(1 << 4)
+#define RK3308_ADC_MODE_SLAVE			(0 << 4)
+#define RK3308_ADC_I2S_FRAME_LEN_SFT		2
+#define RK3308_ADC_I2S_FRAME_LEN_MSK		(0x3 << RK3308_ADC_I2S_FRAME_LEN_SFT)
+#define RK3308_ADC_I2S_FRAME_32BITS		(0x3 << RK3308_ADC_I2S_FRAME_LEN_SFT)
+#define RK3308_ADC_I2S_FRAME_24BITS		(0x2 << RK3308_ADC_I2S_FRAME_LEN_SFT)
+#define RK3308_ADC_I2S_FRAME_20BITS		(0x1 << RK3308_ADC_I2S_FRAME_LEN_SFT)
+#define RK3308_ADC_I2S_FRAME_16BITS		(0x0 << RK3308_ADC_I2S_FRAME_LEN_SFT)
+#define RK3308_ADC_I2S_MSK			(0x1 << 1)
+#define RK3308_ADC_I2S_WORK			(0x1 << 1)
+#define RK3308_ADC_I2S_RESET			(0x0 << 1)
+#define RK3308_ADC_I2S_BIT_CLK_POL_MSK		(0x1 << 0)
+#define RK3308_ADC_I2S_BIT_CLK_POL_REVERSAL	(0x1 << 0)
+#define RK3308_ADC_I2S_BIT_CLK_POL_NORMAL	(0x0 << 0)
+
+/* RK3308_ADC_DIG_CON03 - REG: 0x000c */
+#define RK3308_ADC_L_CH_BIST_SFT		2
+#define RK3308_ADC_L_CH_BIST_MSK		(0x3 << RK3308_ADC_L_CH_BIST_SFT)
+#define RK3308_ADC_L_CH_NORMAL_RIGHT		(0x3 << RK3308_ADC_L_CH_BIST_SFT) /* normal mode */
+#define RK3308_ADC_L_CH_BIST_CUBE		(0x2 << RK3308_ADC_L_CH_BIST_SFT)
+#define RK3308_ADC_L_CH_BIST_SINE		(0x1 << RK3308_ADC_L_CH_BIST_SFT)
+#define RK3308_ADC_L_CH_NORMAL_LEFT		(0x0 << RK3308_ADC_L_CH_BIST_SFT) /* normal mode */
+#define RK3308_ADC_R_CH_BIST_SFT		0
+#define RK3308_ADC_R_CH_BIST_MSK		(0x3 << RK3308_ADC_R_CH_BIST_SFT)
+#define RK3308_ADC_R_CH_NORMAL_LEFT		(0x3 << RK3308_ADC_R_CH_BIST_SFT) /* normal mode */
+#define RK3308_ADC_R_CH_BIST_CUBE		(0x2 << RK3308_ADC_R_CH_BIST_SFT)
+#define RK3308_ADC_R_CH_BIST_SINE		(0x1 << RK3308_ADC_R_CH_BIST_SFT)
+#define RK3308_ADC_R_CH_NORMAL_RIGHT		(0x0 << RK3308_ADC_R_CH_BIST_SFT) /* normal mode */
+
+/* RK3308_ADC_DIG_CON04 - REG: 0x0010 */
+#define RK3308_ADC_HPF_PATH_SFT			2
+#define RK3308_ADC_HPF_PATH_MSK			(1 << RK3308_ADC_HPF_PATH_SFT)
+#define RK3308_ADC_HPF_PATH_DIS			(1 << RK3308_ADC_HPF_PATH_SFT)
+#define RK3308_ADC_HPF_PATH_EN			(0 << RK3308_ADC_HPF_PATH_SFT)
+#define RK3308_ADC_HPF_CUTOFF_SFT		0
+#define RK3308_ADC_HPF_CUTOFF_MSK		(0x3 << RK3308_ADC_HPF_CUTOFF_SFT)
+#define RK3308_ADC_HPF_CUTOFF_612HZ		(0x2 << RK3308_ADC_HPF_CUTOFF_SFT)
+#define RK3308_ADC_HPF_CUTOFF_245HZ		(0x1 << RK3308_ADC_HPF_CUTOFF_SFT)
+#define RK3308_ADC_HPF_CUTOFF_20HZ		(0x0 << RK3308_ADC_HPF_CUTOFF_SFT)
+
+/* RK3308_ADC_DIG_CON07 - REG: 0x001c */
+#define RK3308_ADCL_DATA_SFT			4
+#define RK3308_ADCL_DATA(x)			(x << RK3308_ADCL_DATA_SFT)
+#define RK3308_ADCR_DATA_SFT			2
+#define RK3308_ADCR_DATA(x)			(x << RK3308_ADCR_DATA_SFT)
+#define RK3308_ADCL_DATA_SEL_ADCL		(0x1 << 1)
+#define RK3308_ADCL_DATA_SEL_NORMAL		(0x0 << 1)
+#define RK3308_ADCR_DATA_SEL_ADCR		(0x1 << 0)
+#define RK3308_ADCR_DATA_SEL_NORMAL		(0x0 << 0)
+
+/*
+ * RK3308_ALC_L_DIG_CON00 - REG: 0x0040 + ch * 0xc0
+ * RK3308_ALC_R_DIG_CON00 - REG: 0x0080 + ch * 0xc0
+ */
+#define RK3308_GAIN_ATTACK_JACK			(0x1 << 6)
+#define RK3308_GAIN_ATTACK_NORMAL		(0x0 << 6)
+#define RK3308_CTRL_GEN_SFT			4
+#define RK3308_CTRL_GEN_MSK			(0x3 << RK3308_ALC_CTRL_GEN_SFT)
+#define RK3308_CTRL_GEN_JACK3			(0x3 << RK3308_ALC_CTRL_GEN_SFT)
+#define RK3308_CTRL_GEN_JACK2			(0x2 << RK3308_ALC_CTRL_GEN_SFT)
+#define RK3308_CTRL_GEN_JACK1			(0x1 << RK3308_ALC_CTRL_GEN_SFT)
+#define RK3308_CTRL_GEN_NORMAL			(0x0 << RK3308_ALC_CTRL_GEN_SFT)
+#define RK3308_AGC_HOLD_TIME_SFT		0
+#define RK3308_AGC_HOLD_TIME_MSK		(0xf << RK3308_AGC_HOLD_TIME_SFT)
+#define RK3308_AGC_HOLD_TIME_1S			(0xa << RK3308_AGC_HOLD_TIME_SFT)
+#define RK3308_AGC_HOLD_TIME_512MS		(0x9 << RK3308_AGC_HOLD_TIME_SFT)
+#define RK3308_AGC_HOLD_TIME_256MS		(0x8 << RK3308_AGC_HOLD_TIME_SFT)
+#define RK3308_AGC_HOLD_TIME_128MS		(0x7 << RK3308_AGC_HOLD_TIME_SFT)
+#define RK3308_AGC_HOLD_TIME_64MS		(0x6 << RK3308_AGC_HOLD_TIME_SFT)
+#define RK3308_AGC_HOLD_TIME_32MS		(0x5 << RK3308_AGC_HOLD_TIME_SFT)
+#define RK3308_AGC_HOLD_TIME_16MS		(0x4 << RK3308_AGC_HOLD_TIME_SFT)
+#define RK3308_AGC_HOLD_TIME_8MS		(0x3 << RK3308_AGC_HOLD_TIME_SFT)
+#define RK3308_AGC_HOLD_TIME_4MS		(0x2 << RK3308_AGC_HOLD_TIME_SFT)
+#define RK3308_AGC_HOLD_TIME_2MS		(0x1 << RK3308_AGC_HOLD_TIME_SFT)
+#define RK3308_AGC_HOLD_TIME_0MS		(0x0 << RK3308_AGC_HOLD_TIME_SFT)
+
+/*
+ * RK3308_ALC_L_DIG_CON01 - REG: 0x0044 + ch * 0xc0
+ * RK3308_ALC_R_DIG_CON01 - REG: 0x0084 + ch * 0xc0
+ */
+#define RK3308_AGC_DECAY_TIME_SFT		4
+/* Normal mode (reg_agc_mode = 0) */
+#define RK3308_AGC_DECAY_NORMAL_MSK		(0xf << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_NORMAL_512MS		(0xa << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_NORMAL_256MS		(0x9 << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_NORMAL_128MS		(0x8 << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_NORMAL_64MS		(0x7 << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_NORMAL_32MS		(0x6 << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_NORMAL_16MS		(0x5 << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_NORMAL_8MS		(0x4 << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_NORMAL_4MS		(0x3 << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_NORMAL_2MS		(0x2 << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_NORMAL_1MS		(0x1 << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_NORMAL_0MS		(0x0 << RK3308_AGC_DECAY_TIME_SFT)
+/* Limiter mode (reg_agc_mode = 1) */
+#define RK3308_AGC_DECAY_LIMITER_MSK		(0xf << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_LIMITER_128MS		(0xa << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_LIMITER_64MS		(0x9 << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_LIMITER_32MS		(0x8 << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_LIMITER_16MS		(0x7 << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_LIMITER_8MS		(0x6 << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_LIMITER_4MS		(0x5 << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_LIMITER_2MS		(0x4 << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_LIMITER_1MS		(0x3 << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_LIMITER_500US		(0x2 << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_LIMITER_250US		(0x1 << RK3308_AGC_DECAY_TIME_SFT)
+#define RK3308_AGC_DECAY_LIMITER_125US		(0x0 << RK3308_AGC_DECAY_TIME_SFT)
+
+#define RK3308_AGC_ATTACK_TIME_SFT		0
+/* Normal mode (reg_agc_mode = 0) */
+#define RK3308_AGC_ATTACK_NORMAL_MSK		(0xf << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_NORMAL_128MS		(0xa << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_NORMAL_64MS		(0x9 << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_NORMAL_32MS		(0x8 << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_NORMAL_16MS		(0x7 << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_NORMAL_8MS		(0x6 << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_NORMAL_4MS		(0x5 << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_NORMAL_2MS		(0x4 << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_NORMAL_1MS		(0x3 << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_NORMAL_500US		(0x2 << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_NORMAL_250US		(0x1 << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_NORMAL_125US		(0x0 << RK3308_AGC_ATTACK_TIME_SFT)
+/* Limiter mode (reg_agc_mode = 1) */
+#define RK3308_AGC_ATTACK_LIMITER_MSK		(0xf << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_LIMITER_32MS		(0xa << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_LIMITER_16MS		(0x9 << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_LIMITER_8MS		(0x8 << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_LIMITER_4MS		(0x7 << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_LIMITER_2MS		(0x6 << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_LIMITER_1MS		(0x5 << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_LIMITER_500US		(0x4 << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_LIMITER_250US		(0x3 << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_LIMITER_125US		(0x2 << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_LIMITER_64US		(0x1 << RK3308_AGC_ATTACK_TIME_SFT)
+#define RK3308_AGC_ATTACK_LIMITER_32US		(0x0 << RK3308_AGC_ATTACK_TIME_SFT)
+
+/*
+ * RK3308_ALC_L_DIG_CON02 - REG: 0x0048 + ch * 0xc0
+ * RK3308_ALC_R_DIG_CON02 - REG: 0x0088 + ch * 0xc0
+ */
+#define RK3308_AGC_MODE_LIMITER			(0x1 << 7)
+#define RK3308_AGC_MODE_NORMAL			(0x0 << 7)
+#define RK3308_AGC_ZERO_CRO_EN			(0x1 << 6)
+#define RK3308_AGC_ZERO_CRO_DIS			(0x0 << 6)
+#define RK3308_AGC_AMP_RECOVER_GAIN		(0x1 << 5)
+#define RK3308_AGC_AMP_RECOVER_LVOL		(0x0 << 5)
+#define RK3308_AGC_FAST_DEC_EN			(0x1 << 4)
+#define RK3308_AGC_FAST_DEC_DIS			(0x0 << 4)
+#define RK3308_AGC_NOISE_GATE_EN		(0x1 << 3)
+#define RK3308_AGC_NOISE_GATE_DIS		(0x0 << 3)
+#define RK3308_AGC_NOISE_GATE_THRESH_SFT	0
+#define RK3308_AGC_NOISE_GATE_THRESH_MSK	(0x7 << RK3308_AGC_NOISE_GATE_THRESH_SFT)
+#define RK3308_AGC_NOISE_GATE_THRESH_N81DB	(0x7 << RK3308_AGC_NOISE_GATE_THRESH_SFT)
+#define RK3308_AGC_NOISE_GATE_THRESH_N75DB	(0x6 << RK3308_AGC_NOISE_GATE_THRESH_SFT)
+#define RK3308_AGC_NOISE_GATE_THRESH_N69DB	(0x5 << RK3308_AGC_NOISE_GATE_THRESH_SFT)
+#define RK3308_AGC_NOISE_GATE_THRESH_N63DB	(0x4 << RK3308_AGC_NOISE_GATE_THRESH_SFT)
+#define RK3308_AGC_NOISE_GATE_THRESH_N57DB	(0x3 << RK3308_AGC_NOISE_GATE_THRESH_SFT)
+#define RK3308_AGC_NOISE_GATE_THRESH_N51DB	(0x2 << RK3308_AGC_NOISE_GATE_THRESH_SFT)
+#define RK3308_AGC_NOISE_GATE_THRESH_N45DB	(0x1 << RK3308_AGC_NOISE_GATE_THRESH_SFT)
+#define RK3308_AGC_NOISE_GATE_THRESH_N39DB	(0x0 << RK3308_AGC_NOISE_GATE_THRESH_SFT)
+
+/*
+ * RK3308_ALC_L_DIG_CON03 - REG: 0x004c + ch * 0xc0
+ * RK3308_ALC_R_DIG_CON03 - REG: 0x008c + ch * 0xc0
+ */
+#define RK3308_AGC_PGA_ZERO_CRO_EN		(0x1 << 5)
+#define RK3308_AGC_PGA_ZERO_CRO_DIS		(0x0 << 5)
+#define RK3308_AGC_PGA_GAIN_MAX			0x1f
+#define RK3308_AGC_PGA_GAIN_MIN			0
+#define RK3308_AGC_PGA_GAIN_SFT			0
+#define RK3308_AGC_PGA_GAIN_MSK			(0x1f << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_PDB_28_5		(0x1f << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_PDB_27		(0x1e << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_PDB_25_5		(0x1d << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_PDB_24		(0x1c << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_PDB_22_5		(0x1b << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_PDB_21		(0x1a << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_PDB_19_5		(0x19 << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_PDB_18		(0x18 << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_PDB_16_5		(0x17 << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_PDB_15		(0x16 << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_PDB_13_5		(0x15 << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_PDB_12		(0x14 << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_PDB_10_5		(0x13 << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_PDB_9		(0x12 << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_PDB_7_5		(0x11 << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_PDB_6		(0x10 << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_PDB_4_5		(0x0f << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_PDB_3		(0x0e << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_PDB_1_5		(0x0d << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_0DB			(0x0c << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_NDB_1_5		(0x0b << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_NDB_3		(0x0a << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_NDB_4_5		(0x09 << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_NDB_6		(0x08 << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_NDB_7_5		(0x07 << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_NDB_9		(0x06 << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_NDB_10_5		(0x05 << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_NDB_12		(0x04 << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_NDB_13_5		(0x03 << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_NDB_15		(0x02 << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_NDB_16_5		(0x01 << RK3308_AGC_PGA_GAIN_SFT)
+#define RK3308_AGC_PGA_GAIN_NDB_18		(0x00 << RK3308_AGC_PGA_GAIN_SFT)
+
+/*
+ * RK3308_ALC_L_DIG_CON04 - REG: 0x0050 + ch * 0xc0
+ * RK3308_ALC_R_DIG_CON04 - REG: 0x0090 + ch * 0xc0
+ */
+#define RK3308_AGC_SLOW_CLK_EN			(0x1 << 3)
+#define RK3308_AGC_SLOW_CLK_DIS			(0x0 << 3)
+#define RK3308_AGC_APPROX_RATE_SFT		0
+#define RK3308_AGC_APPROX_RATE_MSK		(0x7 << RK3308_AGC_APPROX_RATE_SFT)
+#define RK3308_AGC_APPROX_RATE_8K		(0x7 << RK3308_AGC_APPROX_RATE_SFT)
+#define RK3308_AGC_APPROX_RATE_12K		(0x6 << RK3308_AGC_APPROX_RATE_SFT)
+#define RK3308_AGC_APPROX_RATE_16K		(0x5 << RK3308_AGC_APPROX_RATE_SFT)
+#define RK3308_AGC_APPROX_RATE_24K		(0x4 << RK3308_AGC_APPROX_RATE_SFT)
+#define RK3308_AGC_APPROX_RATE_32K		(0x3 << RK3308_AGC_APPROX_RATE_SFT)
+#define RK3308_AGC_APPROX_RATE_44_1K		(0x2 << RK3308_AGC_APPROX_RATE_SFT)
+#define RK3308_AGC_APPROX_RATE_48K		(0x1 << RK3308_AGC_APPROX_RATE_SFT)
+#define RK3308_AGC_APPROX_RATE_96K		(0x0 << RK3308_AGC_APPROX_RATE_SFT)
+
+/*
+ * RK3308_ALC_L_DIG_CON05 - REG: 0x0054 + ch * 0xc0
+ * RK3308_ALC_R_DIG_CON05 - REG: 0x0094 + ch * 0xc0
+ */
+#define RK3308_AGC_LO_8BITS_AGC_MAX_MSK		0xff
+
+/*
+ * RK3308_ALC_L_DIG_CON06 - REG: 0x0058 + ch * 0xc0
+ * RK3308_ALC_R_DIG_CON06 - REG: 0x0098 + ch * 0xc0
+ */
+#define RK3308_AGC_HI_8BITS_AGC_MAX_MSK		0xff
+
+/*
+ * RK3308_ALC_L_DIG_CON07 - REG: 0x005c + ch * 0xc0
+ * RK3308_ALC_R_DIG_CON07 - REG: 0x009c + ch * 0xc0
+ */
+#define RK3308_AGC_LO_8BITS_AGC_MIN_MSK		0xff
+
+/*
+ * RK3308_ALC_L_DIG_CON08 - REG: 0x0060 + ch * 0xc0
+ * RK3308_ALC_R_DIG_CON08 - REG: 0x00a0 + ch * 0xc0
+ */
+#define RK3308_AGC_HI_8BITS_AGC_MIN_MSK		0xff
+
+/*
+ * RK3308_ALC_L_DIG_CON09 - REG: 0x0064 + ch * 0xc0
+ * RK3308_ALC_R_DIG_CON09 - REG: 0x00a4 + ch * 0xc0
+ */
+#define RK3308_AGC_FUNC_SEL_MSK			(0x1 << 6)
+#define RK3308_AGC_FUNC_SEL_EN			(0x1 << 6)
+#define RK3308_AGC_FUNC_SEL_DIS			(0x0 << 6)
+#define RK3308_AGC_MAX_GAIN_PGA_MAX		0x7
+#define RK3308_AGC_MAX_GAIN_PGA_MIN		0
+#define RK3308_AGC_MAX_GAIN_PGA_SFT		3
+#define RK3308_AGC_MAX_GAIN_PGA_MSK		(0x7 << RK3308_AGC_MAX_GAIN_PGA_SFT)
+#define RK3308_AGC_MAX_GAIN_PGA_PDB_28_5	(0x7 << RK3308_AGC_MAX_GAIN_PGA_SFT)
+#define RK3308_AGC_MAX_GAIN_PGA_PDB_22_5	(0x6 << RK3308_AGC_MAX_GAIN_PGA_SFT)
+#define RK3308_AGC_MAX_GAIN_PGA_PDB_16_5	(0x5 << RK3308_AGC_MAX_GAIN_PGA_SFT)
+#define RK3308_AGC_MAX_GAIN_PGA_PDB_10_5	(0x4 << RK3308_AGC_MAX_GAIN_PGA_SFT)
+#define RK3308_AGC_MAX_GAIN_PGA_PDB_4_5		(0x3 << RK3308_AGC_MAX_GAIN_PGA_SFT)
+#define RK3308_AGC_MAX_GAIN_PGA_NDB_1_5		(0x2 << RK3308_AGC_MAX_GAIN_PGA_SFT)
+#define RK3308_AGC_MAX_GAIN_PGA_NDB_7_5		(0x1 << RK3308_AGC_MAX_GAIN_PGA_SFT)
+#define RK3308_AGC_MAX_GAIN_PGA_NDB_13_5	(0x0 << RK3308_AGC_MAX_GAIN_PGA_SFT)
+#define RK3308_AGC_MIN_GAIN_PGA_MAX		0x7
+#define RK3308_AGC_MIN_GAIN_PGA_MIN		0
+#define RK3308_AGC_MIN_GAIN_PGA_SFT		0
+#define RK3308_AGC_MIN_GAIN_PGA_MSK		(0x7 << RK3308_AGC_MIN_GAIN_PGA_SFT)
+#define RK3308_AGC_MIN_GAIN_PGA_PDB_24		(0x7 << RK3308_AGC_MIN_GAIN_PGA_SFT)
+#define RK3308_AGC_MIN_GAIN_PGA_PDB_18		(0x6 << RK3308_AGC_MIN_GAIN_PGA_SFT)
+#define RK3308_AGC_MIN_GAIN_PGA_PDB_12		(0x5 << RK3308_AGC_MIN_GAIN_PGA_SFT)
+#define RK3308_AGC_MIN_GAIN_PGA_PDB_6		(0x4 << RK3308_AGC_MIN_GAIN_PGA_SFT)
+#define RK3308_AGC_MIN_GAIN_PGA_0DB		(0x3 << RK3308_AGC_MIN_GAIN_PGA_SFT)
+#define RK3308_AGC_MIN_GAIN_PGA_NDB_6		(0x2 << RK3308_AGC_MIN_GAIN_PGA_SFT)
+#define RK3308_AGC_MIN_GAIN_PGA_NDB_12		(0x1 << RK3308_AGC_MIN_GAIN_PGA_SFT)
+#define RK3308_AGC_MIN_GAIN_PGA_NDB_18		(0x0 << RK3308_AGC_MIN_GAIN_PGA_SFT)
+
+/*
+ * RK3308_ALC_L_DIG_CON12 - REG: 0x0068 + ch * 0xc0
+ * RK3308_ALC_R_DIG_CON12 - REG: 0x00a8 + ch * 0xc0
+ */
+#define RK3308_AGC_GAIN_MSK			0x1f
+
+/* RK3308_DAC_DIG_CON01 - REG: 0x0304 */
+#define RK3308_DAC_I2S_LRC_POL_MSK		(0x1 << 7)
+#define RK3308_DAC_I2S_LRC_POL_REVERSAL		(0x1 << 7)
+#define RK3308_DAC_I2S_LRC_POL_NORMAL		(0x0 << 7)
+#define RK3308_DAC_I2S_VALID_LEN_SFT		5
+#define RK3308_DAC_I2S_VALID_LEN_MSK		(0x3 << RK3308_DAC_I2S_VALID_LEN_SFT)
+#define RK3308_DAC_I2S_VALID_LEN_32BITS		(0x3 << RK3308_DAC_I2S_VALID_LEN_SFT)
+#define RK3308_DAC_I2S_VALID_LEN_24BITS		(0x2 << RK3308_DAC_I2S_VALID_LEN_SFT)
+#define RK3308_DAC_I2S_VALID_LEN_20BITS		(0x1 << RK3308_DAC_I2S_VALID_LEN_SFT)
+#define RK3308_DAC_I2S_VALID_LEN_16BITS		(0x0 << RK3308_DAC_I2S_VALID_LEN_SFT)
+#define RK3308_DAC_I2S_MODE_SFT			3
+#define RK3308_DAC_I2S_MODE_MSK			(0x3 << RK3308_DAC_I2S_MODE_SFT)
+#define RK3308_DAC_I2S_MODE_PCM			(0x3 << RK3308_DAC_I2S_MODE_SFT)
+#define RK3308_DAC_I2S_MODE_I2S			(0x2 << RK3308_DAC_I2S_MODE_SFT)
+#define RK3308_DAC_I2S_MODE_LJ			(0x1 << RK3308_DAC_I2S_MODE_SFT)
+#define RK3308_DAC_I2S_MODE_RJ			(0x0 << RK3308_DAC_I2S_MODE_SFT)
+#define RK3308_DAC_I2S_LR_MSK			(0x1 << 2)
+#define RK3308_DAC_I2S_LR_SWAP			(0x1 << 2)
+#define RK3308_DAC_I2S_LR_NORMAL		(0x0 << 2)
+
+/* RK3308_DAC_DIG_CON02 - REG: 0x0308 */
+#define RK3308_DAC_IO_MODE_MSK			(0x1 << 5)
+#define RK3308_DAC_IO_MODE_MASTER		(0x1 << 5)
+#define RK3308_DAC_IO_MODE_SLAVE		(0x0 << 5)
+#define RK3308_DAC_MODE_MSK			(0x1 << 4)
+#define RK3308_DAC_MODE_MASTER			(0x1 << 4)
+#define RK3308_DAC_MODE_SLAVE			(0x0 << 4)
+#define RK3308_DAC_I2S_FRAME_LEN_SFT		2
+#define RK3308_DAC_I2S_FRAME_LEN_MSK		(0x3 << RK3308_DAC_I2S_FRAME_LEN_SFT)
+#define RK3308_DAC_I2S_FRAME_32BITS		(0x3 << RK3308_DAC_I2S_FRAME_LEN_SFT)
+#define RK3308_DAC_I2S_FRAME_24BITS		(0x2 << RK3308_DAC_I2S_FRAME_LEN_SFT)
+#define RK3308_DAC_I2S_FRAME_20BITS		(0x1 << RK3308_DAC_I2S_FRAME_LEN_SFT)
+#define RK3308_DAC_I2S_FRAME_16BITS		(0x0 << RK3308_DAC_I2S_FRAME_LEN_SFT)
+#define RK3308_DAC_I2S_MSK			(0x1 << 1)
+#define RK3308_DAC_I2S_WORK			(0x1 << 1)
+#define RK3308_DAC_I2S_RESET			(0x0 << 1)
+#define RK3308_DAC_I2S_BIT_CLK_POL_MSK		(0x1 << 0)
+#define RK3308_DAC_I2S_BIT_CLK_POL_REVERSAL	(0x1 << 0)
+#define RK3308_DAC_I2S_BIT_CLK_POL_NORMAL	(0x0 << 0)
+
+/* RK3308_DAC_DIG_CON03 - REG: 0x030C */
+#define RK3308_DAC_L_CH_BIST_SFT		2
+#define RK3308_DAC_L_CH_BIST_MSK		(0x3 << RK3308_DAC_L_CH_BIST_SFT)
+#define RK3308_DAC_L_CH_BIST_LEFT		(0x3 << RK3308_DAC_L_CH_BIST_SFT) /* normal mode */
+#define RK3308_DAC_L_CH_BIST_CUBE		(0x2 << RK3308_DAC_L_CH_BIST_SFT)
+#define RK3308_DAC_L_CH_BIST_SINE		(0x1 << RK3308_DAC_L_CH_BIST_SFT)
+#define RK3308_DAC_L_CH_BIST_RIGHT		(0x0 << RK3308_DAC_L_CH_BIST_SFT) /* normal mode */
+#define RK3308_DAC_R_CH_BIST_SFT		0
+#define RK3308_DAC_R_CH_BIST_MSK		(0x3 << RK3308_DAC_R_CH_BIST_SFT)
+#define RK3308_DAC_R_CH_BIST_LEFT		(0x3 << RK3308_DAC_R_CH_BIST_SFT) /* normal mode */
+#define RK3308_DAC_R_CH_BIST_CUBE		(0x2 << RK3308_DAC_R_CH_BIST_SFT)
+#define RK3308_DAC_R_CH_BIST_SINE		(0x1 << RK3308_DAC_R_CH_BIST_SFT)
+#define RK3308_DAC_R_CH_BIST_RIGHT		(0x0 << RK3308_DAC_R_CH_BIST_SFT) /* normal mode */
+
+/* RK3308_DAC_DIG_CON04 - REG: 0x0310 */
+#define RK3308_DAC_MODULATOR_GAIN_SFT		4
+#define RK3308_DAC_MODULATOR_GAIN_MSK		(0x7 << RK3308_DAC_MODULATOR_GAIN_SFT)
+#define RK3308_DAC_MODULATOR_GAIN_4_8DB		(0x5 << RK3308_DAC_MODULATOR_GAIN_SFT)
+#define RK3308_DAC_MODULATOR_GAIN_4_2DB		(0x4 << RK3308_DAC_MODULATOR_GAIN_SFT)
+#define RK3308_DAC_MODULATOR_GAIN_3_5DB		(0x3 << RK3308_DAC_MODULATOR_GAIN_SFT)
+#define RK3308_DAC_MODULATOR_GAIN_2_8DB		(0x2 << RK3308_DAC_MODULATOR_GAIN_SFT)
+#define RK3308_DAC_MODULATOR_GAIN_2DB		(0x1 << RK3308_DAC_MODULATOR_GAIN_SFT)
+#define RK3308_DAC_MODULATOR_GAIN_0DB		(0x0 << RK3308_DAC_MODULATOR_GAIN_SFT)
+#define RK3308_DAC_CIC_IF_GAIN_SFT		0
+#define RK3308_DAC_CIC_IF_GAIN_MSK		(0x7 << RK3308_DAC_CIC_IF_GAIN_SFT)
+
+/* RK3308_DAC_DIG_CON05 - REG: 0x0314 */
+#define RK3308_DAC_L_REG_CTL_INDATA		(0x1 << 2)
+#define RK3308_DAC_L_NORMAL_DATA		(0x0 << 2)
+#define RK3308_DAC_R_REG_CTL_INDATA		(0x1 << 1)
+#define RK3308_DAC_R_NORMAL_DATA		(0x0 << 1)
+
+/* RK3308_DAC_DIG_CON10 - REG: 0x0328 */
+#define RK3308_DAC_DATA_HI4(x)			(x & 0xf) /* Need to RK3308_DAC_x_REG_CTL_INDATA */
+
+/* RK3308_DAC_DIG_CON11 - REG: 0x032c */
+#define RK3308_DAC_DATA_LO8(x)			(x & 0xff) /* Need to RK3308_DAC_x_REG_CTL_INDATA */
+
+/* RK3308_ADC_ANA_CON00 - REG: 0x0340 */
+#define RK3308_ADC_CH1_CH2_MIC_ALL_MSK		(0xff << 0)
+#define RK3308_ADC_CH1_CH2_MIC_ALL		0xff
+#define RK3308_ADC_CH2_MIC_UNMUTE		(0x1 << 7)
+#define RK3308_ADC_CH2_MIC_MUTE			(0x0 << 7)
+#define RK3308_ADC_CH2_MIC_WORK			(0x1 << 6)
+#define RK3308_ADC_CH2_MIC_INIT			(0x0 << 6)
+#define RK3308_ADC_CH2_MIC_EN			(0x1 << 5)
+#define RK3308_ADC_CH2_MIC_DIS			(0x0 << 5)
+#define RK3308_ADC_CH2_BUF_REF_EN		(0x1 << 4)
+#define RK3308_ADC_CH2_BUF_REF_DIS		(0x0 << 4)
+#define RK3308_ADC_CH1_MIC_UNMUTE		(0x1 << 3)
+#define RK3308_ADC_CH1_MIC_MUTE			(0x0 << 3)
+#define RK3308_ADC_CH1_MIC_WORK			(0x1 << 2)
+#define RK3308_ADC_CH1_MIC_INIT			(0x0 << 2)
+#define RK3308_ADC_CH1_MIC_EN			(0x1 << 1)
+#define RK3308_ADC_CH1_MIC_DIS			(0x0 << 1)
+#define RK3308_ADC_CH1_BUF_REF_EN		(0x1 << 0)
+#define RK3308_ADC_CH1_BUF_REF_DIS		(0x0 << 0)
+
+/* RK3308_ADC_ANA_CON01 - REG: 0x0344
+ *
+ * The PGA of MIC-INs:
+ * 0x0 - MIC1~MIC8 0dB
+ * 0x1 - MIC1~MIC8 6.6dB
+ * 0x2 - MIC1~MIC8 13dB
+ * 0x3 - MIC1~MIC8 20dB
+ */
+#define RK3308_ADC_CH2_MIC_GAIN_MAX		0x3
+#define RK3308_ADC_CH2_MIC_GAIN_MIN		0
+#define RK3308_ADC_CH2_MIC_GAIN_SFT		4
+#define RK3308_ADC_CH2_MIC_GAIN_MSK		(0x3 << RK3308_ADC_CH2_MIC_GAIN_SFT)
+#define RK3308_ADC_CH2_MIC_GAIN_20DB		(0x3 << RK3308_ADC_CH2_MIC_GAIN_SFT)
+#define RK3308_ADC_CH2_MIC_GAIN_13DB		(0x2 << RK3308_ADC_CH2_MIC_GAIN_SFT) /* TRM: only used for version B  */
+#define RK3308_ADC_CH2_MIC_GAIN_6_6DB		(0x1 << RK3308_ADC_CH2_MIC_GAIN_SFT) /* TRM: only used for version B  */
+#define RK3308_ADC_CH2_MIC_GAIN_0DB		(0x0 << RK3308_ADC_CH2_MIC_GAIN_SFT)
+
+#define RK3308_ADC_CH1_MIC_GAIN_MAX		0x3
+#define RK3308_ADC_CH1_MIC_GAIN_MIN		0
+#define RK3308_ADC_CH1_MIC_GAIN_SFT		0
+#define RK3308_ADC_CH1_MIC_GAIN_MSK		(0x3 << RK3308_ADC_CH1_MIC_GAIN_SFT)
+#define RK3308_ADC_CH1_MIC_GAIN_20DB		(0x3 << RK3308_ADC_CH1_MIC_GAIN_SFT)
+#define RK3308_ADC_CH1_MIC_GAIN_13DB		(0x2 << RK3308_ADC_CH1_MIC_GAIN_SFT) /* TRM: only used for version B  */
+#define RK3308_ADC_CH1_MIC_GAIN_6_6DB		(0x1 << RK3308_ADC_CH1_MIC_GAIN_SFT) /* TRM: only used for version B  */
+#define RK3308_ADC_CH1_MIC_GAIN_0DB		(0x0 << RK3308_ADC_CH1_MIC_GAIN_SFT)
+
+/* RK3308_ADC_ANA_CON02 - REG: 0x0348 */
+#define RK3308_ADC_CH2_ALC_ZC_MSK		(0x7 << 4)
+#define RK3308_ADC_CH2_ZEROCROSS_DET_EN		(0x1 << 6)
+#define RK3308_ADC_CH2_ZEROCROSS_DET_DIS	(0x0 << 6)
+#define RK3308_ADC_CH2_ALC_WORK			(0x1 << 5)
+#define RK3308_ADC_CH2_ALC_INIT			(0x0 << 5)
+#define RK3308_ADC_CH2_ALC_EN			(0x1 << 4)
+#define RK3308_ADC_CH2_ALC_DIS			(0x0 << 4)
+
+#define RK3308_ADC_CH1_ALC_ZC_MSK		(0x7 << 0)
+#define RK3308_ADC_CH1_ZEROCROSS_DET_EN		(0x1 << 2)
+#define RK3308_ADC_CH1_ZEROCROSS_DET_DIS	(0x0 << 2)
+#define RK3308_ADC_CH1_ALC_WORK			(0x1 << 1)
+#define RK3308_ADC_CH1_ALC_INIT			(0x0 << 1)
+#define RK3308_ADC_CH1_ALC_EN			(0x1 << 0)
+#define RK3308_ADC_CH1_ALC_DIS			(0x0 << 0)
+
+/* RK3308_ADC_ANA_CON03 - REG: 0x034c */
+#define RK3308_ADC_CH1_ALC_GAIN_MAX		0x1f
+#define RK3308_ADC_CH1_ALC_GAIN_MIN		0
+#define RK3308_ADC_CH1_ALC_GAIN_SFT		0
+#define RK3308_ADC_CH1_ALC_GAIN_MSK		(0x1f << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_PDB_28_5	(0x1f << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_PDB_27		(0x1e << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_PDB_25_5	(0x1d << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_PDB_24		(0x1c << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_PDB_22_5	(0x1b << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_PDB_21		(0x1a << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_PDB_19_5	(0x19 << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_PDB_18		(0x18 << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_PDB_16_5	(0x17 << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_PDB_15		(0x16 << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_PDB_13_5	(0x15 << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_PDB_12		(0x14 << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_PDB_10_5	(0x13 << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_PDB_9		(0x12 << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_PDB_7_5		(0x11 << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_PDB_6		(0x10 << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_PDB_4_5		(0x0f << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_PDB_3		(0x0e << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_PDB_1_5		(0x0d << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_0DB		(0x0c << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_NDB_1_5		(0x0b << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_NDB_3		(0x0a << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_NDB_4_5		(0x09 << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_NDB_6		(0x08 << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_NDB_7_5		(0x07 << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_NDB_9		(0x06 << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_NDB_10_5	(0x05 << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_NDB_12		(0x04 << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_NDB_13_5	(0x03 << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_NDB_15		(0x02 << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_NDB_16_5	(0x01 << RK3308_ADC_CH1_ALC_GAIN_SFT)
+#define RK3308_ADC_CH1_ALC_GAIN_NDB_18		(0x00 << RK3308_ADC_CH1_ALC_GAIN_SFT)
+
+/* RK3308_ADC_ANA_CON04 - REG: 0x0350 */
+#define RK3308_ADC_CH2_ALC_GAIN_MAX		0x1f
+#define RK3308_ADC_CH2_ALC_GAIN_MIN		0
+#define RK3308_ADC_CH2_ALC_GAIN_SFT		0
+#define RK3308_ADC_CH2_ALC_GAIN_MSK		(0x1f << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_PDB_28_5	(0x1f << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_PDB_27		(0x1e << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_PDB_25_5	(0x1d << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_PDB_24		(0x1c << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_PDB_22_5	(0x1b << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_PDB_21		(0x1a << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_PDB_19_5	(0x19 << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_PDB_18		(0x18 << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_PDB_16_5	(0x17 << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_PDB_15		(0x16 << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_PDB_13_5	(0x15 << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_PDB_12		(0x14 << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_PDB_10_5	(0x13 << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_PDB_9		(0x12 << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_PDB_7_5		(0x11 << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_PDB_6		(0x10 << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_PDB_4_5		(0x0f << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_PDB_3		(0x0e << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_PDB_1_5		(0x0d << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_0DB		(0x0c << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_NDB_1_5		(0x0b << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_NDB_3		(0x0a << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_NDB_4_5		(0x09 << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_NDB_6		(0x08 << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_NDB_7_5		(0x07 << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_NDB_9		(0x06 << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_NDB_10_5	(0x05 << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_NDB_12		(0x04 << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_NDB_13_5	(0x03 << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_NDB_15		(0x02 << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_NDB_16_5	(0x01 << RK3308_ADC_CH2_ALC_GAIN_SFT)
+#define RK3308_ADC_CH2_ALC_GAIN_NDB_18		(0x00 << RK3308_ADC_CH2_ALC_GAIN_SFT)
+
+/* RK3308_ADC_ANA_CON05 - REG: 0x0354 */
+#define RK3308_ADC_CH2_ADC_CLK_MSK		(0x7 << 4)
+#define RK3308_ADC_CH2_ADC_WORK			(0x1 << 6)
+#define RK3308_ADC_CH2_ADC_INIT			(0x0 << 6)
+#define RK3308_ADC_CH2_ADC_EN			(0x1 << 5)
+#define RK3308_ADC_CH2_ADC_DIS			(0x0 << 5)
+#define RK3308_ADC_CH2_CLK_EN			(0x1 << 4)
+#define RK3308_ADC_CH2_CLK_DIS			(0x0 << 4)
+
+#define RK3308_ADC_CH1_ADC_CLK_MSK		(0x7 << 0)
+#define RK3308_ADC_CH1_ADC_WORK			(0x1 << 2)
+#define RK3308_ADC_CH1_ADC_INIT			(0x0 << 2)
+#define RK3308_ADC_CH1_ADC_EN			(0x1 << 1)
+#define RK3308_ADC_CH1_ADC_DIS			(0x0 << 1)
+#define RK3308_ADC_CH1_CLK_EN			(0x1 << 0)
+#define RK3308_ADC_CH1_CLK_DIS			(0x0 << 0)
+
+/* RK3308_ADC_ANA_CON06 - REG: 0x0358 */
+#define RK3308_ADC_CURRENT_MSK			(0x1 << 0)
+#define RK3308_ADC_CURRENT_EN			(0x1 << 0)
+#define RK3308_ADC_CURRENT_DIS			(0x0 << 0)
+
+/* RK3308_ADC_ANA_CON07 - REG: 0x035c */
+/* Note: The register configuration is only valid for ADC2 */
+#define RK3308_ADC_CH2_IN_SEL_SFT		6
+#define RK3308_ADC_CH2_IN_SEL_MSK		(0x3 << RK3308_ADC_CH2_IN_SEL_SFT)
+#define RK3308_ADC_CH2_IN_LINEIN_MIC		(0x3 << RK3308_ADC_CH2_IN_SEL_SFT)
+#define RK3308_ADC_CH2_IN_LINEIN		(0x2 << RK3308_ADC_CH2_IN_SEL_SFT)
+#define RK3308_ADC_CH2_IN_MIC			(0x1 << RK3308_ADC_CH2_IN_SEL_SFT)
+#define RK3308_ADC_CH2_IN_NONE			(0x0 << RK3308_ADC_CH2_IN_SEL_SFT)
+/* Note: The register configuration is only valid for ADC1 */
+#define RK3308_ADC_CH1_IN_SEL_SFT		4
+#define RK3308_ADC_CH1_IN_SEL_MSK		(0x3 << RK3308_ADC_CH1_IN_SEL_SFT)
+#define RK3308_ADC_CH1_IN_LINEIN_MIC		(0x3 << RK3308_ADC_CH1_IN_SEL_SFT)
+#define RK3308_ADC_CH1_IN_LINEIN		(0x2 << RK3308_ADC_CH1_IN_SEL_SFT)
+#define RK3308_ADC_CH1_IN_MIC			(0x1 << RK3308_ADC_CH1_IN_SEL_SFT)
+#define RK3308_ADC_CH1_IN_NONE			(0x0 << RK3308_ADC_CH1_IN_SEL_SFT)
+
+#define RK3308_ADC_MIC_BIAS_BUF_SFT		3
+#define RK3308_ADC_MIC_BIAS_BUF_EN		(0x1 << RK3308_ADC_MIC_BIAS_BUF_SFT)
+#define RK3308_ADC_MIC_BIAS_BUF_DIS		(0x0 << RK3308_ADC_MIC_BIAS_BUF_SFT)
+#define RK3308_ADC_LEVEL_RANGE_MICBIAS_SFT	0
+#define RK3308_ADC_LEVEL_RANGE_MICBIAS_MSK	(0x7 << RK3308_ADC_LEVEL_RANGE_MICBIAS_SFT)
+/*
+ * The follow MICBIAS_VOLTs are based on the external reference voltage(Vref).
+ * For example, the Vref == 3.3V, the MICBIAS_VOLT_0_85 is equal:
+ * 3.3V * 0.85 = 2.805V.
+ */
+#define RK3308_ADC_MICBIAS_VOLT_0_85		(0x7 << RK3308_ADC_LEVEL_RANGE_MICBIAS_SFT)
+#define RK3308_ADC_MICBIAS_VOLT_0_8		(0x6 << RK3308_ADC_LEVEL_RANGE_MICBIAS_SFT)
+#define RK3308_ADC_MICBIAS_VOLT_0_75		(0x5 << RK3308_ADC_LEVEL_RANGE_MICBIAS_SFT)
+#define RK3308_ADC_MICBIAS_VOLT_0_7		(0x4 << RK3308_ADC_LEVEL_RANGE_MICBIAS_SFT)
+#define RK3308_ADC_MICBIAS_VOLT_0_65		(0x3 << RK3308_ADC_LEVEL_RANGE_MICBIAS_SFT)
+#define RK3308_ADC_MICBIAS_VOLT_0_6		(0x2 << RK3308_ADC_LEVEL_RANGE_MICBIAS_SFT)
+#define RK3308_ADC_MICBIAS_VOLT_0_55		(0x1 << RK3308_ADC_LEVEL_RANGE_MICBIAS_SFT)
+#define RK3308_ADC_MICBIAS_VOLT_0_5		(0x0 << RK3308_ADC_LEVEL_RANGE_MICBIAS_SFT)
+
+/* RK3308_ADC_ANA_CON08 - REG: 0x0360 */
+#define RK3308_ADC_MICBIAS_CURRENT_MSK		(0x1 << 4)
+#define RK3308_ADC_MICBIAS_CURRENT_EN		(0x1 << 4)
+#define RK3308_ADC_MICBIAS_CURRENT_DIS		(0x0 << 4)
+
+/* RK3308_ADC_ANA_CON10 - REG: 0x0368 */
+#define RK3308_ADC_REF_EN			(0x1 << 7)
+#define RK3308_ADC_REF_DIS			(0x0 << 7)
+#define RK3308_ADC_CURRENT_CHARGE_SFT		0
+#define RK3308_ADC_CURRENT_CHARGE_MSK		(0x7f << RK3308_ADC_CURRENT_CHARGE_SFT)
+#define RK3308_ADC_DONT_SEL_ALL			(0x7f << RK3308_ADC_CURRENT_CHARGE_SFT)
+/*
+ * 1: Choose the current I
+ * 0: Don't choose the current I
+ */
+#define RK3308_ADC_SEL_I(x)			(x & 0x7f)
+
+/* RK3308_ADC_ANA_CON11 - REG: 0x036c */
+#define RK3308_ADC_ALCR_CON_GAIN_PGAR_MSK	(0x1 << 1)
+#define RK3308_ADC_ALCR_CON_GAIN_PGAR_EN	(0x1 << 1)
+#define RK3308_ADC_ALCR_CON_GAIN_PGAR_DIS	(0x0 << 1)
+#define RK3308_ADC_ALCL_CON_GAIN_PGAL_MSK	(0x1 << 0)
+#define RK3308_ADC_ALCL_CON_GAIN_PGAL_EN	(0x1 << 0)
+#define RK3308_ADC_ALCL_CON_GAIN_PGAL_DIS	(0x0 << 0)
+
+/* RK3308_DAC_ANA_CON00 - REG: 0x0440 */
+#define RK3308_DAC_HEADPHONE_DET_MSK		(0x1 << 1)
+#define RK3308_DAC_HEADPHONE_DET_EN		(0x1 << 1)
+#define RK3308_DAC_HEADPHONE_DET_DIS		(0x0 << 1)
+#define RK3308_DAC_CURRENT_MSK			(0x1 << 0)
+#define RK3308_DAC_CURRENT_EN			(0x1 << 0)
+#define RK3308_DAC_CURRENT_DIS			(0x0 << 0)
+
+/* RK3308_DAC_ANA_CON01 - REG: 0x0444 */
+#define RK3308_DAC_BUF_REF_R_MSK		(0x1 << 6)
+#define RK3308_DAC_BUF_REF_R_EN			(0x1 << 6)
+#define RK3308_DAC_BUF_REF_R_DIS		(0x0 << 6)
+#define RK3308_DAC_HPOUT_POP_SOUND_R_SFT	4
+#define RK3308_DAC_HPOUT_POP_SOUND_R_MSK	(0x3 << RK3308_DAC_HPOUT_POP_SOUND_R_SFT)
+#define RK3308_DAC_HPOUT_POP_SOUND_R_WORK	(0x2 << RK3308_DAC_HPOUT_POP_SOUND_R_SFT)
+#define RK3308_DAC_HPOUT_POP_SOUND_R_INIT	(0x1 << RK3308_DAC_HPOUT_POP_SOUND_R_SFT)
+#define RK3308_DAC_BUF_REF_L_MSK		(0x1 << 2)
+#define RK3308_DAC_BUF_REF_L_EN			(0x1 << 2)
+#define RK3308_DAC_BUF_REF_L_DIS		(0x0 << 2)
+#define RK3308_DAC_HPOUT_POP_SOUND_L_SFT	0
+#define RK3308_DAC_HPOUT_POP_SOUND_L_MSK	(0x3 << RK3308_DAC_HPOUT_POP_SOUND_L_SFT)
+#define RK3308_DAC_HPOUT_POP_SOUND_L_WORK	(0x2 << RK3308_DAC_HPOUT_POP_SOUND_L_SFT)
+#define RK3308_DAC_HPOUT_POP_SOUND_L_INIT	(0x1 << RK3308_DAC_HPOUT_POP_SOUND_L_SFT)
+
+/* RK3308_DAC_ANA_CON02 - REG: 0x0448 */
+#define RK3308_DAC_R_DAC_WORK			(0x1 << 7)
+#define RK3308_DAC_R_DAC_INIT			(0x0 << 7)
+#define RK3308_DAC_R_DAC_EN			(0x1 << 6)
+#define RK3308_DAC_R_DAC_DIS			(0x0 << 6)
+#define RK3308_DAC_R_CLK_EN			(0x1 << 5)
+#define RK3308_DAC_R_CLK_DIS			(0x0 << 5)
+#define RK3308_DAC_R_REF_EN			(0x1 << 4)
+#define RK3308_DAC_R_REF_DIS			(0x0 << 4)
+#define RK3308_DAC_L_DAC_WORK			(0x1 << 3)
+#define RK3308_DAC_L_DAC_INIT			(0x0 << 3)
+#define RK3308_DAC_L_DAC_EN			(0x1 << 2)
+#define RK3308_DAC_L_DAC_DIS			(0x0 << 2)
+#define RK3308_DAC_L_CLK_EN			(0x1 << 1)
+#define RK3308_DAC_L_CLK_DIS			(0x0 << 1)
+#define RK3308_DAC_L_REF_EN			(0x1 << 0)
+#define RK3308_DAC_L_REF_DIS			(0x0 << 0)
+
+/* RK3308_DAC_ANA_CON03 - REG: 0x044c */
+#define RK3308_DAC_R_HPOUT_WORK			(0x1 << 6)
+#define RK3308_DAC_R_HPOUT_INIT			(0x0 << 6)
+#define RK3308_DAC_R_HPOUT_EN			(0x1 << 5)
+#define RK3308_DAC_R_HPOUT_DIS			(0x0 << 5)
+#define RK3308_DAC_R_HPOUT_UNMUTE		(0x1 << 4)
+#define RK3308_DAC_R_HPOUT_MUTE			(0x0 << 4)
+#define RK3308_DAC_L_HPOUT_WORK			(0x1 << 2)
+#define RK3308_DAC_L_HPOUT_INIT			(0x0 << 2)
+#define RK3308_DAC_L_HPOUT_EN			(0x1 << 1)
+#define RK3308_DAC_L_HPOUT_DIS			(0x0 << 1)
+#define RK3308_DAC_L_HPOUT_UNMUTE		(0x1 << 0)
+#define RK3308_DAC_L_HPOUT_MUTE			(0x0 << 0)
+
+/* RK3308_DAC_ANA_CON04 - REG: 0x0450 */
+#define RK3308_DAC_R_LINEOUT_GAIN_MAX		0x3
+#define RK3308_DAC_R_LINEOUT_GAIN_SFT		6
+#define RK3308_DAC_R_LINEOUT_GAIN_MSK		(0x3 << RK3308_DAC_R_LINEOUT_GAIN_SFT)
+#define RK3308_DAC_R_LINEOUT_GAIN_0DB		(0x3 << RK3308_DAC_R_LINEOUT_GAIN_SFT)
+#define RK3308_DAC_R_LINEOUT_GAIN_NDB_1_5	(0x2 << RK3308_DAC_R_LINEOUT_GAIN_SFT)
+#define RK3308_DAC_R_LINEOUT_GAIN_NDB_3		(0x1 << RK3308_DAC_R_LINEOUT_GAIN_SFT)
+#define RK3308_DAC_R_LINEOUT_GAIN_NDB_6		(0x0 << RK3308_DAC_R_LINEOUT_GAIN_SFT)
+#define RK3308_DAC_R_LINEOUT_UNMUTE		(0x1 << 5)
+#define RK3308_DAC_R_LINEOUT_MUTE		(0x0 << 5)
+#define RK3308_DAC_R_LINEOUT_EN			(0x1 << 4)
+#define RK3308_DAC_R_LINEOUT_DIS		(0x0 << 4)
+#define RK3308_DAC_L_LINEOUT_GAIN_MAX		0x3
+#define RK3308_DAC_L_LINEOUT_GAIN_SFT		2
+#define RK3308_DAC_L_LINEOUT_GAIN_MSK		(0x3 << RK3308_DAC_L_LINEOUT_GAIN_SFT)
+#define RK3308_DAC_L_LINEOUT_GAIN_0DB		(0x3 << RK3308_DAC_L_LINEOUT_GAIN_SFT)
+#define RK3308_DAC_L_LINEOUT_GAIN_NDB_1_5	(0x2 << RK3308_DAC_L_LINEOUT_GAIN_SFT)
+#define RK3308_DAC_L_LINEOUT_GAIN_NDB_3		(0x1 << RK3308_DAC_L_LINEOUT_GAIN_SFT)
+#define RK3308_DAC_L_LINEOUT_GAIN_NDB_6		(0x0 << RK3308_DAC_L_LINEOUT_GAIN_SFT)
+#define RK3308_DAC_L_LINEOUT_UNMUTE		(0x1 << 1)
+#define RK3308_DAC_L_LINEOUT_MUTE		(0x0 << 1)
+#define RK3308_DAC_L_LINEOUT_EN			(0x1 << 0)
+#define RK3308_DAC_L_LINEOUT_DIS		(0x0 << 0)
+
+/* RK3308_DAC_ANA_CON05 - REG: 0x0454, step is 1.5db */
+#define RK3308_DAC_L_HPOUT_GAIN_MAX		0x1e
+#define RK3308_DAC_L_HPOUT_GAIN_SFT		0
+#define RK3308_DAC_L_HPOUT_GAIN_MSK		(0x1f << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_PDB_6		(0x1e << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_PDB_4_5		(0x1d << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_PDB_3		(0x1c << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_PDB_1_5		(0x1b << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_0DB		(0x1a << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_1_5		(0x19 << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_3		(0x18 << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_4_5		(0x17 << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_6		(0x16 << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_7_5		(0x15 << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_9		(0x14 << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_10_5	(0x13 << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_12		(0x12 << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_13_5	(0x11 << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_15		(0x10 << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_16_5	(0x0f << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_18		(0x0e << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_19_5	(0x0d << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_21		(0x0c << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_22_5	(0x0b << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_24		(0x0a << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_25_5	(0x09 << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_27		(0x08 << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_28_5	(0x07 << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_30		(0x06 << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_31_5	(0x05 << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_33		(0x04 << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_34_5	(0x03 << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_36		(0x02 << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_37_5	(0x01 << RK3308_DAC_L_HPOUT_GAIN_SFT)
+#define RK3308_DAC_L_HPOUT_GAIN_NDB_39		(0x00 << RK3308_DAC_L_HPOUT_GAIN_SFT)
+
+/* RK3308_DAC_ANA_CON06 - REG: 0x0458, step is 1.5db */
+#define RK3308_DAC_R_HPOUT_GAIN_MAX		0x1e
+#define RK3308_DAC_R_HPOUT_GAIN_SFT		0
+#define RK3308_DAC_R_HPOUT_GAIN_MSK		(0x1f << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_PDB_6		(0x1e << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_PDB_4_5		(0x1d << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_PDB_3		(0x1c << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_PDB_1_5		(0x1b << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_0DB		(0x1a << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_1_5		(0x19 << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_3		(0x18 << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_4_5		(0x17 << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_6		(0x16 << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_7_5		(0x15 << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_9		(0x14 << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_10_5	(0x13 << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_12		(0x12 << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_13_5	(0x11 << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_15		(0x10 << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_16_5	(0x0f << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_18		(0x0e << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_19_5	(0x0d << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_21		(0x0c << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_22_5	(0x0b << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_24		(0x0a << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_25_5	(0x09 << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_27		(0x08 << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_28_5	(0x07 << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_30		(0x06 << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_31_5	(0x05 << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_33		(0x04 << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_34_5	(0x03 << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_36		(0x02 << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_37_5	(0x01 << RK3308_DAC_R_HPOUT_GAIN_SFT)
+#define RK3308_DAC_R_HPOUT_GAIN_NDB_39		(0x00 << RK3308_DAC_R_HPOUT_GAIN_SFT)
+
+/* RK3308_DAC_ANA_CON07 - REG: 0x045c */
+#define RK3308_DAC_R_HPOUT_DRV_SFT		4
+#define RK3308_DAC_R_HPOUT_DRV_MSK		(0xf << RK3308_DAC_R_HPOUT_DRV_SFT)
+#define RK3308_DAC_L_HPOUT_DRV_SFT		0
+#define RK3308_DAC_L_HPOUT_DRV_MSK		(0xf << RK3308_DAC_L_HPOUT_DRV_SFT)
+
+/* RK3308_DAC_ANA_CON08 - REG: 0x0460 */
+#define RK3308_DAC_R_LINEOUT_DRV_SFT		4
+#define RK3308_DAC_R_LINEOUT_DRV_MSK		(0xf << RK3308_DAC_R_LINEOUT_DRV_SFT)
+#define RK3308_DAC_L_LINEOUT_DRV_SFT		0
+#define RK3308_DAC_L_LINEOUT_DRV_MSK		(0xf << RK3308_DAC_L_LINEOUT_DRV_SFT)
+
+/* RK3308_DAC_ANA_CON12 - REG: 0x0470 */
+#define RK3308_DAC_R_HPMIX_SEL_SFT		6
+#define RK3308_DAC_R_HPMIX_SEL_MSK		(0x3 << RK3308_DAC_R_HPMIX_SEL_SFT)
+#define RK3308_DAC_R_HPMIX_LINEIN_I2S		(0x3 << RK3308_DAC_R_HPMIX_SEL_SFT)
+#define RK3308_DAC_R_HPMIX_LINEIN		(0x2 << RK3308_DAC_R_HPMIX_SEL_SFT)
+#define RK3308_DAC_R_HPMIX_I2S			(0x1 << RK3308_DAC_R_HPMIX_SEL_SFT)
+#define RK3308_DAC_R_HPMIX_NONE			(0x0 << RK3308_DAC_R_HPMIX_SEL_SFT)
+#define RK3308_DAC_R_HPMIX_GAIN_MIN		0x1
+#define RK3308_DAC_R_HPMIX_GAIN_MAX		0x2
+#define RK3308_DAC_R_HPMIX_GAIN_SFT		4
+#define RK3308_DAC_R_HPMIX_GAIN_MSK		(0x3 << RK3308_DAC_R_HPMIX_GAIN_SFT)
+#define RK3308_DAC_R_HPMIX_GAIN_0DB		(0x2 << RK3308_DAC_R_HPMIX_GAIN_SFT)
+#define RK3308_DAC_R_HPMIX_GAIN_NDB_6		(0x1 << RK3308_DAC_R_HPMIX_GAIN_SFT)
+#define RK3308_DAC_L_HPMIX_SEL_SFT		2
+#define RK3308_DAC_L_HPMIX_SEL_MSK		(0x3 << RK3308_DAC_L_HPMIX_SEL_SFT)
+#define RK3308_DAC_L_HPMIX_LINEIN_I2S		(0x3 << RK3308_DAC_L_HPMIX_SEL_SFT)
+#define RK3308_DAC_L_HPMIX_LINEIN		(0x2 << RK3308_DAC_L_HPMIX_SEL_SFT)
+#define RK3308_DAC_L_HPMIX_I2S			(0x1 << RK3308_DAC_L_HPMIX_SEL_SFT)
+#define RK3308_DAC_L_HPMIX_NONE			(0x0 << RK3308_DAC_L_HPMIX_SEL_SFT)
+#define RK3308_DAC_L_HPMIX_GAIN_MIN		0x1
+#define RK3308_DAC_L_HPMIX_GAIN_MAX		0x2
+#define RK3308_DAC_L_HPMIX_GAIN_SFT		0
+#define RK3308_DAC_L_HPMIX_GAIN_MSK		(0x3 << RK3308_DAC_L_HPMIX_GAIN_SFT)
+#define RK3308_DAC_L_HPMIX_GAIN_0DB		(0x2 << RK3308_DAC_L_HPMIX_GAIN_SFT)
+#define RK3308_DAC_L_HPMIX_GAIN_NDB_6		(0x1 << RK3308_DAC_L_HPMIX_GAIN_SFT)
+
+/* RK3308_DAC_ANA_CON13 - REG: 0x0474 */
+#define RK3308_DAC_R_HPMIX_UNMUTE		(0x1 << 6)
+#define RK3308_DAC_R_HPMIX_MUTE			(0x0 << 6)
+#define RK3308_DAC_R_HPMIX_WORK			(0x1 << 5)
+#define RK3308_DAC_R_HPMIX_INIT			(0x0 << 5)
+#define RK3308_DAC_R_HPMIX_EN			(0x1 << 4)
+#define RK3308_DAC_R_HPMIX_DIS			(0x0 << 4)
+#define RK3308_DAC_L_HPMIX_UNMUTE		(0x1 << 2)
+#define RK3308_DAC_L_HPMIX_MUTE			(0x0 << 2)
+#define RK3308_DAC_L_HPMIX_WORK			(0x1 << 1)
+#define RK3308_DAC_L_HPMIX_INIT			(0x0 << 1)
+#define RK3308_DAC_L_HPMIX_EN			(0x1 << 0)
+#define RK3308_DAC_L_HPMIX_DIS			(0x0 << 0)
+
+/* RK3308_DAC_ANA_CON14 - REG: 0x0478 */
+#define RK3308_DAC_VCM_LINEOUT_EN		(0x1 << 4)
+#define RK3308_DAC_VCM_LINEOUT_DIS		(0x0 << 4)
+#define RK3308_DAC_CURRENT_CHARGE_SFT		0
+#define RK3308_DAC_CURRENT_CHARGE_MSK		(0xf << RK3308_DAC_CURRENT_CHARGE_SFT)
+
+/*
+ * 1: Choose the current I
+ * 0: Don't choose the current I
+ */
+#define RK3308_DAC_SEL_I(x)			(x & 0xf)
+
+/* RK3308_DAC_ANA_CON15 - REG: 0x047C */
+#define RK3308_DAC_LINEOUT_POP_SOUND_R_SFT	4
+#define RK3308_DAC_LINEOUT_POP_SOUND_R_MSK	(0x3 << RK3308_DAC_LINEOUT_POP_SOUND_R_SFT)
+#define RK3308_DAC_R_SEL_DC_FROM_INTERNAL	(0x2 << RK3308_DAC_LINEOUT_POP_SOUND_R_SFT)
+#define RK3308_DAC_R_SEL_DC_FROM_VCM		(0x1 << RK3308_DAC_LINEOUT_POP_SOUND_R_SFT)
+#define RK3308_DAC_R_SEL_LINEOUT_FROM_INTERNAL	(0x0 << RK3308_DAC_LINEOUT_POP_SOUND_R_SFT)
+#define RK3308_DAC_LINEOUT_POP_SOUND_L_SFT	0
+#define RK3308_DAC_LINEOUT_POP_SOUND_L_MSK	(0x3 << RK3308_DAC_LINEOUT_POP_SOUND_L_SFT)
+#define RK3308_DAC_L_SEL_DC_FROM_INTERNAL	(0x2 << RK3308_DAC_LINEOUT_POP_SOUND_L_SFT)
+#define RK3308_DAC_L_SEL_DC_FROM_VCM		(0x1 << RK3308_DAC_LINEOUT_POP_SOUND_L_SFT)
+#define RK3308_DAC_L_SEL_LINEOUT_FROM_INTERNAL	(0x0 << RK3308_DAC_LINEOUT_POP_SOUND_L_SFT)
+
+#define RK3308_HIFI				0x0
+
+#endif /* __RK3308_CODEC_H__ */
Index: linux-5.10.27/sound/soc/codecs/rk3308_codec_provider.h
===================================================================
--- /dev/null
+++ linux-5.10.27/sound/soc/codecs/rk3308_codec_provider.h
@@ -0,0 +1,33 @@
+/*
+ * rk3308_codec_provider.h -- RK3308 ALSA Soc Audio Driver
+ *
+ * Copyright (c) 2018, Fuzhou Rockchip Electronics Co., Ltd All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef __RK3308_CODEC_PROVIDER_H__
+#define __RK3308_CODEC_PROVIDER_H__
+
+#ifdef CONFIG_SND_SOC_RK3308
+void rk3308_codec_set_jack_detect(struct snd_soc_component *component,
+				  struct snd_soc_jack *hpdet_jack);
+#else
+inline void rk3308_codec_set_jack_detect(struct snd_soc_component *component,
+						struct snd_soc_jack *hpdet_jack)
+{
+}
+#endif
+
+#endif /* __RK3308_CODEC_PROVIDER_H__ */
Index: linux-5.10.27/arch/arm64/boot/dts/rockchip/rk3308.dtsi
===================================================================
--- linux-5.10.27.orig/arch/arm64/boot/dts/rockchip/rk3308.dtsi
+++ linux-5.10.27/arch/arm64/boot/dts/rockchip/rk3308.dtsi
@@ -104,6 +104,18 @@
 		compatible = "operating-points-v2";
 		opp-shared;
 
+		rockchip,temp-hysteresis = <5000>;
+		rockchip,low-temp = <0>;
+		rockchip,low-temp-min-volt = <1000000>;
+		rockchip,max-volt = <1340000>;
+		rockchip,low-temp-adjust-volt = <
+			/* MHz    MHz    uV */
+			   0      1296   50000
+		>;
+
+		rockchip,evb-irdrop = <25000>;
+		rockchip,thermal-zone = "soc-thermal";
+
 		opp-408000000 {
 			opp-hz = /bits/ 64 <408000000>;
 			opp-microvolt = <950000 950000 1340000>;
@@ -125,6 +137,16 @@
 			opp-microvolt = <1125000 1125000 1340000>;
 			clock-latency-ns = <40000>;
 		};
+		opp-1200000000 {
+			opp-hz = /bits/ 64 <1200000000>;
+			opp-microvolt = <1250000 1250000 1340000>;
+			clock-latency-ns = <40000>;
+		};
+		opp-1296000000 {
+			opp-hz = /bits/ 64 <1296000000>;
+			opp-microvolt = <1300000 1300000 1340000>;
+			clock-latency-ns = <40000>;
+		};
 	};
 
 	arm-pmu {
@@ -539,6 +561,15 @@
 		clock-names = "pclk", "timer";
 	};
 
+	rk_timer_rtc: rk-timer-rtc@ff1a0020 {
+		compatible = "rockchip,rk3308-timer-rtc";
+		reg = <0x0 0xff1a0020 0x0 0x20>;
+		interrupts = <GIC_SPI 26 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru PCLK_TIMER>, <&cru SCLK_TIMER1>;
+		clock-names = "pclk", "timer";
+		status = "disabled";
+	};
+
 	saradc: saradc@ff1e0000 {
 		compatible = "rockchip,rk3308-saradc", "rockchip,rk3399-saradc";
 		reg = <0x0 0xff1e0000 0x0 0x100>;
@@ -551,6 +582,70 @@
 		status = "disabled";
 	};
 
+	thermal_zones: thermal-zones {
+		soc_thermal: soc-thermal {
+			polling-delay-passive = <20>;
+			polling-delay = <1000>;
+			sustainable-power = <300>;
+
+			thermal-sensors = <&tsadc 1>;
+
+			trips {
+				threshold: trip-point-0 {
+					temperature = <70000>;
+					hysteresis = <2000>;
+					type = "passive";
+				};
+				target: trip-point-1 {
+					temperature = <85000>;
+					hysteresis = <2000>;
+					type = "passive";
+				};
+				soc_crit: soc-crit {
+					temperature = <115000>;
+					hysteresis = <2000>;
+					type = "critical";
+				};
+			};
+
+			cooling-maps {
+				map0 {
+					trip = <&target>;
+					cooling-device = <&cpu0 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
+					contribution = <4096>;
+				};
+			};
+
+		};
+
+		logic_thermal: logic-thermal {
+			polling-delay-passive = <100>; /* milliseconds */
+			polling-delay = <1000>; /* milliseconds */
+
+			thermal-sensors = <&tsadc 0>;
+		};
+	};
+
+	tsadc: tsadc@ff1f0000 {
+		compatible = "rockchip,rk3308-tsadc";
+		reg = <0x0 0xff1f0000 0x0 0x100>;
+		interrupts = <GIC_SPI 38 IRQ_TYPE_LEVEL_HIGH>;
+		rockchip,grf = <&grf>;
+		clocks = <&cru SCLK_TSADC>, <&cru PCLK_TSADC>;
+		clock-names = "tsadc", "apb_pclk";
+		assigned-clocks = <&cru SCLK_TSADC>;
+		assigned-clock-rates = <50000>;
+		resets = <&cru SRST_TSADC>;
+		reset-names = "tsadc-apb";
+		pinctrl-names = "init", "default", "sleep";
+		pinctrl-0 = <&tsadc_otp_pin>;
+		pinctrl-1 = <&tsadc_otp_pin>;
+		pinctrl-2 = <&tsadc_otp_pin>;
+		#thermal-sensor-cells = <1>;
+		rockchip,hw-tshut-temp = <120000>;
+		status = "disabled";
+	};
+
 	amba: bus {
 		compatible = "simple-bus";
 		#address-cells = <2>;
@@ -580,6 +675,124 @@
 		};
 	};
 
+	rng: rng@ff2f0000 {
+		compatible = "rockchip,cryptov2-rng";
+		reg = <0x0 0xff2f0000 0x0 0x4000>;
+		clocks = <&cru SCLK_CRYPTO>, <&cru SCLK_CRYPTO_APK>,
+			<&cru ACLK_CRYPTO>, <&cru HCLK_CRYPTO>;
+		clock-names = "clk_crypto", "clk_crypto_apk",
+				"aclk_crypto", "hclk_crypto";
+		assigned-clocks = <&cru SCLK_CRYPTO>, <&cru SCLK_CRYPTO_APK>,
+					<&cru ACLK_CRYPTO>, <&cru HCLK_CRYPTO>;
+		assigned-clock-rates = <150000000>, <150000000>,
+					<200000000>, <100000000>;
+		resets = <&cru SRST_CRYPTO>;
+		reset-names = "reset";
+		status = "disabled";
+	};
+
+	i2s_8ch_0: i2s@ff300000 {
+		compatible = "rockchip,rk3308-i2s-tdm";
+		reg = <0x0 0xff300000 0x0 0x1000>;
+		interrupts = <GIC_SPI 48 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru SCLK_I2S0_8CH_TX>, <&cru SCLK_I2S0_8CH_RX>, <&cru HCLK_I2S0_8CH>,
+			 <&cru SCLK_I2S0_8CH_TX_SRC>,
+			 <&cru SCLK_I2S0_8CH_RX_SRC>,
+			 <&cru PLL_VPLL0>,
+			 <&cru PLL_VPLL1>;
+		clock-names = "mclk_tx", "mclk_rx", "hclk",
+			      "mclk_tx_src", "mclk_rx_src",
+			      "mclk_root0", "mclk_root1";
+		dmas = <&dmac1 0>, <&dmac1 1>;
+		dma-names = "tx", "rx";
+		resets = <&cru SRST_I2S0_8CH_TX_M>, <&cru SRST_I2S0_8CH_RX_M>;
+		reset-names = "tx-m", "rx-m";
+		rockchip,cru = <&cru>;
+		rockchip,grf = <&grf>;
+		rockchip,mclk-calibrate;
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2s_8ch_0_sclktx
+			     &i2s_8ch_0_sclkrx
+			     &i2s_8ch_0_lrcktx
+			     &i2s_8ch_0_lrckrx
+			     &i2s_8ch_0_sdi0
+			     &i2s_8ch_0_sdi1
+			     &i2s_8ch_0_sdi2
+			     &i2s_8ch_0_sdi3
+			     &i2s_8ch_0_sdo0
+			     &i2s_8ch_0_sdo1
+			     &i2s_8ch_0_sdo2
+			     &i2s_8ch_0_sdo3
+			     &i2s_8ch_0_mclk>;
+		status = "disabled";
+	};
+
+	i2s_8ch_1: i2s@ff310000 {
+		compatible = "rockchip,rk3308-i2s-tdm";
+		reg = <0x0 0xff310000 0x0 0x1000>;
+		interrupts = <GIC_SPI 49 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru SCLK_I2S1_8CH_TX>, <&cru SCLK_I2S1_8CH_RX>, <&cru HCLK_I2S1_8CH>,
+			 <&cru SCLK_I2S1_8CH_TX_SRC>,
+			 <&cru SCLK_I2S1_8CH_RX_SRC>,
+			 <&cru PLL_VPLL0>,
+			 <&cru PLL_VPLL1>;
+		clock-names = "mclk_tx", "mclk_rx", "hclk",
+			      "mclk_tx_src", "mclk_rx_src",
+			      "mclk_root0", "mclk_root1";
+		dmas = <&dmac1 2>, <&dmac1 3>;
+		dma-names = "tx", "rx";
+		resets = <&cru SRST_I2S1_8CH_TX_M>, <&cru SRST_I2S1_8CH_RX_M>;
+		reset-names = "tx-m", "rx-m";
+		rockchip,cru = <&cru>;
+		rockchip,grf = <&grf>;
+		rockchip,mclk-calibrate;
+		status = "disabled";
+	};
+
+	i2s_8ch_2: i2s@ff320000 {
+		compatible = "rockchip,rk3308-i2s-tdm";
+		reg = <0x0 0xff320000 0x0 0x1000>;
+		interrupts = <GIC_SPI 50 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru SCLK_I2S2_8CH_TX>, <&cru SCLK_I2S2_8CH_RX>, <&cru HCLK_I2S2_8CH>,
+			 <&cru SCLK_I2S2_8CH_TX_SRC>,
+			 <&cru SCLK_I2S2_8CH_RX_SRC>,
+			 <&cru PLL_VPLL0>,
+			 <&cru PLL_VPLL1>;
+		clock-names = "mclk_tx", "mclk_rx", "hclk",
+			      "mclk_tx_src", "mclk_rx_src",
+			      "mclk_root0", "mclk_root1";
+		dmas = <&dmac1 4>, <&dmac1 5>;
+		dma-names = "tx", "rx";
+		resets = <&cru SRST_I2S2_8CH_TX_M>, <&cru SRST_I2S2_8CH_RX_M>;
+		reset-names = "tx-m", "rx-m";
+		rockchip,cru = <&cru>;
+		rockchip,grf = <&grf>;
+		rockchip,mclk-calibrate;
+		status = "disabled";
+	};
+
+	i2s_8ch_3: i2s@ff330000 {
+		compatible = "rockchip,rk3308-i2s-tdm";
+		reg = <0x0 0xff330000 0x0 0x1000>;
+		interrupts = <GIC_SPI 51 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru SCLK_I2S3_8CH_TX>, <&cru SCLK_I2S3_8CH_RX>, <&cru HCLK_I2S3_8CH>,
+			 <&cru SCLK_I2S3_8CH_TX_SRC>,
+			 <&cru SCLK_I2S3_8CH_RX_SRC>,
+			 <&cru PLL_VPLL0>,
+			 <&cru PLL_VPLL1>;
+		clock-names = "mclk_tx", "mclk_rx", "hclk",
+			      "mclk_tx_src", "mclk_rx_src",
+			      "mclk_root0", "mclk_root1";
+		dmas = <&dmac1 7>;
+		dma-names = "rx";
+		resets = <&cru SRST_I2S3_8CH_TX_M>, <&cru SRST_I2S3_8CH_RX_M>;
+		reset-names = "tx-m", "rx-m";
+		rockchip,cru = <&cru>;
+		rockchip,grf = <&grf>;
+		rockchip,mclk-calibrate;
+		status = "disabled";
+	};
+
 	i2s_2ch_0: i2s@ff350000 {
 		compatible = "rockchip,rk3308-i2s", "rockchip,rk3066-i2s";
 		reg = <0x0 0xff350000 0x0 0x1000>;
@@ -624,6 +837,21 @@
 		status = "disabled";
 	};
 
+	spdif_rx: spdif-rx@ff3b0000 {
+		compatible = "rockchip,rk3308-spdifrx";
+		reg = <0x0 0xff3b0000 0x0 0x1000>;
+		interrupts = <GIC_SPI 56 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru SCLK_SPDIF_RX>, <&cru HCLK_SPDIFRX>;
+		clock-names = "mclk", "hclk";
+		dmas = <&dmac1 14>;
+		dma-names = "rx";
+		resets = <&cru SRST_SPDIFRX_M>;
+		reset-names = "spdifrx-m";
+		pinctrl-names = "default";
+		pinctrl-0 = <&spdif_in>;
+		status = "disabled";
+	};
+
 	usb20_otg: usb@ff400000 {
 		compatible = "rockchip,rk3308-usb", "rockchip,rk3066-usb",
 			     "snps,dwc2";
@@ -769,6 +997,27 @@
 		};
 	};
 
+	cpu_boost: cpu-boost@ff550000 {
+		compatible = "syscon";
+		reg = <0x0 0xff550000 0x0 0x1000>;
+	};
+
+	acodec: acodec@ff560000 {
+		compatible = "rockchip,rk3308-codec";
+		reg = <0x0 0xff560000 0x0 0x10000>;
+		rockchip,grf = <&grf>;
+		rockchip,detect-grf = <&detect_grf>;
+		interrupts = <GIC_SPI 114 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 115 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru PCLK_ACODEC>,
+			 <&cru SCLK_I2S2_8CH_TX_OUT>,
+			 <&cru SCLK_I2S2_8CH_RX_OUT>;
+		clock-names = "acodec", "mclk_tx", "mclk_rx";
+		resets = <&cru SRST_ACODEC_P>;
+		reset-names = "acodec-reset";
+		status = "disabled";
+	};
+
 	pinctrl: pinctrl {
 		compatible = "rockchip,rk3308-pinctrl";
 		rockchip,grf = <&grf>;
Index: linux-5.10.27/sound/soc/codecs/Kconfig
===================================================================
--- linux-5.10.27.orig/sound/soc/codecs/Kconfig
+++ linux-5.10.27/sound/soc/codecs/Kconfig
@@ -150,6 +150,7 @@ config SND_SOC_ALL_CODECS
 	imply SND_SOC_PCM5102A
 	imply SND_SOC_PCM512x_I2C
 	imply SND_SOC_PCM512x_SPI
+	imply SND_SOC_RK3308
 	imply SND_SOC_RK3328
 	imply SND_SOC_RT274
 	imply SND_SOC_RT286
@@ -1020,6 +1021,13 @@ config SND_SOC_PCM512x_SPI
 	select SND_SOC_PCM512x
 	select REGMAP_SPI
 
+config SND_SOC_RK3308
+	tristate "Rockchip RK3308 audio CODEC"
+	select SND_SOC_ROCKCHIP_I2S
+	select SND_SOC_ROCKCHIP_I2S_TDM
+	select SND_SOC_ROCKCHIP_MULTICODECS
+	select REGMAP_MMIO
+
 config SND_SOC_RK3328
 	tristate "Rockchip RK3328 audio CODEC"
 	select REGMAP_MMIO
Index: linux-5.10.27/sound/soc/codecs/Makefile
===================================================================
--- linux-5.10.27.orig/sound/soc/codecs/Makefile
+++ linux-5.10.27/sound/soc/codecs/Makefile
@@ -155,6 +155,7 @@ snd-soc-pcm5102a-objs := pcm5102a.o
 snd-soc-pcm512x-objs := pcm512x.o
 snd-soc-pcm512x-i2c-objs := pcm512x-i2c.o
 snd-soc-pcm512x-spi-objs := pcm512x-spi.o
+snd-soc-rk3308-objs := rk3308_codec.o
 snd-soc-rk3328-objs := rk3328_codec.o
 snd-soc-rl6231-objs := rl6231.o
 snd-soc-rl6347a-objs := rl6347a.o
@@ -464,6 +465,7 @@ obj-$(CONFIG_SND_SOC_PCM5102A)	+= snd-so
 obj-$(CONFIG_SND_SOC_PCM512x)	+= snd-soc-pcm512x.o
 obj-$(CONFIG_SND_SOC_PCM512x_I2C)	+= snd-soc-pcm512x-i2c.o
 obj-$(CONFIG_SND_SOC_PCM512x_SPI)	+= snd-soc-pcm512x-spi.o
+obj-$(CONFIG_SND_SOC_RK3308)	+= snd-soc-rk3308.o
 obj-$(CONFIG_SND_SOC_RK3328)	+= snd-soc-rk3328.o
 obj-$(CONFIG_SND_SOC_RL6231)	+= snd-soc-rl6231.o
 obj-$(CONFIG_SND_SOC_RL6347A)	+= snd-soc-rl6347a.o
Index: linux-5.10.27/sound/soc/rockchip/Makefile
===================================================================
--- linux-5.10.27.orig/sound/soc/rockchip/Makefile
+++ linux-5.10.27/sound/soc/rockchip/Makefile
@@ -1,20 +1,27 @@
 # SPDX-License-Identifier: GPL-2.0
 # ROCKCHIP Platform Support
 snd-soc-rockchip-i2s-objs := rockchip_i2s.o
+snd-soc-rockchip-i2s-tdm-objs := rockchip_i2s_tdm.o
+snd-soc-rockchip-multi-dais-objs := rockchip_multi_dais.o rockchip_multi_dais_pcm.o
 snd-soc-rockchip-pcm-objs := rockchip_pcm.o
 snd-soc-rockchip-pdm-objs := rockchip_pdm.o
 snd-soc-rockchip-spdif-objs := rockchip_spdif.o
-
+snd-soc-rockchip-spdifrx-objs := rockchip_spdifrx.o
 obj-$(CONFIG_SND_SOC_ROCKCHIP_I2S) += snd-soc-rockchip-i2s.o snd-soc-rockchip-pcm.o
+obj-$(CONFIG_SND_SOC_ROCKCHIP_I2S_TDM) += snd-soc-rockchip-i2s-tdm.o
+obj-$(CONFIG_SND_SOC_ROCKCHIP_MULTI_DAIS) += snd-soc-rockchip-multi-dais.o
 obj-$(CONFIG_SND_SOC_ROCKCHIP_PDM) += snd-soc-rockchip-pdm.o
 obj-$(CONFIG_SND_SOC_ROCKCHIP_SPDIF) += snd-soc-rockchip-spdif.o
+obj-$(CONFIG_SND_SOC_ROCKCHIP_SPDIFRX) += snd-soc-rockchip-spdifrx.o
 
 snd-soc-rockchip-max98090-objs := rockchip_max98090.o
+snd-soc-rockchip-multicodecs-objs := rockchip_multicodecs.o
 snd-soc-rockchip-rt5645-objs := rockchip_rt5645.o
 snd-soc-rk3288-hdmi-analog-objs := rk3288_hdmi_analog.o
 snd-soc-rk3399-gru-sound-objs := rk3399_gru_sound.o
 
 obj-$(CONFIG_SND_SOC_ROCKCHIP_MAX98090) += snd-soc-rockchip-max98090.o
+obj-$(CONFIG_SND_SOC_ROCKCHIP_MULTICODECS) += snd-soc-rockchip-multicodecs.o
 obj-$(CONFIG_SND_SOC_ROCKCHIP_RT5645) += snd-soc-rockchip-rt5645.o
 obj-$(CONFIG_SND_SOC_RK3288_HDMI_ANALOG) += snd-soc-rk3288-hdmi-analog.o
 obj-$(CONFIG_SND_SOC_RK3399_GRU_SOUND) += snd-soc-rk3399-gru-sound.o
Index: linux-5.10.27/sound/soc/rockchip/rockchip_i2s.c
===================================================================
--- linux-5.10.27.orig/sound/soc/rockchip/rockchip_i2s.c
+++ linux-5.10.27/sound/soc/rockchip/rockchip_i2s.c
@@ -5,6 +5,10 @@
  *
  * Copyright (c) 2014 Rockchip Electronics Co. Ltd.
  * Author: Jianqun <jay.xu@rock-chips.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
  */
 
 #include <linux/module.h>
@@ -15,6 +19,7 @@
 #include <linux/clk.h>
 #include <linux/pm_runtime.h>
 #include <linux/regmap.h>
+#include <linux/spinlock.h>
 #include <sound/pcm_params.h>
 #include <sound/dmaengine_pcm.h>
 
@@ -49,8 +54,13 @@ struct rk_i2s_dev {
 	bool rx_start;
 	bool is_master_mode;
 	const struct rk_i2s_pins *pins;
+	unsigned int bclk_fs;
+	unsigned int clk_trcm;
 };
 
+/* txctrl/rxctrl lock */
+static DEFINE_SPINLOCK(lock);
+
 static int i2s_runtime_suspend(struct device *dev)
 {
 	struct rk_i2s_dev *i2s = dev_get_drvdata(dev);
@@ -92,6 +102,7 @@ static void rockchip_snd_txctrl(struct r
 	unsigned int val = 0;
 	int retry = 10;
 
+	spin_lock(&lock);
 	if (on) {
 		regmap_update_bits(i2s->regmap, I2S_DMACR,
 				   I2S_DMACR_TDE_ENABLE, I2S_DMACR_TDE_ENABLE);
@@ -132,6 +143,7 @@ static void rockchip_snd_txctrl(struct r
 			}
 		}
 	}
+	spin_unlock(&lock);
 }
 
 static void rockchip_snd_rxctrl(struct rk_i2s_dev *i2s, int on)
@@ -139,6 +151,7 @@ static void rockchip_snd_rxctrl(struct r
 	unsigned int val = 0;
 	int retry = 10;
 
+	spin_lock(&lock);
 	if (on) {
 		regmap_update_bits(i2s->regmap, I2S_DMACR,
 				   I2S_DMACR_RDE_ENABLE, I2S_DMACR_RDE_ENABLE);
@@ -179,6 +192,7 @@ static void rockchip_snd_rxctrl(struct r
 			}
 		}
 	}
+	spin_unlock(&lock);
 }
 
 static int rockchip_i2s_set_fmt(struct snd_soc_dai *cpu_dai,
@@ -186,7 +200,9 @@ static int rockchip_i2s_set_fmt(struct s
 {
 	struct rk_i2s_dev *i2s = to_info(cpu_dai);
 	unsigned int mask = 0, val = 0;
+	int ret = 0;
 
+	pm_runtime_get_sync(cpu_dai->dev);
 	mask = I2S_CKR_MSS_MASK;
 	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
 	case SND_SOC_DAIFMT_CBS_CFS:
@@ -199,7 +215,8 @@ static int rockchip_i2s_set_fmt(struct s
 		i2s->is_master_mode = false;
 		break;
 	default:
-		return -EINVAL;
+		ret = -EINVAL;
+		goto err_pm_put;
 	}
 
 	regmap_update_bits(i2s->regmap, I2S_CKR, mask, val);
@@ -213,7 +230,8 @@ static int rockchip_i2s_set_fmt(struct s
 		val = I2S_CKR_CKP_POS;
 		break;
 	default:
-		return -EINVAL;
+		ret = -EINVAL;
+		goto err_pm_put;
 	}
 
 	regmap_update_bits(i2s->regmap, I2S_CKR, mask, val);
@@ -236,7 +254,8 @@ static int rockchip_i2s_set_fmt(struct s
 		val = I2S_TXCR_TFS_PCM | I2S_TXCR_PBM_MODE(1);
 		break;
 	default:
-		return -EINVAL;
+		ret = -EINVAL;
+		goto err_pm_put;
 	}
 
 	regmap_update_bits(i2s->regmap, I2S_TXCR, mask, val);
@@ -259,12 +278,16 @@ static int rockchip_i2s_set_fmt(struct s
 		val = I2S_RXCR_TFS_PCM | I2S_RXCR_PBM_MODE(1);
 		break;
 	default:
-		return -EINVAL;
+		ret = -EINVAL;
+		goto err_pm_put;
 	}
 
 	regmap_update_bits(i2s->regmap, I2S_RXCR, mask, val);
 
-	return 0;
+err_pm_put:
+	pm_runtime_put(cpu_dai->dev);
+
+	return ret;
 }
 
 static int rockchip_i2s_hw_params(struct snd_pcm_substream *substream,
@@ -272,17 +295,16 @@ static int rockchip_i2s_hw_params(struct
 				  struct snd_soc_dai *dai)
 {
 	struct rk_i2s_dev *i2s = to_info(dai);
-	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
 	unsigned int val = 0;
 	unsigned int mclk_rate, bclk_rate, div_bclk, div_lrck;
 
 	if (i2s->is_master_mode) {
 		mclk_rate = clk_get_rate(i2s->mclk);
-		bclk_rate = 2 * 32 * params_rate(params);
-		if (bclk_rate == 0 || mclk_rate % bclk_rate)
+		bclk_rate = i2s->bclk_fs * params_rate(params);
+		if (!bclk_rate)
 			return -EINVAL;
 
-		div_bclk = mclk_rate / bclk_rate;
+		div_bclk = DIV_ROUND_CLOSEST(mclk_rate, bclk_rate);
 		div_lrck = bclk_rate / params_rate(params);
 		regmap_update_bits(i2s->regmap, I2S_CKR,
 				   I2S_CKR_MDIV_MASK,
@@ -372,13 +394,6 @@ static int rockchip_i2s_hw_params(struct
 	regmap_update_bits(i2s->regmap, I2S_DMACR, I2S_DMACR_RDL_MASK,
 			   I2S_DMACR_RDL(16));
 
-	val = I2S_CKR_TRCM_TXRX;
-	if (dai->driver->symmetric_rates && rtd->dai_link->symmetric_rates)
-		val = I2S_CKR_TRCM_TXONLY;
-
-	regmap_update_bits(i2s->regmap, I2S_CKR,
-			   I2S_CKR_TRCM_MASK,
-			   val);
 	return 0;
 }
 
@@ -419,9 +434,6 @@ static int rockchip_i2s_set_sysclk(struc
 	struct rk_i2s_dev *i2s = to_info(cpu_dai);
 	int ret;
 
-	if (freq == 0)
-		return 0;
-
 	ret = clk_set_rate(i2s->mclk, freq);
 	if (ret)
 		dev_err(i2s->dev, "Fail to set mclk %d\n", ret);
@@ -471,7 +483,6 @@ static struct snd_soc_dai_driver rockchi
 			    SNDRV_PCM_FMTBIT_S32_LE),
 	},
 	.ops = &rockchip_i2s_dai_ops,
-	.symmetric_rates = 1,
 };
 
 static const struct snd_soc_component_driver rockchip_i2s_component = {
@@ -567,9 +578,14 @@ static const struct rk_i2s_pins rk3399_i
 };
 
 static const struct of_device_id rockchip_i2s_match[] = {
+	{ .compatible = "rockchip,px30-i2s", },
+	{ .compatible = "rockchip,rk3036-i2s", },
 	{ .compatible = "rockchip,rk3066-i2s", },
+	{ .compatible = "rockchip,rk3128-i2s", },
 	{ .compatible = "rockchip,rk3188-i2s", },
 	{ .compatible = "rockchip,rk3288-i2s", },
+	{ .compatible = "rockchip,rk3328-i2s", },
+	{ .compatible = "rockchip,rk3368-i2s", },
 	{ .compatible = "rockchip,rk3399-i2s", .data = &rk3399_i2s_pins },
 	{},
 };
@@ -586,8 +602,10 @@ static int rockchip_i2s_probe(struct pla
 	int val;
 
 	i2s = devm_kzalloc(&pdev->dev, sizeof(*i2s), GFP_KERNEL);
-	if (!i2s)
+	if (!i2s) {
+		dev_err(&pdev->dev, "Can't allocate rk_i2s_dev\n");
 		return -ENOMEM;
+	}
 
 	i2s->dev = &pdev->dev;
 
@@ -633,11 +651,11 @@ static int rockchip_i2s_probe(struct pla
 
 	i2s->playback_dma_data.addr = res->start + I2S_TXDR;
 	i2s->playback_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
-	i2s->playback_dma_data.maxburst = 4;
+	i2s->playback_dma_data.maxburst = 8;
 
 	i2s->capture_dma_data.addr = res->start + I2S_RXDR;
 	i2s->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
-	i2s->capture_dma_data.maxburst = 4;
+	i2s->capture_dma_data.maxburst = 8;
 
 	dev_set_drvdata(&pdev->dev, i2s);
 
@@ -648,13 +666,12 @@ static int rockchip_i2s_probe(struct pla
 			goto err_pm_disable;
 	}
 
-	soc_dai = devm_kmemdup(&pdev->dev, &rockchip_i2s_dai,
+	soc_dai = devm_kzalloc(&pdev->dev,
 			       sizeof(*soc_dai), GFP_KERNEL);
-	if (!soc_dai) {
-		ret = -ENOMEM;
-		goto err_pm_disable;
-	}
+	if (!soc_dai)
+		return -ENOMEM;
 
+	memcpy(soc_dai, &rockchip_i2s_dai, sizeof(*soc_dai));
 	if (!of_property_read_u32(node, "rockchip,playback-channels", &val)) {
 		if (val >= 2 && val <= 8)
 			soc_dai->playback.channels_max = val;
@@ -665,6 +682,29 @@ static int rockchip_i2s_probe(struct pla
 			soc_dai->capture.channels_max = val;
 	}
 
+	if (of_property_read_bool(node, "rockchip,playback-only"))
+		soc_dai->capture.channels_min = 0;
+	else if (of_property_read_bool(node, "rockchip,capture-only"))
+		soc_dai->playback.channels_min = 0;
+
+	i2s->bclk_fs = 64;
+	if (!of_property_read_u32(node, "rockchip,bclk-fs", &val)) {
+		if ((val >= 32) && (val % 2 == 0))
+			i2s->bclk_fs = val;
+	}
+
+	i2s->clk_trcm = I2S_CKR_TRCM_TXRX;
+	if (!of_property_read_u32(node, "rockchip,clk-trcm", &val)) {
+		if (val >= 0 && val <= 2) {
+			i2s->clk_trcm = val << I2S_CKR_TRCM_SHIFT;
+			if (i2s->clk_trcm)
+				soc_dai->symmetric_rates = 1;
+		}
+	}
+
+	regmap_update_bits(i2s->regmap, I2S_CKR,
+			   I2S_CKR_TRCM_MASK, i2s->clk_trcm);
+
 	ret = devm_snd_soc_register_component(&pdev->dev,
 					      &rockchip_i2s_component,
 					      soc_dai, 1);
@@ -674,10 +714,12 @@ static int rockchip_i2s_probe(struct pla
 		goto err_suspend;
 	}
 
-	ret = rockchip_pcm_platform_register(&pdev->dev);
+	if (of_property_read_bool(node, "rockchip,no-dmaengine"))
+		return ret;
+	ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
 	if (ret) {
 		dev_err(&pdev->dev, "Could not register PCM\n");
-		goto err_suspend;
+		return ret;
 	}
 
 	return 0;
@@ -699,14 +741,41 @@ static int rockchip_i2s_remove(struct pl
 	if (!pm_runtime_status_suspended(&pdev->dev))
 		i2s_runtime_suspend(&pdev->dev);
 
+	clk_disable_unprepare(i2s->mclk);
 	clk_disable_unprepare(i2s->hclk);
 
 	return 0;
 }
 
+#ifdef CONFIG_PM_SLEEP
+static int rockchip_i2s_suspend(struct device *dev)
+{
+	struct rk_i2s_dev *i2s = dev_get_drvdata(dev);
+
+	regcache_mark_dirty(i2s->regmap);
+
+	return 0;
+}
+
+static int rockchip_i2s_resume(struct device *dev)
+{
+	struct rk_i2s_dev *i2s = dev_get_drvdata(dev);
+	int ret;
+
+	ret = pm_runtime_get_sync(dev);
+	if (ret < 0)
+		return ret;
+	ret = regcache_sync(i2s->regmap);
+	pm_runtime_put(dev);
+
+	return ret;
+}
+#endif
+
 static const struct dev_pm_ops rockchip_i2s_pm_ops = {
 	SET_RUNTIME_PM_OPS(i2s_runtime_suspend, i2s_runtime_resume,
 			   NULL)
+	SET_SYSTEM_SLEEP_PM_OPS(rockchip_i2s_suspend, rockchip_i2s_resume)
 };
 
 static struct platform_driver rockchip_i2s_driver = {
Index: linux-5.10.27/sound/soc/rockchip/rockchip_i2s.h
===================================================================
--- linux-5.10.27.orig/sound/soc/rockchip/rockchip_i2s.h
+++ linux-5.10.27/sound/soc/rockchip/rockchip_i2s.h
@@ -6,6 +6,10 @@
  *
  * Copyright (c) 2014 Rockchip Electronics Co. Ltd.
  * Author: Jianqun xu <jay.xu@rock-chips.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
  */
 
 #ifndef _ROCKCHIP_IIS_H
Index: linux-5.10.27/sound/soc/rockchip/rockchip_i2s_tdm.c
===================================================================
--- /dev/null
+++ linux-5.10.27/sound/soc/rockchip/rockchip_i2s_tdm.c
@@ -0,0 +1,1702 @@
+/* sound/soc/rockchip/rockchip_i2s_tdm.c
+ *
+ * ALSA SoC Audio Layer - Rockchip I2S/TDM Controller driver
+ *
+ * Copyright (c) 2018 Rockchip Electronics Co. Ltd.
+ * Author: Sugar Zhang <sugar.zhang@rock-chips.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/mfd/syscon.h>
+#include <linux/delay.h>
+#include <linux/of_gpio.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include <linux/spinlock.h>
+#include <sound/pcm_params.h>
+#include <sound/dmaengine_pcm.h>
+
+#include "rockchip_i2s_tdm.h"
+
+#define DRV_NAME "rockchip-i2s-tdm"
+
+#define DEFAULT_MCLK_FS				256
+#define CH_GRP_MAX				4  /* The max channel 8 / 2 */
+#define MULTIPLEX_CH_MAX			10
+
+struct txrx_config {
+	u32 addr;
+	u32 reg;
+	u32 txonly;
+	u32 rxonly;
+};
+
+struct rk_i2s_soc_data {
+	u32 softrst_offset;
+	u32 grf_reg_offset;
+	u32 grf_shift;
+	int tx_reset_id;
+	int rx_reset_id;
+	int config_count;
+	const struct txrx_config *configs;
+	int (*init)(struct device *dev, u32 addr);
+};
+
+struct rk_i2s_tdm_dev {
+	struct device *dev;
+	struct clk *hclk;
+	struct clk *mclk_tx;
+	struct clk *mclk_rx;
+	/* The mclk_tx_src is parent of mclk_tx */
+	struct clk *mclk_tx_src;
+	/* The mclk_rx_src is parent of mclk_rx */
+	struct clk *mclk_rx_src;
+	/*
+	 * The mclk_root0 and mclk_root1 are root parent and supplies for
+	 * the different FS.
+	 *
+	 * e.g:
+	 * mclk_root0 is VPLL0, used for FS=48000Hz
+	 * mclk_root0 is VPLL1, used for FS=44100Hz
+	 */
+	struct clk *mclk_root0;
+	struct clk *mclk_root1;
+	struct regmap *regmap;
+	struct regmap *grf;
+	struct snd_dmaengine_dai_dma_data capture_dma_data;
+	struct snd_dmaengine_dai_dma_data playback_dma_data;
+	struct reset_control *tx_reset;
+	struct reset_control *rx_reset;
+	struct rk_i2s_soc_data *soc_data;
+	void __iomem *cru_base;
+	bool is_master_mode;
+	bool io_multiplex;
+	bool mclk_calibrate;
+	bool tdm_mode;
+	unsigned int mclk_rx_freq;
+	unsigned int mclk_tx_freq;
+	unsigned int bclk_fs;
+	unsigned int clk_trcm;
+	unsigned int i2s_sdis[CH_GRP_MAX];
+	unsigned int i2s_sdos[CH_GRP_MAX];
+	atomic_t refcount;
+	spinlock_t lock; /* xfer lock */
+};
+
+static int to_ch_num(unsigned int val)
+{
+	int chs;
+
+	switch (val) {
+	case I2S_CHN_4:
+		chs = 4;
+		break;
+	case I2S_CHN_6:
+		chs = 6;
+		break;
+	case I2S_CHN_8:
+		chs = 8;
+		break;
+	default:
+		chs = 2;
+		break;
+	}
+
+	return chs;
+}
+
+static int i2s_tdm_runtime_suspend(struct device *dev)
+{
+	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+
+	regcache_cache_only(i2s_tdm->regmap, true);
+	if (!IS_ERR(i2s_tdm->mclk_tx))
+		clk_disable_unprepare(i2s_tdm->mclk_tx);
+	if (!IS_ERR(i2s_tdm->mclk_rx))
+		clk_disable_unprepare(i2s_tdm->mclk_rx);
+
+	return 0;
+}
+
+static int i2s_tdm_runtime_resume(struct device *dev)
+{
+	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+	int ret;
+
+	if (!IS_ERR(i2s_tdm->mclk_tx))
+		clk_prepare_enable(i2s_tdm->mclk_tx);
+	if (!IS_ERR(i2s_tdm->mclk_rx))
+		clk_prepare_enable(i2s_tdm->mclk_rx);
+
+	regcache_cache_only(i2s_tdm->regmap, false);
+	regcache_mark_dirty(i2s_tdm->regmap);
+
+	ret = regcache_sync(i2s_tdm->regmap);
+	if (ret) {
+		if (!IS_ERR(i2s_tdm->mclk_tx))
+			clk_disable_unprepare(i2s_tdm->mclk_tx);
+		if (!IS_ERR(i2s_tdm->mclk_rx))
+			clk_disable_unprepare(i2s_tdm->mclk_rx);
+	}
+
+	return ret;
+}
+
+static inline struct rk_i2s_tdm_dev *to_info(struct snd_soc_dai *dai)
+{
+	return snd_soc_dai_get_drvdata(dai);
+}
+
+#if defined(CONFIG_ARM) && !defined(writeq)
+static inline void __raw_writeq(u64 val, volatile void __iomem *addr)
+{
+	asm volatile("strd %0, %H0, [%1]" : : "r" (val), "r" (addr));
+}
+#define writeq(v,c) ({ __iowmb(); __raw_writeq((__force u64) cpu_to_le64(v), c); })
+#endif
+
+static void rockchip_snd_xfer_reset_assert(struct rk_i2s_tdm_dev *i2s_tdm,
+					   int tx_bank, int tx_offset,
+					   int rx_bank, int rx_offset)
+{
+	void __iomem *cru_reset, *addr;
+	unsigned long flags;
+	u64 val;
+
+	cru_reset = i2s_tdm->cru_base + i2s_tdm->soc_data->softrst_offset;
+
+	switch (abs(tx_bank - rx_bank)) {
+	case 0:
+		writel(BIT(tx_offset) | BIT(rx_offset) |
+		       (BIT(tx_offset) << 16) | (BIT(rx_offset) << 16),
+		       cru_reset + (tx_bank * 4));
+		break;
+	case 1:
+		if (tx_bank < rx_bank) {
+			val = BIT(rx_offset) | (BIT(rx_offset) << 16);
+			val <<= 32;
+			val |= BIT(tx_offset) | (BIT(tx_offset) << 16);
+			addr = cru_reset + (tx_bank * 4);
+		} else {
+			val = BIT(tx_offset) | (BIT(tx_offset) << 16);
+			val <<= 32;
+			val |= BIT(rx_offset) | (BIT(rx_offset) << 16);
+			addr = cru_reset + (rx_bank * 4);
+		}
+
+		if (IS_ALIGNED((uintptr_t)addr, 8)) {
+			writeq(val, addr);
+			break;
+		}
+		/* fall through */
+	default:
+		local_irq_save(flags);
+		writel(BIT(tx_offset) | (BIT(tx_offset) << 16),
+		       cru_reset + (tx_bank * 4));
+		writel(BIT(rx_offset) | (BIT(rx_offset) << 16),
+		       cru_reset + (rx_bank * 4));
+		local_irq_restore(flags);
+		break;
+	}
+}
+
+static void rockchip_snd_xfer_reset_deassert(struct rk_i2s_tdm_dev *i2s_tdm,
+					     int tx_bank, int tx_offset,
+					     int rx_bank, int rx_offset)
+{
+	void __iomem *cru_reset, *addr;
+	unsigned long flags;
+	u64 val;
+
+	cru_reset = i2s_tdm->cru_base + i2s_tdm->soc_data->softrst_offset;
+
+	switch (abs(tx_bank - rx_bank)) {
+	case 0:
+		writel((BIT(tx_offset) << 16) | (BIT(rx_offset) << 16),
+		       cru_reset + (tx_bank * 4));
+		break;
+	case 1:
+		if (tx_bank < rx_bank) {
+			val = (BIT(rx_offset) << 16);
+			val <<= 32;
+			val |= (BIT(tx_offset) << 16);
+			addr = cru_reset + (tx_bank * 4);
+		} else {
+			val = (BIT(tx_offset) << 16);
+			val <<= 32;
+			val |= (BIT(rx_offset) << 16);
+			addr = cru_reset + (rx_bank * 4);
+		}
+
+		if (IS_ALIGNED((uintptr_t)addr, 8)) {
+			writeq(val, addr);
+			break;
+		}
+		/* fall through */
+	default:
+		local_irq_save(flags);
+		writel((BIT(tx_offset) << 16),
+		       cru_reset + (tx_bank * 4));
+		writel((BIT(rx_offset) << 16),
+		       cru_reset + (rx_bank * 4));
+		local_irq_restore(flags);
+		break;
+	}
+}
+
+/*
+ * to make sure tx/rx reset at the same time when clk_trcm > 0
+ * if not, will lead lrck is abnormal.
+ */
+static void rockchip_snd_xfer_sync_reset(struct rk_i2s_tdm_dev *i2s_tdm)
+{
+	int tx_id, rx_id;
+	int tx_bank, rx_bank, tx_offset, rx_offset;
+
+	if (!i2s_tdm->cru_base || !i2s_tdm->soc_data)
+		return;
+
+	tx_id = i2s_tdm->soc_data->tx_reset_id;
+	rx_id = i2s_tdm->soc_data->rx_reset_id;
+	if (tx_id < 0 || rx_id < 0) {
+		dev_err(i2s_tdm->dev, "invalid reset id\n");
+		return;
+	}
+
+	tx_bank = tx_id / 16;
+	tx_offset = tx_id % 16;
+	rx_bank = rx_id / 16;
+	rx_offset = rx_id % 16;
+	dev_dbg(i2s_tdm->dev,
+		"tx_bank: %d, rx_bank: %d,tx_offset: %d, rx_offset: %d\n",
+		tx_bank, rx_bank, tx_offset, rx_offset);
+
+	rockchip_snd_xfer_reset_assert(i2s_tdm, tx_bank, tx_offset,
+				       rx_bank, rx_offset);
+
+	udelay(150);
+
+	rockchip_snd_xfer_reset_deassert(i2s_tdm, tx_bank, tx_offset,
+					 rx_bank, rx_offset);
+}
+
+/* only used when clk_trcm > 0 */
+static void rockchip_snd_txrxctrl(struct snd_pcm_substream *substream,
+				  struct snd_soc_dai *dai, int on)
+{
+	struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
+	unsigned int val = 0;
+	int retry = 10;
+
+	spin_lock(&i2s_tdm->lock);
+	if (on) {
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
+					   I2S_DMACR_TDE_ENABLE,
+					   I2S_DMACR_TDE_ENABLE);
+		else
+			regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
+					   I2S_DMACR_RDE_ENABLE,
+					   I2S_DMACR_RDE_ENABLE);
+
+		if (atomic_inc_return(&i2s_tdm->refcount) == 1) {
+			rockchip_snd_xfer_sync_reset(i2s_tdm);
+			regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+					   I2S_XFER_TXS_START |
+					   I2S_XFER_RXS_START,
+					   I2S_XFER_TXS_START |
+					   I2S_XFER_RXS_START);
+		}
+	} else {
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
+					   I2S_DMACR_TDE_ENABLE,
+					   I2S_DMACR_TDE_DISABLE);
+		else
+			regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
+					   I2S_DMACR_RDE_ENABLE,
+					   I2S_DMACR_RDE_DISABLE);
+
+		if (atomic_dec_and_test(&i2s_tdm->refcount)) {
+			regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+					   I2S_XFER_TXS_START |
+					   I2S_XFER_RXS_START,
+					   I2S_XFER_TXS_STOP |
+					   I2S_XFER_RXS_STOP);
+
+			udelay(150);
+			regmap_update_bits(i2s_tdm->regmap, I2S_CLR,
+					   I2S_CLR_TXC | I2S_CLR_RXC,
+					   I2S_CLR_TXC | I2S_CLR_RXC);
+
+			regmap_read(i2s_tdm->regmap, I2S_CLR, &val);
+
+			/* Should wait for clear operation to finish */
+			while (val) {
+				regmap_read(i2s_tdm->regmap, I2S_CLR, &val);
+				retry--;
+				if (!retry) {
+					dev_info(i2s_tdm->dev, "reset txrx\n");
+					rockchip_snd_xfer_sync_reset(i2s_tdm);
+					break;
+				}
+			}
+		}
+	}
+	spin_unlock(&i2s_tdm->lock);
+}
+
+static void rockchip_snd_txctrl(struct rk_i2s_tdm_dev *i2s_tdm, int on)
+{
+	unsigned int val = 0;
+	int retry = 10;
+
+	if (on) {
+		regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
+				   I2S_DMACR_TDE_ENABLE, I2S_DMACR_TDE_ENABLE);
+
+		regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+				   I2S_XFER_TXS_START,
+				   I2S_XFER_TXS_START);
+	} else {
+		regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
+				   I2S_DMACR_TDE_ENABLE, I2S_DMACR_TDE_DISABLE);
+
+		regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+				   I2S_XFER_TXS_START,
+				   I2S_XFER_TXS_STOP);
+
+		udelay(150);
+		regmap_update_bits(i2s_tdm->regmap, I2S_CLR,
+				   I2S_CLR_TXC,
+				   I2S_CLR_TXC);
+
+		regmap_read(i2s_tdm->regmap, I2S_CLR, &val);
+
+		/* Should wait for clear operation to finish */
+		while (val) {
+			regmap_read(i2s_tdm->regmap, I2S_CLR, &val);
+			retry--;
+			if (!retry) {
+				dev_warn(i2s_tdm->dev, "reset tx\n");
+				reset_control_assert(i2s_tdm->tx_reset);
+				udelay(1);
+				reset_control_deassert(i2s_tdm->tx_reset);
+				break;
+			}
+		}
+	}
+}
+
+static void rockchip_snd_rxctrl(struct rk_i2s_tdm_dev *i2s_tdm, int on)
+{
+	unsigned int val = 0;
+	int retry = 10;
+
+	if (on) {
+		regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
+				   I2S_DMACR_RDE_ENABLE, I2S_DMACR_RDE_ENABLE);
+
+		regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+				   I2S_XFER_RXS_START,
+				   I2S_XFER_RXS_START);
+	} else {
+		regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
+				   I2S_DMACR_RDE_ENABLE, I2S_DMACR_RDE_DISABLE);
+
+		regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+				   I2S_XFER_RXS_START,
+				   I2S_XFER_RXS_STOP);
+
+		udelay(150);
+		regmap_update_bits(i2s_tdm->regmap, I2S_CLR,
+				   I2S_CLR_RXC,
+				   I2S_CLR_RXC);
+
+		regmap_read(i2s_tdm->regmap, I2S_CLR, &val);
+
+		/* Should wait for clear operation to finish */
+		while (val) {
+			regmap_read(i2s_tdm->regmap, I2S_CLR, &val);
+			retry--;
+			if (!retry) {
+				dev_warn(i2s_tdm->dev, "reset rx\n");
+				reset_control_assert(i2s_tdm->rx_reset);
+				udelay(1);
+				reset_control_deassert(i2s_tdm->rx_reset);
+				break;
+			}
+		}
+	}
+}
+
+static int rockchip_i2s_tdm_set_fmt(struct snd_soc_dai *cpu_dai,
+				    unsigned int fmt)
+{
+	struct rk_i2s_tdm_dev *i2s_tdm = to_info(cpu_dai);
+	unsigned int mask = 0, val = 0, tdm_val = 0;
+	int ret = 0;
+	bool is_tdm = i2s_tdm->tdm_mode;
+
+	pm_runtime_get_sync(cpu_dai->dev);
+	mask = I2S_CKR_MSS_MASK;
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		/* Set source clock in Master mode */
+		val = I2S_CKR_MSS_MASTER;
+		i2s_tdm->is_master_mode = true;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFM:
+		val = I2S_CKR_MSS_SLAVE;
+		i2s_tdm->is_master_mode = false;
+		break;
+	default:
+		ret = -EINVAL;
+		goto err_pm_put;
+	}
+
+	regmap_update_bits(i2s_tdm->regmap, I2S_CKR, mask, val);
+
+	mask = I2S_CKR_CKP_MASK;
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		val = I2S_CKR_CKP_NEG;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		val = I2S_CKR_CKP_POS;
+		break;
+	default:
+		ret = -EINVAL;
+		goto err_pm_put;
+	}
+
+	regmap_update_bits(i2s_tdm->regmap, I2S_CKR, mask, val);
+
+	mask = I2S_TXCR_IBM_MASK | I2S_TXCR_TFS_MASK | I2S_TXCR_PBM_MASK;
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_RIGHT_J:
+		val = I2S_TXCR_IBM_RSJM;
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		val = I2S_TXCR_IBM_LSJM;
+		break;
+	case SND_SOC_DAIFMT_I2S:
+		val = I2S_TXCR_IBM_NORMAL;
+		break;
+	case SND_SOC_DAIFMT_DSP_A: /* PCM no delay mode */
+		val = I2S_TXCR_TFS_PCM;
+		break;
+	case SND_SOC_DAIFMT_DSP_B: /* PCM delay 1 mode */
+		val = I2S_TXCR_TFS_PCM | I2S_TXCR_PBM_MODE(1);
+		break;
+	default:
+		ret = -EINVAL;
+		goto err_pm_put;
+	}
+
+	regmap_update_bits(i2s_tdm->regmap, I2S_TXCR, mask, val);
+
+	mask = I2S_RXCR_IBM_MASK | I2S_RXCR_TFS_MASK | I2S_RXCR_PBM_MASK;
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_RIGHT_J:
+		val = I2S_RXCR_IBM_RSJM;
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		val = I2S_RXCR_IBM_LSJM;
+		break;
+	case SND_SOC_DAIFMT_I2S:
+		val = I2S_RXCR_IBM_NORMAL;
+		break;
+	case SND_SOC_DAIFMT_DSP_A: /* PCM no delay mode */
+		val = I2S_RXCR_TFS_PCM;
+		break;
+	case SND_SOC_DAIFMT_DSP_B: /* PCM delay 1 mode */
+		val = I2S_RXCR_TFS_PCM | I2S_RXCR_PBM_MODE(1);
+		break;
+	default:
+		ret = -EINVAL;
+		goto err_pm_put;
+	}
+
+	regmap_update_bits(i2s_tdm->regmap, I2S_RXCR, mask, val);
+
+	if (is_tdm) {
+		switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+		case SND_SOC_DAIFMT_RIGHT_J:
+			val = I2S_TXCR_TFS_TDM_I2S;
+			tdm_val = TDM_SHIFT_CTRL(2);
+			break;
+		case SND_SOC_DAIFMT_LEFT_J:
+			val = I2S_TXCR_TFS_TDM_I2S;
+			tdm_val = TDM_SHIFT_CTRL(1);
+			break;
+		case SND_SOC_DAIFMT_I2S:
+			val = I2S_TXCR_TFS_TDM_I2S;
+			tdm_val = TDM_SHIFT_CTRL(0);
+			break;
+		case SND_SOC_DAIFMT_DSP_A:
+			val = I2S_TXCR_TFS_TDM_PCM;
+			tdm_val = TDM_SHIFT_CTRL(0);
+			break;
+		case SND_SOC_DAIFMT_DSP_B:
+			val = I2S_TXCR_TFS_TDM_PCM;
+			tdm_val = TDM_SHIFT_CTRL(2);
+			break;
+		default:
+			ret = -EINVAL;
+			goto err_pm_put;
+		}
+
+		tdm_val |= TDM_FSYNC_WIDTH_SEL1(1);
+		tdm_val |= TDM_FSYNC_WIDTH_ONE_FRAME;
+
+		mask = I2S_TXCR_TFS_MASK;
+		regmap_update_bits(i2s_tdm->regmap, I2S_TXCR, mask, val);
+		regmap_update_bits(i2s_tdm->regmap, I2S_RXCR, mask, val);
+
+		mask = TDM_FSYNC_WIDTH_SEL1_MSK | TDM_FSYNC_WIDTH_SEL0_MSK |
+		       TDM_SHIFT_CTRL_MSK;
+		regmap_update_bits(i2s_tdm->regmap, I2S_TDM_TXCR,
+				   mask, tdm_val);
+		regmap_update_bits(i2s_tdm->regmap, I2S_TDM_RXCR,
+				   mask, tdm_val);
+	}
+
+err_pm_put:
+	pm_runtime_put(cpu_dai->dev);
+
+	return ret;
+}
+
+static void rockchip_i2s_tdm_xfer_pause(struct snd_pcm_substream *substream,
+					struct rk_i2s_tdm_dev *i2s_tdm)
+{
+	int stream;
+	unsigned int val = 0;
+	int retry = 10;
+
+	stream = SNDRV_PCM_STREAM_LAST - substream->stream;
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+		regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
+				   I2S_DMACR_TDE_ENABLE,
+				   I2S_DMACR_TDE_DISABLE);
+	else
+		regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
+				   I2S_DMACR_RDE_ENABLE,
+				   I2S_DMACR_RDE_DISABLE);
+
+	regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+			   I2S_XFER_TXS_START |
+			   I2S_XFER_RXS_START,
+			   I2S_XFER_TXS_STOP |
+			   I2S_XFER_RXS_STOP);
+
+	udelay(150);
+	regmap_update_bits(i2s_tdm->regmap, I2S_CLR,
+			   I2S_CLR_TXC | I2S_CLR_RXC,
+			   I2S_CLR_TXC | I2S_CLR_RXC);
+
+	regmap_read(i2s_tdm->regmap, I2S_CLR, &val);
+
+	/* Should wait for clear operation to finish */
+	while (val) {
+		regmap_read(i2s_tdm->regmap, I2S_CLR, &val);
+		retry--;
+		if (!retry) {
+			dev_info(i2s_tdm->dev, "reset txrx\n");
+			rockchip_snd_xfer_sync_reset(i2s_tdm);
+			break;
+		}
+	}
+}
+
+static void rockchip_i2s_tdm_xfer_resume(struct snd_pcm_substream *substream,
+					 struct rk_i2s_tdm_dev *i2s_tdm)
+{
+	int stream;
+
+	stream = SNDRV_PCM_STREAM_LAST - substream->stream;
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+		regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
+				   I2S_DMACR_TDE_ENABLE,
+				   I2S_DMACR_TDE_ENABLE);
+	else
+		regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
+				   I2S_DMACR_RDE_ENABLE,
+				   I2S_DMACR_RDE_ENABLE);
+
+	regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+			   I2S_XFER_TXS_START |
+			   I2S_XFER_RXS_START,
+			   I2S_XFER_TXS_START |
+			   I2S_XFER_RXS_START);
+}
+
+static int rockchip_i2s_tdm_calibrate_mclk(struct rk_i2s_tdm_dev *i2s_tdm,
+					   struct snd_pcm_substream *substream,
+					   unsigned int lrck_freq)
+{
+	struct clk *mclk_root;
+	struct clk *mclk_parent;
+	/* It's 256 times higher than a high sample rate */
+	unsigned int mclk_parent_freq;
+	int ret;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		mclk_parent = i2s_tdm->mclk_tx_src;
+	else
+		mclk_parent = i2s_tdm->mclk_rx_src;
+
+	switch (lrck_freq) {
+	case 8000:
+	case 16000:
+	case 24000:
+	case 32000:
+	case 48000:
+	case 64000:
+	case 96000:
+	case 192000:
+		mclk_root = i2s_tdm->mclk_root0;
+		mclk_parent_freq = DEFAULT_MCLK_FS * 192000;
+		break;
+	case 11025:
+	case 22050:
+	case 44100:
+	case 88200:
+	case 176400:
+		mclk_root = i2s_tdm->mclk_root1;
+		mclk_parent_freq = DEFAULT_MCLK_FS * 176400;
+		break;
+	default:
+		dev_err(i2s_tdm->dev, "Invalid LRCK freq: %u Hz\n",
+			lrck_freq);
+		return -EINVAL;
+	}
+
+	ret = clk_set_parent(mclk_parent, mclk_root);
+	if (ret < 0) {
+		dev_err(i2s_tdm->dev, "parent: %s set root: %s failed: %d\n",
+			__clk_get_name(mclk_parent),
+			__clk_get_name(mclk_root),
+			ret);
+		goto out;
+	}
+
+	ret = clk_set_rate(mclk_parent, mclk_parent_freq);
+	if (ret < 0) {
+		dev_err(i2s_tdm->dev, "parent: %s set freq: %d failed: %d\n",
+			__clk_get_name(mclk_parent),
+			mclk_parent_freq,
+			ret);
+		goto out;
+	}
+
+out:
+	return ret;
+}
+
+static int rockchip_i2s_tdm_set_mclk(struct rk_i2s_tdm_dev *i2s_tdm,
+				     struct snd_pcm_substream *substream,
+				     struct clk **mclk)
+{
+	unsigned int mclk_freq;
+	int ret;
+
+	if (i2s_tdm->clk_trcm) {
+		if (i2s_tdm->mclk_tx_freq != i2s_tdm->mclk_rx_freq) {
+			dev_err(i2s_tdm->dev,
+				"clk_trcm, tx: %d and rx: %d should be same\n",
+				i2s_tdm->mclk_tx_freq,
+				i2s_tdm->mclk_rx_freq);
+			ret = -EINVAL;
+			goto err;
+		}
+
+		ret = clk_set_rate(i2s_tdm->mclk_tx, i2s_tdm->mclk_tx_freq);
+		if (ret < 0) {
+			dev_err(i2s_tdm->dev,
+				"Set mclk_tx: %s freq: %d failed: %d\n",
+				__clk_get_name(i2s_tdm->mclk_tx),
+				i2s_tdm->mclk_tx_freq, ret);
+			goto err;
+		}
+
+		ret = clk_set_rate(i2s_tdm->mclk_rx, i2s_tdm->mclk_rx_freq);
+		if (ret < 0) {
+			dev_err(i2s_tdm->dev,
+				"Set mclk_rx: %s freq: %d failed: %d\n",
+				__clk_get_name(i2s_tdm->mclk_rx),
+				i2s_tdm->mclk_rx_freq, ret);
+			goto err;
+		}
+
+		/* Using mclk_rx is ok. */
+		*mclk = i2s_tdm->mclk_tx;
+	} else {
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			*mclk = i2s_tdm->mclk_tx;
+			mclk_freq = i2s_tdm->mclk_tx_freq;
+		} else {
+			*mclk = i2s_tdm->mclk_rx;
+			mclk_freq = i2s_tdm->mclk_rx_freq;
+		}
+
+		ret = clk_set_rate(*mclk, mclk_freq);
+		if (ret < 0) {
+			dev_err(i2s_tdm->dev, "Set mclk_%s: %s freq: %d failed: %d\n",
+				substream->stream ? "rx" : "tx",
+				__clk_get_name(*mclk), mclk_freq, ret);
+			goto err;
+		}
+	}
+
+	return 0;
+
+err:
+	return ret;
+}
+
+static int rockchip_i2s_tdm_hw_params(struct snd_pcm_substream *substream,
+				      struct snd_pcm_hw_params *params,
+				      struct snd_soc_dai *dai)
+{
+	struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
+	struct clk *mclk;
+	int ret = 0;
+	unsigned int val = 0;
+	unsigned int mclk_rate, bclk_rate, div_bclk, div_lrck;
+
+	if (i2s_tdm->mclk_calibrate)
+		rockchip_i2s_tdm_calibrate_mclk(i2s_tdm, substream,
+						params_rate(params));
+
+	ret = rockchip_i2s_tdm_set_mclk(i2s_tdm, substream, &mclk);
+	if (ret)
+		return ret;
+
+	if (i2s_tdm->clk_trcm) {
+		spin_lock(&i2s_tdm->lock);
+		if (atomic_read(&i2s_tdm->refcount))
+			rockchip_i2s_tdm_xfer_pause(substream, i2s_tdm);
+	}
+
+	if (i2s_tdm->is_master_mode) {
+		mclk_rate = clk_get_rate(mclk);
+		bclk_rate = i2s_tdm->bclk_fs * params_rate(params);
+		if (!bclk_rate) {
+			ret = -EINVAL;
+			goto err;
+		}
+		div_bclk = DIV_ROUND_CLOSEST(mclk_rate, bclk_rate);
+		div_lrck = bclk_rate / params_rate(params);
+		if (i2s_tdm->clk_trcm) {
+			regmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,
+					   I2S_CLKDIV_TXM_MASK | I2S_CLKDIV_RXM_MASK,
+					   I2S_CLKDIV_TXM(div_bclk) | I2S_CLKDIV_RXM(div_bclk));
+			regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
+					   I2S_CKR_TSD_MASK | I2S_CKR_RSD_MASK,
+					   I2S_CKR_TSD(div_lrck) | I2S_CKR_RSD(div_lrck));
+		} else if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			regmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,
+					   I2S_CLKDIV_TXM_MASK,
+					   I2S_CLKDIV_TXM(div_bclk));
+			regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
+					   I2S_CKR_TSD_MASK,
+					   I2S_CKR_TSD(div_lrck));
+		} else {
+			regmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,
+					   I2S_CLKDIV_RXM_MASK,
+					   I2S_CLKDIV_RXM(div_bclk));
+			regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
+					   I2S_CKR_RSD_MASK,
+					   I2S_CKR_RSD(div_lrck));
+		}
+	}
+
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S8:
+		val |= I2S_TXCR_VDW(8);
+		break;
+	case SNDRV_PCM_FORMAT_S16_LE:
+		val |= I2S_TXCR_VDW(16);
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+		val |= I2S_TXCR_VDW(20);
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		val |= I2S_TXCR_VDW(24);
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		val |= I2S_TXCR_VDW(32);
+		break;
+	default:
+		ret = -EINVAL;
+		goto err;
+	}
+
+	switch (params_channels(params)) {
+	case 8:
+		val |= I2S_CHN_8;
+		break;
+	case 6:
+		val |= I2S_CHN_6;
+		break;
+	case 4:
+		val |= I2S_CHN_4;
+		break;
+	case 2:
+		val |= I2S_CHN_2;
+		break;
+	default:
+		dev_err(i2s_tdm->dev, "invalid channel: %d\n",
+			params_channels(params));
+		ret = -EINVAL;
+		goto err;
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+		regmap_update_bits(i2s_tdm->regmap, I2S_RXCR,
+				   I2S_RXCR_VDW_MASK | I2S_RXCR_CSR_MASK,
+				   val);
+	else
+		regmap_update_bits(i2s_tdm->regmap, I2S_TXCR,
+				   I2S_TXCR_VDW_MASK | I2S_TXCR_CSR_MASK,
+				   val);
+
+	if (i2s_tdm->io_multiplex) {
+		int usable_chs = MULTIPLEX_CH_MAX;
+
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+			struct snd_pcm_str *playback_str =
+				&substream->pcm->streams[SNDRV_PCM_STREAM_PLAYBACK];
+
+			if (playback_str->substream_opened) {
+				regmap_read(i2s_tdm->regmap, I2S_TXCR, &val);
+				val &= I2S_TXCR_CSR_MASK;
+				usable_chs = MULTIPLEX_CH_MAX - to_ch_num(val);
+			}
+
+			regmap_read(i2s_tdm->regmap, I2S_RXCR, &val);
+			val &= I2S_RXCR_CSR_MASK;
+
+			if (to_ch_num(val) > usable_chs) {
+				dev_err(i2s_tdm->dev,
+					"Capture chs(%d) > usable chs(%d)\n",
+					to_ch_num(val), usable_chs);
+				ret = -EINVAL;
+				goto err;
+			}
+
+			switch (val) {
+			case I2S_CHN_4:
+				val = I2S_IO_6CH_OUT_4CH_IN;
+				break;
+			case I2S_CHN_6:
+				val = I2S_IO_4CH_OUT_6CH_IN;
+				break;
+			case I2S_CHN_8:
+				val = I2S_IO_2CH_OUT_8CH_IN;
+				break;
+			default:
+				val = I2S_IO_8CH_OUT_2CH_IN;
+				break;
+			}
+		} else {
+			struct snd_pcm_str *capture_str =
+				&substream->pcm->streams[SNDRV_PCM_STREAM_CAPTURE];
+
+			if (capture_str->substream_opened) {
+				regmap_read(i2s_tdm->regmap, I2S_RXCR, &val);
+				val &= I2S_RXCR_CSR_MASK;
+				usable_chs = MULTIPLEX_CH_MAX - to_ch_num(val);
+			}
+
+			regmap_read(i2s_tdm->regmap, I2S_TXCR, &val);
+			val &= I2S_TXCR_CSR_MASK;
+
+			if (to_ch_num(val) > usable_chs) {
+				dev_err(i2s_tdm->dev,
+					"Playback chs(%d) > usable chs(%d)\n",
+					to_ch_num(val), usable_chs);
+				ret = -EINVAL;
+				goto err;
+			}
+
+			switch (val) {
+			case I2S_CHN_4:
+				val = I2S_IO_4CH_OUT_6CH_IN;
+				break;
+			case I2S_CHN_6:
+				val = I2S_IO_6CH_OUT_4CH_IN;
+				break;
+			case I2S_CHN_8:
+				val = I2S_IO_8CH_OUT_2CH_IN;
+				break;
+			default:
+				val = I2S_IO_2CH_OUT_8CH_IN;
+				break;
+			}
+		}
+
+		val <<= i2s_tdm->soc_data->grf_shift;
+		val |= (I2S_IO_DIRECTION_MASK << i2s_tdm->soc_data->grf_shift) << 16;
+		regmap_write(i2s_tdm->grf, i2s_tdm->soc_data->grf_reg_offset, val);
+	}
+
+	regmap_update_bits(i2s_tdm->regmap, I2S_DMACR, I2S_DMACR_TDL_MASK,
+			   I2S_DMACR_TDL(16));
+	regmap_update_bits(i2s_tdm->regmap, I2S_DMACR, I2S_DMACR_RDL_MASK,
+			   I2S_DMACR_RDL(16));
+
+	if (i2s_tdm->clk_trcm) {
+		if (atomic_read(&i2s_tdm->refcount))
+			rockchip_i2s_tdm_xfer_resume(substream, i2s_tdm);
+		spin_unlock(&i2s_tdm->lock);
+	}
+
+	return 0;
+
+err:
+	if (i2s_tdm->clk_trcm)
+		spin_unlock(&i2s_tdm->lock);
+	return ret;
+}
+
+static int rockchip_i2s_tdm_trigger(struct snd_pcm_substream *substream,
+				    int cmd, struct snd_soc_dai *dai)
+{
+	struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (i2s_tdm->clk_trcm)
+			rockchip_snd_txrxctrl(substream, dai, 1);
+		else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+			rockchip_snd_rxctrl(i2s_tdm, 1);
+		else
+			rockchip_snd_txctrl(i2s_tdm, 1);
+		break;
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (i2s_tdm->clk_trcm)
+			rockchip_snd_txrxctrl(substream, dai, 0);
+		else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+			rockchip_snd_rxctrl(i2s_tdm, 0);
+		else
+			rockchip_snd_txctrl(i2s_tdm, 0);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static int rockchip_i2s_tdm_set_sysclk(struct snd_soc_dai *cpu_dai, int stream,
+				       unsigned int freq, int dir)
+{
+	struct rk_i2s_tdm_dev *i2s_tdm = to_info(cpu_dai);
+
+	/* Put set mclk rate into rockchip_i2s_tdm_set_mclk() */
+	if (i2s_tdm->clk_trcm) {
+		i2s_tdm->mclk_tx_freq = freq;
+		i2s_tdm->mclk_rx_freq = freq;
+	} else {
+		if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+			i2s_tdm->mclk_tx_freq = freq;
+		else
+			i2s_tdm->mclk_rx_freq = freq;
+	}
+
+	dev_dbg(i2s_tdm->dev, "The target mclk_%s freq is: %d\n",
+		stream ? "rx" : "tx", freq);
+
+	return 0;
+}
+
+static int rockchip_i2s_tdm_dai_probe(struct snd_soc_dai *dai)
+{
+	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+
+	dai->capture_dma_data = &i2s_tdm->capture_dma_data;
+	dai->playback_dma_data = &i2s_tdm->playback_dma_data;
+
+	return 0;
+}
+
+static int rockchip_dai_tdm_slot(struct snd_soc_dai *dai,
+				 unsigned int tx_mask, unsigned int rx_mask,
+				 int slots, int slot_width)
+{
+	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+	unsigned int mask, val;
+
+	i2s_tdm->tdm_mode = true;
+	i2s_tdm->bclk_fs = slots * slot_width;
+	mask = TDM_SLOT_BIT_WIDTH_MSK | TDM_FRAME_WIDTH_MSK;
+	val = TDM_SLOT_BIT_WIDTH(slot_width) |
+	      TDM_FRAME_WIDTH(slots * slot_width);
+	regmap_update_bits(i2s_tdm->regmap, I2S_TDM_TXCR,
+			   mask, val);
+	regmap_update_bits(i2s_tdm->regmap, I2S_TDM_RXCR,
+			   mask, val);
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops rockchip_i2s_tdm_dai_ops = {
+	.hw_params = rockchip_i2s_tdm_hw_params,
+	.set_sysclk = rockchip_i2s_tdm_set_sysclk,
+	.set_fmt = rockchip_i2s_tdm_set_fmt,
+	.set_tdm_slot = rockchip_dai_tdm_slot,
+	.trigger = rockchip_i2s_tdm_trigger,
+};
+
+static const struct snd_soc_component_driver rockchip_i2s_tdm_component = {
+	.name = DRV_NAME,
+};
+
+static bool rockchip_i2s_tdm_wr_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case I2S_TXCR:
+	case I2S_RXCR:
+	case I2S_CKR:
+	case I2S_DMACR:
+	case I2S_INTCR:
+	case I2S_XFER:
+	case I2S_CLR:
+	case I2S_TXDR:
+	case I2S_TDM_TXCR:
+	case I2S_TDM_RXCR:
+	case I2S_CLKDIV:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool rockchip_i2s_tdm_rd_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case I2S_TXCR:
+	case I2S_RXCR:
+	case I2S_CKR:
+	case I2S_DMACR:
+	case I2S_INTCR:
+	case I2S_XFER:
+	case I2S_CLR:
+	case I2S_TXDR:
+	case I2S_RXDR:
+	case I2S_TXFIFOLR:
+	case I2S_INTSR:
+	case I2S_RXFIFOLR:
+	case I2S_TDM_TXCR:
+	case I2S_TDM_RXCR:
+	case I2S_CLKDIV:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool rockchip_i2s_tdm_volatile_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case I2S_TXFIFOLR:
+	case I2S_INTSR:
+	case I2S_CLR:
+	case I2S_TXDR:
+	case I2S_RXDR:
+	case I2S_RXFIFOLR:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool rockchip_i2s_tdm_precious_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case I2S_RXDR:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static const struct reg_default rockchip_i2s_tdm_reg_defaults[] = {
+	{0x00, 0x7200000f},
+	{0x04, 0x01c8000f},
+	{0x08, 0x00001f1f},
+	{0x10, 0x001f0000},
+	{0x14, 0x01f00000},
+	{0x30, 0x00003eff},
+	{0x34, 0x00003eff},
+	{0x38, 0x00000707},
+};
+
+static const struct regmap_config rockchip_i2s_tdm_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = I2S_CLKDIV,
+	.reg_defaults = rockchip_i2s_tdm_reg_defaults,
+	.num_reg_defaults = ARRAY_SIZE(rockchip_i2s_tdm_reg_defaults),
+	.writeable_reg = rockchip_i2s_tdm_wr_reg,
+	.readable_reg = rockchip_i2s_tdm_rd_reg,
+	.volatile_reg = rockchip_i2s_tdm_volatile_reg,
+	.precious_reg = rockchip_i2s_tdm_precious_reg,
+	.cache_type = REGCACHE_FLAT,
+};
+
+static int common_soc_init(struct device *dev, u32 addr)
+{
+	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+	const struct txrx_config *configs = i2s_tdm->soc_data->configs;
+	u32 reg = 0, val = 0, trcm = i2s_tdm->clk_trcm;
+	int i;
+
+	switch (trcm) {
+	case I2S_CKR_TRCM_TXONLY:
+		/* fall through */
+	case I2S_CKR_TRCM_RXONLY:
+		break;
+	default:
+		return 0;
+	}
+
+	for (i = 0; i < i2s_tdm->soc_data->config_count; i++) {
+		if (addr != configs[i].addr)
+			continue;
+		reg = configs[i].reg;
+		if (trcm == I2S_CKR_TRCM_TXONLY)
+			val = configs[i].txonly;
+		else
+			val = configs[i].rxonly;
+	}
+
+	if (reg)
+		regmap_write(i2s_tdm->grf, reg, val);
+
+	return 0;
+}
+
+static const struct txrx_config px30_txrx_config[] = {
+	{ 0xff060000, 0x184, PX30_I2S0_CLK_TXONLY, PX30_I2S0_CLK_RXONLY },
+};
+
+static const struct txrx_config rk1808_txrx_config[] = {
+	{ 0xff7e0000, 0x190, RK1808_I2S0_CLK_TXONLY, RK1808_I2S0_CLK_RXONLY },
+};
+
+static const struct txrx_config rk3308_txrx_config[] = {
+	{ 0xff300000, 0x308, RK3308_I2S0_CLK_TXONLY, RK3308_I2S0_CLK_RXONLY },
+	{ 0xff310000, 0x308, RK3308_I2S1_CLK_TXONLY, RK3308_I2S1_CLK_RXONLY },
+};
+
+static struct rk_i2s_soc_data px30_i2s_soc_data = {
+	.softrst_offset = 0x0300,
+	.configs = px30_txrx_config,
+	.config_count = ARRAY_SIZE(px30_txrx_config),
+	.init = common_soc_init,
+};
+
+static struct rk_i2s_soc_data rk1808_i2s_soc_data = {
+	.softrst_offset = 0x0300,
+	.configs = rk1808_txrx_config,
+	.config_count = ARRAY_SIZE(rk1808_txrx_config),
+	.init = common_soc_init,
+};
+
+static struct rk_i2s_soc_data rk3308_i2s_soc_data = {
+	.softrst_offset = 0x0400,
+	.grf_reg_offset = 0x0308,
+	.grf_shift = 5,
+	.configs = rk3308_txrx_config,
+	.config_count = ARRAY_SIZE(rk3308_txrx_config),
+	.init = common_soc_init,
+};
+
+static const struct of_device_id rockchip_i2s_tdm_match[] = {
+	{ .compatible = "rockchip,px30-i2s-tdm", .data = &px30_i2s_soc_data },
+	{ .compatible = "rockchip,rk1808-i2s-tdm", .data = &rk1808_i2s_soc_data },
+	{ .compatible = "rockchip,rk3308-i2s-tdm", .data = &rk3308_i2s_soc_data },
+	{},
+};
+
+static int of_i2s_resetid_get(struct device_node *node,
+			      const char *id)
+{
+	struct of_phandle_args args;
+	int index = 0;
+	int ret;
+
+	if (id)
+		index = of_property_match_string(node,
+						 "reset-names", id);
+	ret = of_parse_phandle_with_args(node, "resets", "#reset-cells",
+					 index, &args);
+	if (ret)
+		return ret;
+
+	return args.args[0];
+}
+
+static int rockchip_i2s_tdm_dai_prepare(struct platform_device *pdev,
+					struct snd_soc_dai_driver **soc_dai)
+{
+	struct snd_soc_dai_driver rockchip_i2s_tdm_dai = {
+		.probe = rockchip_i2s_tdm_dai_probe,
+		.playback = {
+			.stream_name = "Playback",
+			.channels_min = 2,
+			.channels_max = 8,
+			.rates = SNDRV_PCM_RATE_8000_192000,
+			.formats = (SNDRV_PCM_FMTBIT_S8 |
+				    SNDRV_PCM_FMTBIT_S16_LE |
+				    SNDRV_PCM_FMTBIT_S20_3LE |
+				    SNDRV_PCM_FMTBIT_S24_LE |
+				    SNDRV_PCM_FMTBIT_S32_LE),
+		},
+		.capture = {
+			.stream_name = "Capture",
+			.channels_min = 2,
+			.channels_max = 8,
+			.rates = SNDRV_PCM_RATE_8000_192000,
+			.formats = (SNDRV_PCM_FMTBIT_S8 |
+				    SNDRV_PCM_FMTBIT_S16_LE |
+				    SNDRV_PCM_FMTBIT_S20_3LE |
+				    SNDRV_PCM_FMTBIT_S24_LE |
+				    SNDRV_PCM_FMTBIT_S32_LE),
+		},
+		.ops = &rockchip_i2s_tdm_dai_ops,
+	};
+
+	*soc_dai = devm_kmemdup(&pdev->dev, &rockchip_i2s_tdm_dai,
+				sizeof(rockchip_i2s_tdm_dai), GFP_KERNEL);
+	if (!(*soc_dai)) {
+		dev_err(&pdev->dev, "Failed to duplicate i2s_tdm_dai\n");
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static int rockchip_i2s_tdm_path_check(struct rk_i2s_tdm_dev *i2s_tdm,
+				       int num,
+				       bool is_rx_path)
+{
+	unsigned int *i2s_data;
+	int i, j, ret = 0;
+
+	if (is_rx_path)
+		i2s_data = i2s_tdm->i2s_sdis;
+	else
+		i2s_data = i2s_tdm->i2s_sdos;
+
+	for (i = 0; i < num; i++) {
+		if (i2s_data[i] > CH_GRP_MAX - 1) {
+			dev_err(i2s_tdm->dev,
+				"%s path i2s_data[%d]: %d is overflow, max is: %d\n",
+				is_rx_path ? "RX" : "TX",
+				i, i2s_data[i], CH_GRP_MAX);
+			ret = -EINVAL;
+			goto err;
+		}
+
+		for (j = 0; j < num; j++) {
+			if (i == j)
+				continue;
+
+			if (i2s_data[i] == i2s_data[j]) {
+				dev_err(i2s_tdm->dev,
+					"%s path invalid routed i2s_data: [%d]%d == [%d]%d\n",
+					is_rx_path ? "RX" : "TX",
+					i, i2s_data[i],
+					j, i2s_data[j]);
+				ret = -EINVAL;
+				goto err;
+			}
+		}
+	}
+
+err:
+	return ret;
+}
+
+static void rockchip_i2s_tdm_tx_path_config(struct rk_i2s_tdm_dev *i2s_tdm,
+					    int num)
+{
+	int idx;
+
+	for (idx = 0; idx < num; idx++) {
+		regmap_update_bits(i2s_tdm->regmap, I2S_TXCR,
+				   I2S_TXCR_PATH_MASK(idx),
+				   I2S_TXCR_PATH(idx, i2s_tdm->i2s_sdos[idx]));
+	}
+}
+
+static void rockchip_i2s_tdm_rx_path_config(struct rk_i2s_tdm_dev *i2s_tdm,
+					    int num)
+{
+	int idx;
+
+	for (idx = 0; idx < num; idx++) {
+		regmap_update_bits(i2s_tdm->regmap, I2S_RXCR,
+				   I2S_RXCR_PATH_MASK(idx),
+				   I2S_RXCR_PATH(idx, i2s_tdm->i2s_sdis[idx]));
+	}
+}
+
+static void rockchip_i2s_tdm_path_config(struct rk_i2s_tdm_dev *i2s_tdm,
+					 int num, bool is_rx_path)
+{
+	if (is_rx_path)
+		rockchip_i2s_tdm_rx_path_config(i2s_tdm, num);
+	else
+		rockchip_i2s_tdm_tx_path_config(i2s_tdm, num);
+}
+
+static int rockchip_i2s_tdm_path_prepare(struct rk_i2s_tdm_dev *i2s_tdm,
+					 struct device_node *np,
+					 bool is_rx_path)
+{
+	char *i2s_tx_path_prop = "rockchip,i2s-tx-route";
+	char *i2s_rx_path_prop = "rockchip,i2s-rx-route";
+	char *i2s_path_prop;
+	unsigned int *i2s_data;
+	int num, ret = 0;
+
+	if (is_rx_path) {
+		i2s_path_prop = i2s_rx_path_prop;
+		i2s_data = i2s_tdm->i2s_sdis;
+	} else {
+		i2s_path_prop = i2s_tx_path_prop;
+		i2s_data = i2s_tdm->i2s_sdos;
+	}
+
+	num = of_count_phandle_with_args(np, i2s_path_prop, NULL);
+	if (num < 0) {
+		if (num != -ENOENT) {
+			dev_err(i2s_tdm->dev,
+				"Failed to read '%s' num: %d\n",
+				i2s_path_prop, num);
+			ret = num;
+		}
+		goto out;
+	} else if (num != CH_GRP_MAX) {
+		dev_err(i2s_tdm->dev,
+			"The num: %d should be: %d\n", num, CH_GRP_MAX);
+		ret = -EINVAL;
+		goto out;
+	}
+
+	ret = of_property_read_u32_array(np, i2s_path_prop,
+					 i2s_data, num);
+	if (ret < 0) {
+		dev_err(i2s_tdm->dev,
+			"Failed to read '%s': %d\n",
+			i2s_path_prop, ret);
+		goto out;
+	}
+
+	ret = rockchip_i2s_tdm_path_check(i2s_tdm, num, is_rx_path);
+	if (ret < 0) {
+		dev_err(i2s_tdm->dev,
+			"Failed to check i2s data bus: %d\n", ret);
+		goto out;
+	}
+
+	rockchip_i2s_tdm_path_config(i2s_tdm, num, is_rx_path);
+
+out:
+	return ret;
+}
+
+static int rockchip_i2s_tdm_tx_path_prepare(struct rk_i2s_tdm_dev *i2s_tdm,
+					    struct device_node *np)
+{
+	return rockchip_i2s_tdm_path_prepare(i2s_tdm, np, 0);
+}
+
+static int rockchip_i2s_tdm_rx_path_prepare(struct rk_i2s_tdm_dev *i2s_tdm,
+					    struct device_node *np)
+{
+	return rockchip_i2s_tdm_path_prepare(i2s_tdm, np, 1);
+}
+
+static int rockchip_i2s_tdm_probe(struct platform_device *pdev)
+{
+	struct device_node *node = pdev->dev.of_node;
+	struct device_node *cru_node;
+	const struct of_device_id *of_id;
+	struct rk_i2s_tdm_dev *i2s_tdm;
+	struct snd_soc_dai_driver *soc_dai;
+	struct resource *res;
+	void __iomem *regs;
+	int ret;
+	int val;
+
+	ret = rockchip_i2s_tdm_dai_prepare(pdev, &soc_dai);
+	if (ret < 0)
+		return ret;
+
+	i2s_tdm = devm_kzalloc(&pdev->dev, sizeof(*i2s_tdm), GFP_KERNEL);
+	if (!i2s_tdm)
+		return -ENOMEM;
+
+	i2s_tdm->dev = &pdev->dev;
+
+	of_id = of_match_device(rockchip_i2s_tdm_match, &pdev->dev);
+	if (!of_id || !of_id->data)
+		return -EINVAL;
+
+	spin_lock_init(&i2s_tdm->lock);
+	i2s_tdm->soc_data = (struct rk_i2s_soc_data *)of_id->data;
+
+	i2s_tdm->bclk_fs = 64;
+	if (!of_property_read_u32(node, "rockchip,bclk-fs", &val)) {
+		if ((val >= 32) && (val % 2 == 0))
+			i2s_tdm->bclk_fs = val;
+	}
+
+	i2s_tdm->clk_trcm = I2S_CKR_TRCM_TXRX;
+	if (!of_property_read_u32(node, "rockchip,clk-trcm", &val)) {
+		if (val >= 0 && val <= 2) {
+			i2s_tdm->clk_trcm = val << I2S_CKR_TRCM_SHIFT;
+			if (i2s_tdm->clk_trcm)
+				soc_dai->symmetric_rates = 1;
+		}
+	}
+
+	if (of_property_read_bool(node, "rockchip,playback-only"))
+		soc_dai->capture.channels_min = 0;
+	else if (of_property_read_bool(node, "rockchip,capture-only"))
+		soc_dai->playback.channels_min = 0;
+
+	i2s_tdm->grf = syscon_regmap_lookup_by_phandle(node, "rockchip,grf");
+	if (IS_ERR(i2s_tdm->grf))
+		return PTR_ERR(i2s_tdm->grf);
+
+	if (i2s_tdm->clk_trcm) {
+		cru_node = of_parse_phandle(node, "rockchip,cru", 0);
+		i2s_tdm->cru_base = of_iomap(cru_node, 0);
+		if (!i2s_tdm->cru_base)
+			return -ENOENT;
+
+		i2s_tdm->soc_data->tx_reset_id = of_i2s_resetid_get(node, "tx-m");
+		if (i2s_tdm->soc_data->tx_reset_id < 0)
+			return -EINVAL;
+		i2s_tdm->soc_data->rx_reset_id = of_i2s_resetid_get(node, "rx-m");
+		if (i2s_tdm->soc_data->rx_reset_id < 0)
+			return -EINVAL;
+	}
+
+	i2s_tdm->tx_reset = devm_reset_control_get(&pdev->dev, "tx-m");
+	if (IS_ERR(i2s_tdm->tx_reset)) {
+		ret = PTR_ERR(i2s_tdm->tx_reset);
+		if (ret != -ENOENT)
+			return ret;
+	}
+
+	i2s_tdm->rx_reset = devm_reset_control_get(&pdev->dev, "rx-m");
+	if (IS_ERR(i2s_tdm->rx_reset)) {
+		ret = PTR_ERR(i2s_tdm->rx_reset);
+		if (ret != -ENOENT)
+			return ret;
+	}
+
+	i2s_tdm->hclk = devm_clk_get(&pdev->dev, "hclk");
+	if (IS_ERR(i2s_tdm->hclk))
+		return PTR_ERR(i2s_tdm->hclk);
+
+	ret = clk_prepare_enable(i2s_tdm->hclk);
+	if (ret)
+		return ret;
+
+	i2s_tdm->mclk_tx = devm_clk_get(&pdev->dev, "mclk_tx");
+	if (IS_ERR(i2s_tdm->mclk_tx))
+		return PTR_ERR(i2s_tdm->mclk_tx);
+
+	i2s_tdm->mclk_rx = devm_clk_get(&pdev->dev, "mclk_rx");
+	if (IS_ERR(i2s_tdm->mclk_rx))
+		return PTR_ERR(i2s_tdm->mclk_rx);
+
+	i2s_tdm->io_multiplex =
+		of_property_read_bool(node, "rockchip,io-multiplex");
+
+	i2s_tdm->mclk_calibrate =
+		of_property_read_bool(node, "rockchip,mclk-calibrate");
+	if (i2s_tdm->mclk_calibrate) {
+		i2s_tdm->mclk_tx_src = devm_clk_get(&pdev->dev, "mclk_tx_src");
+		if (IS_ERR(i2s_tdm->mclk_tx_src))
+			return PTR_ERR(i2s_tdm->mclk_tx_src);
+
+		i2s_tdm->mclk_rx_src = devm_clk_get(&pdev->dev, "mclk_rx_src");
+		if (IS_ERR(i2s_tdm->mclk_rx_src))
+			return PTR_ERR(i2s_tdm->mclk_rx_src);
+
+		i2s_tdm->mclk_root0 = devm_clk_get(&pdev->dev, "mclk_root0");
+		if (IS_ERR(i2s_tdm->mclk_root0))
+			return PTR_ERR(i2s_tdm->mclk_root0);
+
+		i2s_tdm->mclk_root1 = devm_clk_get(&pdev->dev, "mclk_root1");
+		if (IS_ERR(i2s_tdm->mclk_root1))
+			return PTR_ERR(i2s_tdm->mclk_root1);
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(regs))
+		return PTR_ERR(regs);
+
+	i2s_tdm->regmap = devm_regmap_init_mmio(&pdev->dev, regs,
+					    &rockchip_i2s_tdm_regmap_config);
+	if (IS_ERR(i2s_tdm->regmap))
+		return PTR_ERR(i2s_tdm->regmap);
+
+	i2s_tdm->playback_dma_data.addr = res->start + I2S_TXDR;
+	i2s_tdm->playback_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	i2s_tdm->playback_dma_data.maxburst = 8;
+
+	i2s_tdm->capture_dma_data.addr = res->start + I2S_RXDR;
+	i2s_tdm->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	i2s_tdm->capture_dma_data.maxburst = 8;
+
+	ret = rockchip_i2s_tdm_tx_path_prepare(i2s_tdm, node);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "I2S TX path prepare failed: %d\n", ret);
+		return ret;
+	}
+
+	ret = rockchip_i2s_tdm_rx_path_prepare(i2s_tdm, node);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "I2S RX path prepare failed: %d\n", ret);
+		return ret;
+	}
+
+	atomic_set(&i2s_tdm->refcount, 0);
+	dev_set_drvdata(&pdev->dev, i2s_tdm);
+
+	pm_runtime_enable(&pdev->dev);
+	if (!pm_runtime_enabled(&pdev->dev)) {
+		ret = i2s_tdm_runtime_resume(&pdev->dev);
+		if (ret)
+			goto err_pm_disable;
+	}
+
+	regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
+			   I2S_CKR_TRCM_MASK, i2s_tdm->clk_trcm);
+
+	if (i2s_tdm->soc_data && i2s_tdm->soc_data->init)
+		i2s_tdm->soc_data->init(&pdev->dev, res->start);
+
+	ret = devm_snd_soc_register_component(&pdev->dev,
+					      &rockchip_i2s_tdm_component,
+					      soc_dai, 1);
+
+	if (ret) {
+		dev_err(&pdev->dev, "Could not register DAI\n");
+		goto err_suspend;
+	}
+
+	if (of_property_read_bool(node, "rockchip,no-dmaengine"))
+		return ret;
+	ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
+	if (ret) {
+		dev_err(&pdev->dev, "Could not register PCM\n");
+		return ret;
+	}
+
+	return 0;
+
+err_suspend:
+	if (!pm_runtime_status_suspended(&pdev->dev))
+		i2s_tdm_runtime_suspend(&pdev->dev);
+err_pm_disable:
+	pm_runtime_disable(&pdev->dev);
+
+	return ret;
+}
+
+static int rockchip_i2s_tdm_remove(struct platform_device *pdev)
+{
+	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(&pdev->dev);
+
+	pm_runtime_disable(&pdev->dev);
+	if (!pm_runtime_status_suspended(&pdev->dev))
+		i2s_tdm_runtime_suspend(&pdev->dev);
+
+	if (!IS_ERR(i2s_tdm->mclk_tx))
+		clk_prepare_enable(i2s_tdm->mclk_tx);
+	if (!IS_ERR(i2s_tdm->mclk_rx))
+		clk_prepare_enable(i2s_tdm->mclk_rx);
+	if (!IS_ERR(i2s_tdm->hclk))
+		clk_disable_unprepare(i2s_tdm->hclk);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int rockchip_i2s_tdm_suspend(struct device *dev)
+{
+	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+
+	regcache_mark_dirty(i2s_tdm->regmap);
+
+	return 0;
+}
+
+static int rockchip_i2s_tdm_resume(struct device *dev)
+{
+	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+	int ret;
+
+	ret = pm_runtime_get_sync(dev);
+	if (ret < 0)
+		return ret;
+	ret = regcache_sync(i2s_tdm->regmap);
+	pm_runtime_put(dev);
+
+	return ret;
+}
+#endif
+
+static const struct dev_pm_ops rockchip_i2s_tdm_pm_ops = {
+	SET_RUNTIME_PM_OPS(i2s_tdm_runtime_suspend, i2s_tdm_runtime_resume,
+			   NULL)
+	SET_SYSTEM_SLEEP_PM_OPS(rockchip_i2s_tdm_suspend,
+				rockchip_i2s_tdm_resume)
+};
+
+static struct platform_driver rockchip_i2s_tdm_driver = {
+	.probe = rockchip_i2s_tdm_probe,
+	.remove = rockchip_i2s_tdm_remove,
+	.driver = {
+		.name = DRV_NAME,
+		.of_match_table = of_match_ptr(rockchip_i2s_tdm_match),
+		.pm = &rockchip_i2s_tdm_pm_ops,
+	},
+};
+module_platform_driver(rockchip_i2s_tdm_driver);
+
+MODULE_DESCRIPTION("ROCKCHIP I2S/TDM ASoC Interface");
+MODULE_AUTHOR("Sugar Zhang <sugar.zhang@rock-chips.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" DRV_NAME);
+MODULE_DEVICE_TABLE(of, rockchip_i2s_tdm_match);
Index: linux-5.10.27/sound/soc/rockchip/rockchip_i2s_tdm.h
===================================================================
--- /dev/null
+++ linux-5.10.27/sound/soc/rockchip/rockchip_i2s_tdm.h
@@ -0,0 +1,388 @@
+/*
+ * sound/soc/rockchip/rockchip_i2s_tdm.h
+ *
+ * ALSA SoC Audio Layer - Rockchip I2S_TDM Controller driver
+ *
+ * Copyright (c) 2018 Rockchip Electronics Co. Ltd.
+ * Author: Sugar Zhang <sugar.zhang@rock-chips.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _ROCKCHIP_I2S_TDM_H
+#define _ROCKCHIP_I2S_TDM_H
+
+/*
+ * TXCR
+ * transmit operation control register
+ */
+#define I2S_TXCR_PATH_SHIFT(x)	(23 + (x) * 2)
+#define I2S_TXCR_PATH_MASK(x)	(0x3 << I2S_TXCR_PATH_SHIFT(x))
+#define I2S_TXCR_PATH(x, v)	((v) << I2S_TXCR_PATH_SHIFT(x))
+#define I2S_TXCR_RCNT_SHIFT	17
+#define I2S_TXCR_RCNT_MASK	(0x3f << I2S_TXCR_RCNT_SHIFT)
+#define I2S_TXCR_CSR_SHIFT	15
+#define I2S_TXCR_CSR(x)		(x << I2S_TXCR_CSR_SHIFT)
+#define I2S_TXCR_CSR_MASK	(3 << I2S_TXCR_CSR_SHIFT)
+#define I2S_TXCR_HWT		BIT(14)
+#define I2S_TXCR_SJM_SHIFT	12
+#define I2S_TXCR_SJM_R		(0 << I2S_TXCR_SJM_SHIFT)
+#define I2S_TXCR_SJM_L		(1 << I2S_TXCR_SJM_SHIFT)
+#define I2S_TXCR_FBM_SHIFT	11
+#define I2S_TXCR_FBM_MSB	(0 << I2S_TXCR_FBM_SHIFT)
+#define I2S_TXCR_FBM_LSB	(1 << I2S_TXCR_FBM_SHIFT)
+#define I2S_TXCR_IBM_SHIFT	9
+#define I2S_TXCR_IBM_NORMAL	(0 << I2S_TXCR_IBM_SHIFT)
+#define I2S_TXCR_IBM_LSJM	(1 << I2S_TXCR_IBM_SHIFT)
+#define I2S_TXCR_IBM_RSJM	(2 << I2S_TXCR_IBM_SHIFT)
+#define I2S_TXCR_IBM_MASK	(3 << I2S_TXCR_IBM_SHIFT)
+#define I2S_TXCR_PBM_SHIFT	7
+#define I2S_TXCR_PBM_MODE(x)	(x << I2S_TXCR_PBM_SHIFT)
+#define I2S_TXCR_PBM_MASK	(3 << I2S_TXCR_PBM_SHIFT)
+#define I2S_TXCR_TFS_SHIFT	5
+#define I2S_TXCR_TFS_I2S	(0 << I2S_TXCR_TFS_SHIFT)
+#define I2S_TXCR_TFS_PCM	(1 << I2S_TXCR_TFS_SHIFT)
+#define I2S_TXCR_TFS_TDM_PCM	(2 << I2S_TXCR_TFS_SHIFT)
+#define I2S_TXCR_TFS_TDM_I2S	(3 << I2S_TXCR_TFS_SHIFT)
+#define I2S_TXCR_TFS_MASK	(3 << I2S_TXCR_TFS_SHIFT)
+#define I2S_TXCR_VDW_SHIFT	0
+#define I2S_TXCR_VDW(x)		((x - 1) << I2S_TXCR_VDW_SHIFT)
+#define I2S_TXCR_VDW_MASK	(0x1f << I2S_TXCR_VDW_SHIFT)
+
+/*
+ * RXCR
+ * receive operation control register
+ */
+#define I2S_RXCR_PATH_SHIFT(x)	(17 + (x) * 2)
+#define I2S_RXCR_PATH_MASK(x)	(0x3 << I2S_RXCR_PATH_SHIFT(x))
+#define I2S_RXCR_PATH(x, v)	((v) << I2S_RXCR_PATH_SHIFT(x))
+#define I2S_RXCR_CSR_SHIFT	15
+#define I2S_RXCR_CSR(x)		(x << I2S_RXCR_CSR_SHIFT)
+#define I2S_RXCR_CSR_MASK	(3 << I2S_RXCR_CSR_SHIFT)
+#define I2S_RXCR_HWT		BIT(14)
+#define I2S_RXCR_SJM_SHIFT	12
+#define I2S_RXCR_SJM_R		(0 << I2S_RXCR_SJM_SHIFT)
+#define I2S_RXCR_SJM_L		(1 << I2S_RXCR_SJM_SHIFT)
+#define I2S_RXCR_FBM_SHIFT	11
+#define I2S_RXCR_FBM_MSB	(0 << I2S_RXCR_FBM_SHIFT)
+#define I2S_RXCR_FBM_LSB	(1 << I2S_RXCR_FBM_SHIFT)
+#define I2S_RXCR_IBM_SHIFT	9
+#define I2S_RXCR_IBM_NORMAL	(0 << I2S_RXCR_IBM_SHIFT)
+#define I2S_RXCR_IBM_LSJM	(1 << I2S_RXCR_IBM_SHIFT)
+#define I2S_RXCR_IBM_RSJM	(2 << I2S_RXCR_IBM_SHIFT)
+#define I2S_RXCR_IBM_MASK	(3 << I2S_RXCR_IBM_SHIFT)
+#define I2S_RXCR_PBM_SHIFT	7
+#define I2S_RXCR_PBM_MODE(x)	(x << I2S_RXCR_PBM_SHIFT)
+#define I2S_RXCR_PBM_MASK	(3 << I2S_RXCR_PBM_SHIFT)
+#define I2S_RXCR_TFS_SHIFT	5
+#define I2S_RXCR_TFS_I2S	(0 << I2S_RXCR_TFS_SHIFT)
+#define I2S_RXCR_TFS_PCM	(1 << I2S_RXCR_TFS_SHIFT)
+#define I2S_RXCR_TFS_TDM_PCM	(2 << I2S_RXCR_TFS_SHIFT)
+#define I2S_RXCR_TFS_TDM_I2S	(3 << I2S_RXCR_TFS_SHIFT)
+#define I2S_RXCR_TFS_MASK	(3 << I2S_RXCR_TFS_SHIFT)
+#define I2S_RXCR_VDW_SHIFT	0
+#define I2S_RXCR_VDW(x)		((x - 1) << I2S_RXCR_VDW_SHIFT)
+#define I2S_RXCR_VDW_MASK	(0x1f << I2S_RXCR_VDW_SHIFT)
+
+/*
+ * CKR
+ * clock generation register
+ */
+#define I2S_CKR_TRCM_SHIFT	28
+#define I2S_CKR_TRCM(x)	(x << I2S_CKR_TRCM_SHIFT)
+#define I2S_CKR_TRCM_TXRX	(0 << I2S_CKR_TRCM_SHIFT)
+#define I2S_CKR_TRCM_TXONLY	(1 << I2S_CKR_TRCM_SHIFT)
+#define I2S_CKR_TRCM_RXONLY	(2 << I2S_CKR_TRCM_SHIFT)
+#define I2S_CKR_TRCM_MASK	(3 << I2S_CKR_TRCM_SHIFT)
+#define I2S_CKR_MSS_SHIFT	27
+#define I2S_CKR_MSS_MASTER	(0 << I2S_CKR_MSS_SHIFT)
+#define I2S_CKR_MSS_SLAVE	(1 << I2S_CKR_MSS_SHIFT)
+#define I2S_CKR_MSS_MASK	(1 << I2S_CKR_MSS_SHIFT)
+#define I2S_CKR_CKP_SHIFT	26
+#define I2S_CKR_CKP_NEG		(0 << I2S_CKR_CKP_SHIFT)
+#define I2S_CKR_CKP_POS		(1 << I2S_CKR_CKP_SHIFT)
+#define I2S_CKR_CKP_MASK	(1 << I2S_CKR_CKP_SHIFT)
+#define I2S_CKR_RLP_SHIFT	25
+#define I2S_CKR_RLP_NORMAL	(0 << I2S_CKR_RLP_SHIFT)
+#define I2S_CKR_RLP_OPPSITE	(1 << I2S_CKR_RLP_SHIFT)
+#define I2S_CKR_TLP_SHIFT	24
+#define I2S_CKR_TLP_NORMAL	(0 << I2S_CKR_TLP_SHIFT)
+#define I2S_CKR_TLP_OPPSITE	(1 << I2S_CKR_TLP_SHIFT)
+#define I2S_CKR_MDIV_SHIFT	16
+#define I2S_CKR_MDIV(x)		((x - 1) << I2S_CKR_MDIV_SHIFT)
+#define I2S_CKR_MDIV_MASK	(0xff << I2S_CKR_MDIV_SHIFT)
+#define I2S_CKR_RSD_SHIFT	8
+#define I2S_CKR_RSD(x)		((x - 1) << I2S_CKR_RSD_SHIFT)
+#define I2S_CKR_RSD_MASK	(0xff << I2S_CKR_RSD_SHIFT)
+#define I2S_CKR_TSD_SHIFT	0
+#define I2S_CKR_TSD(x)		((x - 1) << I2S_CKR_TSD_SHIFT)
+#define I2S_CKR_TSD_MASK	(0xff << I2S_CKR_TSD_SHIFT)
+
+/*
+ * FIFOLR
+ * FIFO level register
+ */
+#define I2S_FIFOLR_RFL_SHIFT	24
+#define I2S_FIFOLR_RFL_MASK	(0x3f << I2S_FIFOLR_RFL_SHIFT)
+#define I2S_FIFOLR_TFL3_SHIFT	18
+#define I2S_FIFOLR_TFL3_MASK	(0x3f << I2S_FIFOLR_TFL3_SHIFT)
+#define I2S_FIFOLR_TFL2_SHIFT	12
+#define I2S_FIFOLR_TFL2_MASK	(0x3f << I2S_FIFOLR_TFL2_SHIFT)
+#define I2S_FIFOLR_TFL1_SHIFT	6
+#define I2S_FIFOLR_TFL1_MASK	(0x3f << I2S_FIFOLR_TFL1_SHIFT)
+#define I2S_FIFOLR_TFL0_SHIFT	0
+#define I2S_FIFOLR_TFL0_MASK	(0x3f << I2S_FIFOLR_TFL0_SHIFT)
+
+/*
+ * DMACR
+ * DMA control register
+ */
+#define I2S_DMACR_RDE_SHIFT	24
+#define I2S_DMACR_RDE_DISABLE	(0 << I2S_DMACR_RDE_SHIFT)
+#define I2S_DMACR_RDE_ENABLE	(1 << I2S_DMACR_RDE_SHIFT)
+#define I2S_DMACR_RDL_SHIFT	16
+#define I2S_DMACR_RDL(x)	((x - 1) << I2S_DMACR_RDL_SHIFT)
+#define I2S_DMACR_RDL_MASK	(0x1f << I2S_DMACR_RDL_SHIFT)
+#define I2S_DMACR_TDE_SHIFT	8
+#define I2S_DMACR_TDE_DISABLE	(0 << I2S_DMACR_TDE_SHIFT)
+#define I2S_DMACR_TDE_ENABLE	(1 << I2S_DMACR_TDE_SHIFT)
+#define I2S_DMACR_TDL_SHIFT	0
+#define I2S_DMACR_TDL(x)	((x) << I2S_DMACR_TDL_SHIFT)
+#define I2S_DMACR_TDL_MASK	(0x1f << I2S_DMACR_TDL_SHIFT)
+
+/*
+ * INTCR
+ * interrupt control register
+ */
+#define I2S_INTCR_RFT_SHIFT	20
+#define I2S_INTCR_RFT(x)	((x - 1) << I2S_INTCR_RFT_SHIFT)
+#define I2S_INTCR_RXOIC		BIT(18)
+#define I2S_INTCR_RXOIE_SHIFT	17
+#define I2S_INTCR_RXOIE_DISABLE	(0 << I2S_INTCR_RXOIE_SHIFT)
+#define I2S_INTCR_RXOIE_ENABLE	(1 << I2S_INTCR_RXOIE_SHIFT)
+#define I2S_INTCR_RXFIE_SHIFT	16
+#define I2S_INTCR_RXFIE_DISABLE	(0 << I2S_INTCR_RXFIE_SHIFT)
+#define I2S_INTCR_RXFIE_ENABLE	(1 << I2S_INTCR_RXFIE_SHIFT)
+#define I2S_INTCR_TFT_SHIFT	4
+#define I2S_INTCR_TFT(x)	((x - 1) << I2S_INTCR_TFT_SHIFT)
+#define I2S_INTCR_TFT_MASK	(0x1f << I2S_INTCR_TFT_SHIFT)
+#define I2S_INTCR_TXUIC		BIT(2)
+#define I2S_INTCR_TXUIE_SHIFT	1
+#define I2S_INTCR_TXUIE_DISABLE	(0 << I2S_INTCR_TXUIE_SHIFT)
+#define I2S_INTCR_TXUIE_ENABLE	(1 << I2S_INTCR_TXUIE_SHIFT)
+
+/*
+ * INTSR
+ * interrupt status register
+ */
+#define I2S_INTSR_TXEIE_SHIFT	0
+#define I2S_INTSR_TXEIE_DISABLE	(0 << I2S_INTSR_TXEIE_SHIFT)
+#define I2S_INTSR_TXEIE_ENABLE	(1 << I2S_INTSR_TXEIE_SHIFT)
+#define I2S_INTSR_RXOI_SHIFT	17
+#define I2S_INTSR_RXOI_INA	(0 << I2S_INTSR_RXOI_SHIFT)
+#define I2S_INTSR_RXOI_ACT	(1 << I2S_INTSR_RXOI_SHIFT)
+#define I2S_INTSR_RXFI_SHIFT	16
+#define I2S_INTSR_RXFI_INA	(0 << I2S_INTSR_RXFI_SHIFT)
+#define I2S_INTSR_RXFI_ACT	(1 << I2S_INTSR_RXFI_SHIFT)
+#define I2S_INTSR_TXUI_SHIFT	1
+#define I2S_INTSR_TXUI_INA	(0 << I2S_INTSR_TXUI_SHIFT)
+#define I2S_INTSR_TXUI_ACT	(1 << I2S_INTSR_TXUI_SHIFT)
+#define I2S_INTSR_TXEI_SHIFT	0
+#define I2S_INTSR_TXEI_INA	(0 << I2S_INTSR_TXEI_SHIFT)
+#define I2S_INTSR_TXEI_ACT	(1 << I2S_INTSR_TXEI_SHIFT)
+
+/*
+ * XFER
+ * Transfer start register
+ */
+#define I2S_XFER_RXS_SHIFT	1
+#define I2S_XFER_RXS_STOP	(0 << I2S_XFER_RXS_SHIFT)
+#define I2S_XFER_RXS_START	(1 << I2S_XFER_RXS_SHIFT)
+#define I2S_XFER_TXS_SHIFT	0
+#define I2S_XFER_TXS_STOP	(0 << I2S_XFER_TXS_SHIFT)
+#define I2S_XFER_TXS_START	(1 << I2S_XFER_TXS_SHIFT)
+
+/*
+ * CLR
+ * clear SCLK domain logic register
+ */
+#define I2S_CLR_RXC	BIT(1)
+#define I2S_CLR_TXC	BIT(0)
+
+/*
+ * TXDR
+ * Transimt FIFO data register, write only.
+ */
+#define I2S_TXDR_MASK	(0xff)
+
+/*
+ * RXDR
+ * Receive FIFO data register, write only.
+ */
+#define I2S_RXDR_MASK	(0xff)
+
+/*
+ * TDM_CTRL
+ * TDM ctrl register
+ */
+#define TDM_FSYNC_WIDTH_SEL1_MSK	GENMASK(20, 18)
+#define TDM_FSYNC_WIDTH_SEL1(x)		((x - 1) << 18)
+#define TDM_FSYNC_WIDTH_SEL0_MSK	BIT(17)
+#define TDM_FSYNC_WIDTH_HALF_FRAME	0
+#define TDM_FSYNC_WIDTH_ONE_FRAME	BIT(17)
+#define TDM_SHIFT_CTRL_MSK		GENMASK(16, 14)
+#define TDM_SHIFT_CTRL(x)		((x) << 14)
+#define TDM_SLOT_BIT_WIDTH_MSK		GENMASK(13, 9)
+#define TDM_SLOT_BIT_WIDTH(x)		((x - 1) << 9)
+#define TDM_FRAME_WIDTH_MSK		GENMASK(8, 0)
+#define TDM_FRAME_WIDTH(x)		((x - 1) << 0)
+
+/*
+ * CLKDIV
+ * Mclk div register
+ */
+#define I2S_CLKDIV_TXM_SHIFT	0
+#define I2S_CLKDIV_TXM(x)		((x - 1) << I2S_CLKDIV_TXM_SHIFT)
+#define I2S_CLKDIV_TXM_MASK	(0xff << I2S_CLKDIV_TXM_SHIFT)
+#define I2S_CLKDIV_RXM_SHIFT	8
+#define I2S_CLKDIV_RXM(x)		((x - 1) << I2S_CLKDIV_RXM_SHIFT)
+#define I2S_CLKDIV_RXM_MASK	(0xff << I2S_CLKDIV_RXM_SHIFT)
+
+/* Clock divider id */
+enum {
+	ROCKCHIP_DIV_MCLK = 0,
+	ROCKCHIP_DIV_BCLK,
+};
+
+/* channel select */
+#define I2S_CSR_SHIFT	15
+#define I2S_CHN_2	(0 << I2S_CSR_SHIFT)
+#define I2S_CHN_4	(1 << I2S_CSR_SHIFT)
+#define I2S_CHN_6	(2 << I2S_CSR_SHIFT)
+#define I2S_CHN_8	(3 << I2S_CSR_SHIFT)
+
+/* io direction cfg register */
+#define I2S_IO_DIRECTION_MASK	(7)
+#define I2S_IO_8CH_OUT_2CH_IN	(7)
+#define I2S_IO_6CH_OUT_4CH_IN	(3)
+#define I2S_IO_4CH_OUT_6CH_IN	(1)
+#define I2S_IO_2CH_OUT_8CH_IN	(0)
+
+/* I2S REGS */
+#define I2S_TXCR	(0x0000)
+#define I2S_RXCR	(0x0004)
+#define I2S_CKR		(0x0008)
+#define I2S_TXFIFOLR	(0x000c)
+#define I2S_DMACR	(0x0010)
+#define I2S_INTCR	(0x0014)
+#define I2S_INTSR	(0x0018)
+#define I2S_XFER	(0x001c)
+#define I2S_CLR		(0x0020)
+#define I2S_TXDR	(0x0024)
+#define I2S_RXDR	(0x0028)
+#define I2S_RXFIFOLR	(0x002c)
+#define I2S_TDM_TXCR	(0x0030)
+#define I2S_TDM_RXCR	(0x0034)
+#define I2S_CLKDIV	(0x0038)
+
+/* PX30 GRF CONFIGS*/
+#define PX30_I2S0_CLK_IN_SRC_MASK		GENMASK(13, 12)
+#define PX30_I2S0_CLK_IN_SRC_FROM_TX		(0x1 << 12)
+#define PX30_I2S0_CLK_IN_SRC_FROM_RX		(0x2 << 12)
+#define PX30_I2S0_MCLK_OUT_SRC_MSK		BIT(5)
+#define PX30_I2S0_MCLK_OUT_SRC_FROM_TX		BIT(5)
+#define PX30_I2S0_MCLK_OUT_SRC_FROM_RX		0
+
+#define PX30_I2S0_CLK_MSK \
+	(PX30_I2S0_MCLK_OUT_SRC_MSK | \
+	PX30_I2S0_CLK_IN_SRC_MASK)
+
+#define PX30_I2S0_CLK_TXONLY \
+	(PX30_I2S0_MCLK_OUT_SRC_FROM_TX | \
+	PX30_I2S0_CLK_IN_SRC_FROM_TX | \
+	(PX30_I2S0_CLK_MSK << 16))
+
+#define PX30_I2S0_CLK_RXONLY \
+	(PX30_I2S0_MCLK_OUT_SRC_FROM_RX | \
+	PX30_I2S0_CLK_IN_SRC_FROM_RX | \
+	(PX30_I2S0_CLK_MSK << 16))
+
+/* RK1808 GRF CONFIGS*/
+#define RK1808_I2S0_MCLK_OUT_SRC_MSK		BIT(2)
+#define RK1808_I2S0_MCLK_OUT_SRC_FROM_RX	BIT(2)
+#define RK1808_I2S0_MCLK_OUT_SRC_FROM_TX	0
+#define RK1808_I2S0_CLK_IN_SRC_MASK		GENMASK(1, 0)
+#define RK1808_I2S0_CLK_IN_SRC_FROM_TX		(0x1 << 0)
+#define RK1808_I2S0_CLK_IN_SRC_FROM_RX		(0x2 << 0)
+
+#define RK1808_I2S0_CLK_MSK \
+	(RK1808_I2S0_MCLK_OUT_SRC_MSK | \
+	RK1808_I2S0_CLK_IN_SRC_MASK)
+
+#define RK1808_I2S0_CLK_TXONLY \
+	(RK1808_I2S0_MCLK_OUT_SRC_FROM_TX | \
+	RK1808_I2S0_CLK_IN_SRC_FROM_TX | \
+	(RK1808_I2S0_CLK_MSK << 16))
+
+#define RK1808_I2S0_CLK_RXONLY \
+	(RK1808_I2S0_MCLK_OUT_SRC_FROM_RX | \
+	RK1808_I2S0_CLK_IN_SRC_FROM_RX | \
+	(RK1808_I2S0_CLK_MSK << 16))
+
+/* RK3308 GRF CONFIGS*/
+#define RK3308_I2S0_8CH_MCLK_OUT_SRC_MSK	BIT(10)
+#define RK3308_I2S0_8CH_MCLK_OUT_SRC_FROM_RX	BIT(10)
+#define RK3308_I2S0_8CH_MCLK_OUT_SRC_FROM_TX	0
+#define RK3308_I2S0_8CH_CLK_IN_RX_SRC_MSK	BIT(9)
+#define RK3308_I2S0_8CH_CLK_IN_RX_SRC_FROM_TX	BIT(9)
+#define RK3308_I2S0_8CH_CLK_IN_RX_SRC_FROM_RX	0
+#define RK3308_I2S0_8CH_CLK_IN_TX_SRC_MSK	BIT(8)
+#define RK3308_I2S0_8CH_CLK_IN_TX_SRC_FROM_RX	BIT(8)
+#define RK3308_I2S0_8CH_CLK_IN_TX_SRC_FROM_TX	0
+#define RK3308_I2S1_8CH_MCLK_OUT_SRC_MSK	BIT(2)
+#define RK3308_I2S1_8CH_MCLK_OUT_SRC_FROM_RX	BIT(2)
+#define RK3308_I2S1_8CH_MCLK_OUT_SRC_FROM_TX	0
+#define RK3308_I2S1_8CH_CLK_IN_RX_SRC_MSK	BIT(1)
+#define RK3308_I2S1_8CH_CLK_IN_RX_SRC_FROM_TX	BIT(1)
+#define RK3308_I2S1_8CH_CLK_IN_RX_SRC_FROM_RX	0
+#define RK3308_I2S1_8CH_CLK_IN_TX_SRC_MSK	BIT(0)
+#define RK3308_I2S1_8CH_CLK_IN_TX_SRC_FROM_RX	BIT(0)
+#define RK3308_I2S1_8CH_CLK_IN_TX_SRC_FROM_TX	0
+
+#define RK3308_I2S0_CLK_MSK \
+	(RK3308_I2S0_8CH_MCLK_OUT_SRC_MSK | \
+	RK3308_I2S0_8CH_CLK_IN_RX_SRC_MSK | \
+	RK3308_I2S0_8CH_CLK_IN_TX_SRC_MSK)
+
+#define RK3308_I2S0_CLK_TXONLY \
+	(RK3308_I2S0_8CH_MCLK_OUT_SRC_FROM_TX | \
+	RK3308_I2S0_8CH_CLK_IN_RX_SRC_FROM_TX | \
+	RK3308_I2S0_8CH_CLK_IN_TX_SRC_FROM_TX | \
+	(RK3308_I2S0_CLK_MSK << 16))
+
+#define RK3308_I2S0_CLK_RXONLY \
+	(RK3308_I2S0_8CH_MCLK_OUT_SRC_FROM_RX | \
+	RK3308_I2S0_8CH_CLK_IN_RX_SRC_FROM_RX | \
+	RK3308_I2S0_8CH_CLK_IN_TX_SRC_FROM_RX | \
+	(RK3308_I2S0_CLK_MSK << 16))
+
+#define RK3308_I2S1_CLK_MSK \
+	(RK3308_I2S1_8CH_MCLK_OUT_SRC_MSK | \
+	RK3308_I2S1_8CH_CLK_IN_RX_SRC_MSK | \
+	RK3308_I2S1_8CH_CLK_IN_TX_SRC_MSK)
+
+#define RK3308_I2S1_CLK_TXONLY \
+	(RK3308_I2S1_8CH_MCLK_OUT_SRC_FROM_TX | \
+	RK3308_I2S1_8CH_CLK_IN_RX_SRC_FROM_TX | \
+	RK3308_I2S1_8CH_CLK_IN_TX_SRC_FROM_TX | \
+	(RK3308_I2S1_CLK_MSK << 16))
+
+#define RK3308_I2S1_CLK_RXONLY \
+	(RK3308_I2S1_8CH_MCLK_OUT_SRC_FROM_RX | \
+	RK3308_I2S1_8CH_CLK_IN_RX_SRC_FROM_RX | \
+	RK3308_I2S1_8CH_CLK_IN_TX_SRC_FROM_RX | \
+	(RK3308_I2S1_CLK_MSK << 16))
+
+#endif /* _ROCKCHIP_I2S_TDM_H */
Index: linux-5.10.27/sound/soc/rockchip/rockchip_multi_dais.c
===================================================================
--- /dev/null
+++ linux-5.10.27/sound/soc/rockchip/rockchip_multi_dais.c
@@ -0,0 +1,521 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * ALSA SoC Audio Layer - Rockchip Multi-DAIS  driver
+ *
+ * Copyright (c) 2018 Rockchip Electronics Co. Ltd.
+ * Author: Sugar Zhang <sugar.zhang@rock-chips.com>
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/mfd/syscon.h>
+#include <linux/of_device.h>
+#include <linux/pm_runtime.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#include "rockchip_multi_dais.h"
+
+#define BITCLOCK_INV_STR	"bitclock-inversion"
+#define FRAME_INV_STR		"frame-inversion"
+#define BITCLOCK_MASTER_STR	"bitclock-master"
+#define FRAME_MASTER_STR	"frame-master"
+#define DAIS_DRV_NAME		"rockchip-mdais"
+#define RK3308_GRF_SOC_CON2	0x308
+
+static inline struct rk_mdais_dev *to_info(struct snd_soc_dai *dai)
+{
+	return snd_soc_dai_get_drvdata(dai);
+}
+
+static void hw_refine_channels(struct snd_pcm_hw_params *params,
+			       unsigned int channel)
+{
+	struct snd_interval *c =
+		hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
+
+	c->min = channel;
+	c->max = channel;
+}
+
+static int rockchip_mdais_hw_params(struct snd_pcm_substream *substream,
+				    struct snd_pcm_hw_params *params,
+				    struct snd_soc_dai *dai)
+{
+	struct rk_mdais_dev *mdais = to_info(dai);
+	struct snd_pcm_hw_params *cparams;
+	struct snd_soc_dai *child;
+	unsigned int *channel_maps;
+	int ret = 0, i = 0;
+
+	cparams = kmemdup(params, sizeof(*params), GFP_KERNEL);
+	if (IS_ERR(cparams))
+		return PTR_ERR(cparams);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		channel_maps = mdais->playback_channel_maps;
+	else
+		channel_maps = mdais->capture_channel_maps;
+
+	for (i = 0; i < mdais->num_dais; i++) {
+		child = mdais->dais[i].dai;
+		if (channel_maps[i])
+			hw_refine_channels(cparams, channel_maps[i]);
+		if (child->driver->ops && child->driver->ops->hw_params) {
+			ret = child->driver->ops->hw_params(substream, cparams, child);
+			if (ret < 0) {
+				dev_err(dai->dev, "ASoC: can't set %s hw params: %d\n",
+					dai->name, ret);
+				return ret;
+			}
+		}
+	}
+
+	kfree(cparams);
+	return 0;
+}
+
+static int rockchip_mdais_trigger(struct snd_pcm_substream *substream,
+				  int cmd, struct snd_soc_dai *dai)
+{
+	struct rk_mdais_dev *mdais = to_info(dai);
+	struct snd_soc_dai *child;
+	int ret = 0, i = 0;
+
+	for (i = 0; i < mdais->num_dais; i++) {
+		child = mdais->dais[i].dai;
+		if (child->driver->ops && child->driver->ops->trigger) {
+			ret = child->driver->ops->trigger(substream,
+							  cmd, child);
+			if (ret < 0)
+				return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int rockchip_mdais_set_sysclk(struct snd_soc_dai *cpu_dai, int clk_id,
+				     unsigned int freq, int dir)
+{
+	struct rk_mdais_dev *mdais = to_info(cpu_dai);
+	struct snd_soc_dai *child;
+	int ret, i = 0;
+
+	for (i = 0; i < mdais->num_dais; i++) {
+		child = mdais->dais[i].dai;
+		ret = snd_soc_dai_set_sysclk(child, clk_id, freq, dir);
+		if (ret && ret != -ENOTSUPP)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int rockchip_mdais_set_fmt(struct snd_soc_dai *cpu_dai,
+				  unsigned int fmt)
+{
+	struct rk_mdais_dev *mdais = to_info(cpu_dai);
+	struct snd_soc_dai *child;
+	unsigned int dai_fmt;
+	int ret, i = 0;
+
+	for (i = 0; i < mdais->num_dais; i++) {
+		child = mdais->dais[i].dai;
+		dai_fmt = fmt;
+		if (mdais->dais[i].fmt_msk) {
+			dai_fmt &= ~(mdais->dais[i].fmt_msk);
+			dai_fmt |= mdais->dais[i].fmt;
+		}
+		ret = snd_soc_dai_set_fmt(child, dai_fmt);
+		if (ret && ret != -ENOTSUPP)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int rockchip_mdais_dai_probe(struct snd_soc_dai *dai)
+{
+	struct rk_mdais_dev *mdais = to_info(dai);
+	struct snd_soc_dai *child;
+	int ret, i = 0;
+
+	for (i = 0; i < mdais->num_dais; i++) {
+		child = mdais->dais[i].dai;
+		if (!child->probed && child->driver->probe) {
+			ret = child->driver->probe(child);
+			if (ret < 0) {
+				dev_err(child->dev,
+					"ASoC: failed to probe DAI %s: %d\n",
+					child->name, ret);
+				return ret;
+			}
+			dai->probed = 1;
+		}
+	}
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops rockchip_mdais_dai_ops = {
+	.hw_params = rockchip_mdais_hw_params,
+	.set_sysclk = rockchip_mdais_set_sysclk,
+	.set_fmt = rockchip_mdais_set_fmt,
+	.trigger = rockchip_mdais_trigger,
+};
+
+static const struct snd_soc_component_driver rockchip_mdais_component = {
+	.name = DAIS_DRV_NAME,
+};
+
+static const struct of_device_id rockchip_mdais_match[] = {
+	{ .compatible = "rockchip,multi-dais", },
+	{ .compatible = "rockchip,rk3308-multi-dais", },
+	{},
+};
+
+static struct snd_soc_dai *rockchip_mdais_find_dai(struct device_node *np)
+{
+	struct snd_soc_dai_link_component dai_component = { 0 };
+
+	dai_component.of_node = np;
+
+	return snd_soc_find_dai(&dai_component);
+}
+
+static int mdais_runtime_suspend(struct device *dev)
+{
+	struct rk_mdais_dev *mdais = dev_get_drvdata(dev);
+	struct snd_soc_dai *child;
+	int i = 0;
+
+	for (i = 0; i < mdais->num_dais; i++) {
+		child = mdais->dais[i].dai;
+		pm_runtime_put(child->dev);
+	}
+
+	return 0;
+}
+
+static int mdais_runtime_resume(struct device *dev)
+{
+	struct rk_mdais_dev *mdais = dev_get_drvdata(dev);
+	struct snd_soc_dai *child;
+	int i = 0;
+
+	for (i = 0; i < mdais->num_dais; i++) {
+		child = mdais->dais[i].dai;
+		pm_runtime_get_sync(child->dev);
+	}
+
+	return 0;
+}
+
+static int mdais_read_prop_array(struct device_node *node,
+				 const char *propname,
+				 unsigned int *array, int num)
+{
+	int ret = 0;
+
+	memset(array, 0, sizeof(*array) * num);
+	if (of_property_read_bool(node, propname)) {
+		ret = of_property_read_u32_array(node, propname, array, num);
+		if (ret)
+			ret = -EINVAL;
+	} else {
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static void mdais_parse_daifmt(struct device_node *node, struct rk_dai *dais,
+			       int num_dai)
+{
+	unsigned int cinv[MAX_DAIS], finv[MAX_DAIS];
+	unsigned int cmst[MAX_DAIS], fmst[MAX_DAIS];
+	unsigned int format = 0, format_mask = 0;
+	int i = 0, ret = 0;
+
+	ret = mdais_read_prop_array(node, BITCLOCK_INV_STR, cinv, num_dai);
+	if (!ret)
+		format_mask |= SND_SOC_DAIFMT_INV_MASK;
+	ret = mdais_read_prop_array(node, FRAME_INV_STR, finv, num_dai);
+	if (!ret)
+		format_mask |= SND_SOC_DAIFMT_INV_MASK;
+	ret = mdais_read_prop_array(node, BITCLOCK_MASTER_STR, cmst, num_dai);
+	if (!ret)
+		format_mask |= SND_SOC_DAIFMT_MASTER_MASK;
+	ret = mdais_read_prop_array(node, FRAME_MASTER_STR, fmst, num_dai);
+	if (!ret)
+		format_mask |= SND_SOC_DAIFMT_MASTER_MASK;
+
+	for (i = 0; i < num_dai; i++) {
+		format = 0;
+
+		switch ((cinv[i] << 4) + finv[i]) {
+		case 0x11:
+			format |= SND_SOC_DAIFMT_IB_IF;
+			break;
+		case 0x10:
+			format |= SND_SOC_DAIFMT_IB_NF;
+			break;
+		case 0x01:
+			format |= SND_SOC_DAIFMT_NB_IF;
+			break;
+		default:
+			/* SND_SOC_DAIFMT_NB_NF is default */
+			break;
+		}
+
+		switch ((!cmst[i] << 4) + !fmst[i]) {
+		case 0x11:
+			format |= SND_SOC_DAIFMT_CBM_CFM;
+			break;
+		case 0x10:
+			format |= SND_SOC_DAIFMT_CBM_CFS;
+			break;
+		case 0x01:
+			format |= SND_SOC_DAIFMT_CBS_CFM;
+			break;
+		default:
+			format |= SND_SOC_DAIFMT_CBS_CFS;
+			break;
+		}
+
+		dais[i].fmt = format & format_mask;
+		dais[i].fmt_msk = format_mask;
+	}
+}
+
+static int rockchip_mdais_dai_prepare(struct platform_device *pdev,
+				      struct snd_soc_dai_driver **soc_dai)
+{
+	struct snd_soc_dai_driver rockchip_mdais_dai = {
+		.probe = rockchip_mdais_dai_probe,
+		.playback = {
+			.stream_name = "Playback",
+			.channels_min = 2,
+			.channels_max = 32,
+			.rates = SNDRV_PCM_RATE_8000_192000,
+			.formats = (SNDRV_PCM_FMTBIT_S8 |
+				    SNDRV_PCM_FMTBIT_S16_LE |
+				    SNDRV_PCM_FMTBIT_S20_3LE |
+				    SNDRV_PCM_FMTBIT_S24_LE |
+				    SNDRV_PCM_FMTBIT_S32_LE),
+		},
+		.capture = {
+			.stream_name = "Capture",
+			.channels_min = 2,
+			.channels_max = 32,
+			.rates = SNDRV_PCM_RATE_8000_192000,
+			.formats = (SNDRV_PCM_FMTBIT_S8 |
+				    SNDRV_PCM_FMTBIT_S16_LE |
+				    SNDRV_PCM_FMTBIT_S20_3LE |
+				    SNDRV_PCM_FMTBIT_S24_LE |
+				    SNDRV_PCM_FMTBIT_S32_LE),
+		},
+		.ops = &rockchip_mdais_dai_ops,
+	};
+
+	*soc_dai = devm_kmemdup(&pdev->dev, &rockchip_mdais_dai,
+				sizeof(rockchip_mdais_dai), GFP_KERNEL);
+	if (!(*soc_dai))
+		return -ENOMEM;
+
+	return 0;
+}
+
+static void mdais_fixup_dai(struct snd_soc_dai_driver *soc_dai,
+			    struct rk_mdais_dev *mdais)
+{
+	int i, tch, rch;
+	unsigned int *tx_maps, *rx_maps;
+
+	tch = 0;
+	rch = 0;
+	tx_maps = mdais->playback_channel_maps;
+	rx_maps = mdais->capture_channel_maps;
+	for (i = 0; i < mdais->num_dais; i++) {
+		tch += tx_maps[i];
+		rch += rx_maps[i];
+	}
+
+	soc_dai->playback.channels_min = tch;
+	soc_dai->playback.channels_max = tch;
+	soc_dai->capture.channels_min = rch;
+	soc_dai->capture.channels_max = rch;
+}
+
+static int rockchip_mdais_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct platform_device  *sub_pdev;
+	struct rk_mdais_dev *mdais;
+	struct device_node *node;
+	struct snd_soc_dai_driver *soc_dai;
+	struct rk_dai *dais;
+	unsigned int *map;
+	int count, mp_count;
+	int ret = 0, i = 0;
+
+	ret = rockchip_mdais_dai_prepare(pdev, &soc_dai);
+	if (ret < 0)
+		return ret;
+
+	mdais = devm_kzalloc(&pdev->dev, sizeof(*mdais), GFP_KERNEL);
+	if (!mdais)
+		return -ENOMEM;
+
+	count = of_count_phandle_with_args(np, "dais", NULL);
+	if (count < 0 || count > MAX_DAIS)
+		return -EINVAL;
+
+	mp_count = of_property_count_u32_elems(np, "capture,channel-mapping");
+	if (mp_count != count)
+		return -EINVAL;
+	mp_count = of_property_count_u32_elems(np, "playback,channel-mapping");
+	if (mp_count != count)
+		return -EINVAL;
+
+	mdais->num_dais = count;
+	dais = devm_kcalloc(&pdev->dev, count,
+			    sizeof(*dais), GFP_KERNEL);
+	if (!dais)
+		return -ENOMEM;
+
+	map = devm_kcalloc(&pdev->dev, count,
+			   sizeof(*map), GFP_KERNEL);
+	if (!map)
+		return -ENOMEM;
+	ret = of_property_read_u32_array(np, "capture,channel-mapping",
+					 map, count);
+	if (ret)
+		return -EINVAL;
+	mdais->capture_channel_maps = map;
+	map = devm_kcalloc(&pdev->dev, count,
+			   sizeof(*map), GFP_KERNEL);
+	if (!map)
+		return -ENOMEM;
+	ret = of_property_read_u32_array(np, "playback,channel-mapping",
+					 map, count);
+	if (ret)
+		return -EINVAL;
+	mdais->playback_channel_maps = map;
+
+	for (i = 0; i < count; i++) {
+		node = of_parse_phandle(np, "dais", i);
+		sub_pdev = of_find_device_by_node(node);
+		if (!sub_pdev) {
+			dev_err(&pdev->dev, "fail to find subnode dev\n");
+			return -ENODEV;
+		}
+		dais[i].of_node = node;
+		dais[i].dev = &sub_pdev->dev;
+		dais[i].dai = rockchip_mdais_find_dai(node);
+		if (!dais[i].dai)
+			return -EPROBE_DEFER;
+	}
+
+	mdais_parse_daifmt(np, dais, count);
+	mdais_fixup_dai(soc_dai, mdais);
+
+	if (of_device_is_compatible(np, "rockchip,rk3308-multi-dais")) {
+		struct regmap *grf;
+		const char *name;
+		unsigned int i2s0_fmt = 0, i2s1_fmt = 0;
+
+		for (i = 0; i < count; i++) {
+			name = dev_name(dais[i].dev);
+			if (strstr(name, "ff300000"))
+				i2s0_fmt = dais[i].fmt;
+			else if (strstr(name, "ff310000"))
+				i2s1_fmt = dais[i].fmt;
+		}
+		i2s0_fmt &= SND_SOC_DAIFMT_MASTER_MASK;
+		i2s1_fmt &= SND_SOC_DAIFMT_MASTER_MASK;
+
+		if ((i2s0_fmt == SND_SOC_DAIFMT_CBS_CFS &&
+		     i2s1_fmt == SND_SOC_DAIFMT_CBM_CFM) ||
+		    (i2s0_fmt == SND_SOC_DAIFMT_CBM_CFM &&
+		     i2s1_fmt == SND_SOC_DAIFMT_CBS_CFS)) {
+			grf = syscon_regmap_lookup_by_phandle(np,
+							      "rockchip,grf");
+			if (IS_ERR(grf))
+				return PTR_ERR(grf);
+
+			dev_info(&pdev->dev, "enable i2s 16ch ctrl en\n");
+			regmap_write(grf, RK3308_GRF_SOC_CON2,
+				     BIT(14) << 16 | BIT(14));
+		}
+	}
+
+	mdais->dais = dais;
+	mdais->dev = &pdev->dev;
+	dev_set_drvdata(&pdev->dev, mdais);
+
+	pm_runtime_enable(&pdev->dev);
+	if (!pm_runtime_enabled(&pdev->dev)) {
+		ret = mdais_runtime_resume(&pdev->dev);
+		if (ret)
+			goto err_pm_disable;
+	}
+
+	ret = devm_snd_soc_register_component(&pdev->dev,
+					      &rockchip_mdais_component,
+					      soc_dai, 1);
+
+	if (ret) {
+		dev_err(&pdev->dev, "could not register dai: %d\n", ret);
+		goto err_suspend;
+	}
+
+	ret = snd_dmaengine_mpcm_register(mdais);
+	if (ret) {
+		dev_err(&pdev->dev, "Could not register PCM\n");
+		return ret;
+	}
+
+	return 0;
+
+err_suspend:
+	if (!pm_runtime_status_suspended(&pdev->dev))
+		mdais_runtime_resume(&pdev->dev);
+err_pm_disable:
+	pm_runtime_disable(&pdev->dev);
+
+	return ret;
+}
+
+static int rockchip_mdais_remove(struct platform_device *pdev)
+{
+	snd_dmaengine_mpcm_unregister(&pdev->dev);
+	pm_runtime_disable(&pdev->dev);
+	if (!pm_runtime_status_suspended(&pdev->dev))
+		mdais_runtime_suspend(&pdev->dev);
+
+	return 0;
+}
+
+static const struct dev_pm_ops rockchip_mdais_pm_ops = {
+	SET_RUNTIME_PM_OPS(mdais_runtime_suspend, mdais_runtime_resume,
+			   NULL)
+};
+
+static struct platform_driver rockchip_mdais_driver = {
+	.probe = rockchip_mdais_probe,
+	.remove = rockchip_mdais_remove,
+	.driver = {
+		.name = DAIS_DRV_NAME,
+		.of_match_table = of_match_ptr(rockchip_mdais_match),
+		.pm = &rockchip_mdais_pm_ops,
+	},
+};
+module_platform_driver(rockchip_mdais_driver);
+
+MODULE_DESCRIPTION("ROCKCHIP MULTI-DAIS ASoC Interface");
+MODULE_AUTHOR("Sugar Zhang <sugar.zhang@rock-chips.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" DAIS_DRV_NAME);
+MODULE_DEVICE_TABLE(of, rockchip_mdais_match);
Index: linux-5.10.27/sound/soc/rockchip/rockchip_multi_dais.h
===================================================================
--- /dev/null
+++ linux-5.10.27/sound/soc/rockchip/rockchip_multi_dais.h
@@ -0,0 +1,33 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Rockchip MULTI DAIS driver
+ *
+ * Copyright (C) 2018 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ */
+
+#ifndef _ROCKCHIP_MULTI_DAIS_H
+#define _ROCKCHIP_MULTI_DAIS_H
+
+#define MAX_DAIS 4
+
+struct rk_dai {
+	struct device *dev;
+	struct device_node *of_node;
+	struct snd_soc_dai *dai;
+	unsigned int fmt;
+	unsigned int fmt_msk;
+};
+
+struct rk_mdais_dev {
+	struct device *dev;
+	struct rk_dai *dais;
+	unsigned int *playback_channel_maps;
+	unsigned int *capture_channel_maps;
+	int num_dais;
+};
+
+int snd_dmaengine_mpcm_register(struct rk_mdais_dev *mdais);
+void snd_dmaengine_mpcm_unregister(struct device *dev);
+
+#endif
Index: linux-5.10.27/sound/soc/rockchip/rockchip_multi_dais_pcm.c
===================================================================
--- /dev/null
+++ linux-5.10.27/sound/soc/rockchip/rockchip_multi_dais_pcm.c
@@ -0,0 +1,704 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * ALSA SoC Audio Layer - Rockchip Multi-DAIS-PCM driver
+ *
+ * Copyright (c) 2018 Rockchip Electronics Co. Ltd.
+ * Author: Sugar Zhang <sugar.zhang@rock-chips.com>
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/dmaengine.h>
+#include <linux/dma-mapping.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#include "rockchip_multi_dais.h"
+
+#define MAX_FIFO_SIZE	32 /* max fifo size in frames */
+
+struct dmaengine_mpcm {
+	struct rk_mdais_dev *mdais;
+	struct dma_chan *tx_chans[MAX_DAIS];
+	struct dma_chan *rx_chans[MAX_DAIS];
+	struct snd_soc_platform platform;
+};
+
+struct dmaengine_mpcm_runtime_data {
+	struct dma_chan *chans[MAX_DAIS];
+	dma_cookie_t cookies[MAX_DAIS];
+	unsigned int *channel_maps;
+	int num_chans;
+	unsigned int pos;
+	unsigned int master_chan;
+	bool start_flag;
+#ifdef CONFIG_SND_SOC_ROCKCHIP_VAD
+	unsigned int vpos;
+	unsigned int vresidue_bytes;
+#endif
+};
+
+static inline struct dmaengine_mpcm_runtime_data *substream_to_prtd(
+	const struct snd_pcm_substream *substream)
+{
+	return substream->runtime->private_data;
+}
+
+static struct dmaengine_mpcm *soc_platform_to_pcm(struct snd_soc_platform *p)
+{
+	return container_of(p, struct dmaengine_mpcm, platform);
+}
+
+static struct dma_chan *to_chan(struct dmaengine_mpcm *pcm,
+				struct snd_pcm_substream *substream)
+{
+	struct dma_chan *chan = NULL;
+	int i;
+
+	for (i = 0; i < pcm->mdais->num_dais; i++) {
+		chan = substream->stream ? pcm->rx_chans[i] : pcm->tx_chans[i];
+		if (chan)
+			break;
+	}
+
+	return chan;
+}
+
+static struct device *dmaengine_dma_dev(struct dmaengine_mpcm *pcm,
+					struct snd_pcm_substream *substream)
+{
+	struct dma_chan *chan;
+
+	chan = to_chan(pcm, substream);
+	if (!chan)
+		return NULL;
+
+	return chan->device->dev;
+}
+
+static void snd_dmaengine_mpcm_set_config_from_dai_data(
+	const struct snd_pcm_substream *substream,
+	const struct snd_dmaengine_dai_dma_data *dma_data,
+	struct dma_slave_config *slave_config)
+{
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		slave_config->dst_addr = dma_data->addr;
+		if (dma_data->addr_width != DMA_SLAVE_BUSWIDTH_UNDEFINED)
+			slave_config->dst_addr_width = dma_data->addr_width;
+	} else {
+		slave_config->src_addr = dma_data->addr;
+		if (dma_data->addr_width != DMA_SLAVE_BUSWIDTH_UNDEFINED)
+			slave_config->src_addr_width = dma_data->addr_width;
+	}
+
+	slave_config->slave_id = dma_data->slave_id;
+}
+
+static void dmaengine_mpcm_dma_complete(void *arg)
+{
+	struct snd_pcm_substream *substream = arg;
+#ifdef CONFIG_SND_SOC_ROCKCHIP_VAD
+	struct dmaengine_mpcm_runtime_data *prtd = substream_to_prtd(substream);
+
+	if (snd_pcm_vad_attached(substream) &&
+	    substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		void *buf = substream->runtime->dma_area + prtd->pos;
+
+		snd_pcm_vad_preprocess(substream, buf,
+				       substream->runtime->period_size);
+	}
+
+	prtd->pos += snd_pcm_lib_period_bytes(substream);
+	if (prtd->pos >= snd_pcm_lib_buffer_bytes(substream))
+		prtd->pos = 0;
+
+#endif
+	snd_pcm_period_elapsed(substream);
+}
+
+static int dmaengine_mpcm_prepare_and_submit(struct snd_pcm_substream *substream)
+{
+	struct dmaengine_mpcm_runtime_data *prtd = substream_to_prtd(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct dma_async_tx_descriptor *desc;
+	enum dma_transfer_direction direction;
+	unsigned long flags = DMA_CTRL_ACK;
+	unsigned int *maps = prtd->channel_maps;
+	int offset, buffer_bytes, period_bytes;
+	int i;
+	bool callback = false;
+
+	direction = snd_pcm_substream_to_dma_direction(substream);
+
+	if (!substream->runtime->no_period_wakeup)
+		flags |= DMA_PREP_INTERRUPT;
+
+	prtd->pos = 0;
+	offset = 0;
+	period_bytes = snd_pcm_lib_period_bytes(substream);
+	buffer_bytes = snd_pcm_lib_buffer_bytes(substream);
+	for (i = 0; i < prtd->num_chans; i++) {
+		if (!prtd->chans[i])
+			continue;
+		desc = dmaengine_prep_dma_cyclic(prtd->chans[i],
+						 runtime->dma_addr + offset,
+						 buffer_bytes, period_bytes,
+						 direction, flags);
+
+		if (!desc)
+			return -ENOMEM;
+		if (!callback) {
+			desc->callback = dmaengine_mpcm_dma_complete;
+			desc->callback_param = substream;
+			callback = true;
+			prtd->master_chan = i;
+		}
+		prtd->cookies[i] = dmaengine_submit(desc);
+		offset += samples_to_bytes(runtime, maps[i]);
+	}
+
+	return 0;
+}
+
+static void mpcm_dma_async_issue_pending(struct dmaengine_mpcm_runtime_data *prtd)
+{
+	int i;
+
+	for (i = 0; i < prtd->num_chans; i++) {
+		if (prtd->chans[i])
+			dma_async_issue_pending(prtd->chans[i]);
+	}
+}
+
+static void mpcm_dmaengine_resume(struct dmaengine_mpcm_runtime_data *prtd)
+{
+	int i;
+
+	for (i = 0; i < prtd->num_chans; i++) {
+		if (prtd->chans[i])
+			dmaengine_resume(prtd->chans[i]);
+	}
+}
+
+static void mpcm_dmaengine_pause(struct dmaengine_mpcm_runtime_data *prtd)
+{
+	int i;
+
+	for (i = 0; i < prtd->num_chans; i++) {
+		if (prtd->chans[i])
+			dmaengine_pause(prtd->chans[i]);
+	}
+}
+
+static void mpcm_dmaengine_terminate_all(struct dmaengine_mpcm_runtime_data *prtd)
+{
+	int i;
+
+	for (i = 0; i < prtd->num_chans; i++) {
+		if (prtd->chans[i])
+			dmaengine_terminate_all(prtd->chans[i]);
+	}
+}
+
+#ifdef CONFIG_SND_SOC_ROCKCHIP_VAD
+static void dmaengine_mpcm_single_dma_complete(void *arg)
+{
+	struct snd_pcm_substream *substream = arg;
+	struct dmaengine_mpcm_runtime_data *prtd = substream_to_prtd(substream);
+	unsigned int pos, size;
+	void *buf;
+
+	if (snd_pcm_vad_attached(substream) &&
+	    substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		buf = substream->runtime->dma_area + prtd->vpos;
+		pos = prtd->vpos + snd_pcm_lib_period_bytes(substream);
+
+		if (pos <= snd_pcm_lib_buffer_bytes(substream))
+			size = substream->runtime->period_size;
+		else
+			size = bytes_to_frames(substream->runtime,
+					       prtd->vresidue_bytes);
+		snd_pcm_vad_preprocess(substream, buf, size);
+	}
+
+	prtd->vpos += snd_pcm_lib_period_bytes(substream);
+	if (prtd->vpos >= snd_pcm_lib_buffer_bytes(substream))
+		prtd->vpos = 0;
+	snd_pcm_period_elapsed(substream);
+}
+
+static int __mpcm_prepare_single_and_submit(struct snd_pcm_substream *substream,
+					    dma_addr_t buf_start, int size)
+{
+	struct dmaengine_mpcm_runtime_data *prtd = substream_to_prtd(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct dma_async_tx_descriptor *desc;
+	enum dma_transfer_direction direction;
+	unsigned long flags = DMA_CTRL_ACK;
+	unsigned int *maps = prtd->channel_maps;
+	int offset, i;
+	bool callback = false;
+
+	direction = snd_pcm_substream_to_dma_direction(substream);
+
+	if (!substream->runtime->no_period_wakeup)
+		flags |= DMA_PREP_INTERRUPT;
+
+	offset = 0;
+	for (i = 0; i < prtd->num_chans; i++) {
+		if (!prtd->chans[i])
+			continue;
+		desc = dmaengine_prep_slave_single(prtd->chans[i],
+						   buf_start + offset,
+						   size,
+						   direction, flags);
+
+		if (!desc)
+			return -ENOMEM;
+		if (!callback) {
+			desc->callback = dmaengine_mpcm_single_dma_complete;
+			desc->callback_param = substream;
+			callback = true;
+		}
+		dmaengine_submit(desc);
+		offset += samples_to_bytes(runtime, maps[i]);
+	}
+
+	return 0;
+}
+
+static int dmaengine_mpcm_prepare_single_and_submit(struct snd_pcm_substream *substream)
+{
+	struct dmaengine_mpcm_runtime_data *prtd = substream_to_prtd(substream);
+	enum dma_transfer_direction direction;
+	unsigned long flags = DMA_CTRL_ACK;
+	snd_pcm_uframes_t avail;
+	dma_addr_t buf_start, buf_end;
+	int offset, i, count, ret;
+	int buffer_bytes, period_bytes, residue_bytes;
+
+	direction = snd_pcm_substream_to_dma_direction(substream);
+
+	if (!substream->runtime->no_period_wakeup)
+		flags |= DMA_PREP_INTERRUPT;
+
+	period_bytes = snd_pcm_lib_period_bytes(substream);
+	buffer_bytes = snd_pcm_lib_buffer_bytes(substream);
+	avail = snd_pcm_vad_avail(substream);
+	offset = frames_to_bytes(substream->runtime, avail);
+	prtd->vpos = offset;
+	buf_start = substream->runtime->dma_addr + offset;
+	buf_end = substream->runtime->dma_addr + snd_pcm_lib_buffer_bytes(substream);
+	count = (buf_end - buf_start) / period_bytes;
+	residue_bytes = (buf_end - buf_start) % period_bytes;
+	prtd->vresidue_bytes = residue_bytes;
+	pr_debug("%s: offset: %d, buffer_bytes: %d\n", __func__, offset, buffer_bytes);
+	pr_debug("%s: count: %d, residue_bytes: %d\n", __func__, count, residue_bytes);
+	for (i = 0; i < count; i++) {
+		ret = __mpcm_prepare_single_and_submit(substream, buf_start,
+						       period_bytes);
+		if (ret)
+			return ret;
+		buf_start += period_bytes;
+	}
+
+	if (residue_bytes) {
+		ret = __mpcm_prepare_single_and_submit(substream, buf_start,
+						       residue_bytes);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+#endif
+
+static int snd_dmaengine_mpcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct dmaengine_mpcm_runtime_data *prtd = substream_to_prtd(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int ret;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+#ifdef CONFIG_SND_SOC_ROCKCHIP_VAD
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE &&
+		    snd_pcm_vad_attached(substream) &&
+		    snd_pcm_vad_avail(substream)) {
+			dmaengine_mpcm_prepare_single_and_submit(substream);
+			mpcm_dma_async_issue_pending(prtd);
+		}
+#endif
+		ret = dmaengine_mpcm_prepare_and_submit(substream);
+		if (ret)
+			return ret;
+		mpcm_dma_async_issue_pending(prtd);
+		break;
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		mpcm_dmaengine_resume(prtd);
+		break;
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+		if (runtime->info & SNDRV_PCM_INFO_PAUSE)
+			mpcm_dmaengine_pause(prtd);
+		else
+			mpcm_dmaengine_terminate_all(prtd);
+		prtd->start_flag = false;
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		mpcm_dmaengine_pause(prtd);
+		prtd->start_flag = false;
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		mpcm_dmaengine_terminate_all(prtd);
+		prtd->start_flag = false;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int dmaengine_mpcm_hw_params(struct snd_pcm_substream *substream,
+				    struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct dmaengine_mpcm *pcm = soc_platform_to_pcm(rtd->platform);
+	struct dma_chan *chan;
+	struct snd_dmaengine_dai_dma_data *dma_data;
+	struct dma_slave_config slave_config;
+	snd_pcm_format_t format;
+	unsigned int *maps;
+	int frame_bytes;
+	int ret, num, i, sz;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		maps = pcm->mdais->playback_channel_maps;
+	else
+		maps = pcm->mdais->capture_channel_maps;
+	format = params_format(params);
+	frame_bytes = snd_pcm_format_size(format, params_channels(params));
+	num = pcm->mdais->num_dais;
+
+	for (i = 0; i < num; i++) {
+		memset(&slave_config, 0, sizeof(slave_config));
+		ret = snd_hwparams_to_dma_slave_config(substream, params,
+						       &slave_config);
+		if (ret)
+			return ret;
+
+		dma_data = snd_soc_dai_get_dma_data(pcm->mdais->dais[i].dai,
+						    substream);
+		if (!dma_data)
+			continue;
+
+		snd_dmaengine_mpcm_set_config_from_dai_data(substream,
+							    dma_data,
+							    &slave_config);
+
+		/* refine params for interlace access */
+		sz = snd_pcm_format_size(format, maps[i]);
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			chan = pcm->tx_chans[i];
+			if (sz) {
+				slave_config.src_interlace_size = frame_bytes - sz;
+				if (slave_config.src_interlace_size)
+					slave_config.dst_maxburst = sz / slave_config.dst_addr_width;
+			}
+		} else {
+			chan = pcm->rx_chans[i];
+			if (sz) {
+				slave_config.dst_interlace_size = frame_bytes - sz;
+				if (slave_config.dst_interlace_size)
+					slave_config.src_maxburst = sz / slave_config.src_addr_width;
+			}
+		}
+		if (!chan)
+			continue;
+
+		ret = dmaengine_slave_config(chan, &slave_config);
+		if (ret)
+			return ret;
+	}
+	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));
+}
+
+static int dmaengine_mpcm_set_runtime_hwparams(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct dmaengine_mpcm *pcm = soc_platform_to_pcm(rtd->platform);
+	struct device *dma_dev = dmaengine_dma_dev(pcm, substream);
+	struct dma_chan *chan;
+	struct dma_slave_caps dma_caps;
+	struct snd_pcm_hardware hw;
+	u32 addr_widths = BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) |
+			  BIT(DMA_SLAVE_BUSWIDTH_2_BYTES) |
+			  BIT(DMA_SLAVE_BUSWIDTH_4_BYTES);
+	int i, ret;
+
+	chan = to_chan(pcm, substream);
+	if (!chan)
+		return -EINVAL;
+
+	memset(&hw, 0, sizeof(hw));
+	hw.info = SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID |
+			SNDRV_PCM_INFO_INTERLEAVED;
+	hw.periods_min = 2;
+	hw.periods_max = UINT_MAX;
+	hw.period_bytes_min = 256;
+	hw.period_bytes_max = dma_get_max_seg_size(dma_dev);
+	hw.buffer_bytes_max = SIZE_MAX;
+
+	ret = dma_get_slave_caps(chan, &dma_caps);
+	if (ret == 0) {
+		if (dma_caps.cmd_pause)
+			hw.info |= SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME;
+		if (dma_caps.residue_granularity <= DMA_RESIDUE_GRANULARITY_SEGMENT)
+			hw.info |= SNDRV_PCM_INFO_BATCH;
+
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			addr_widths = dma_caps.dst_addr_widths;
+		else
+			addr_widths = dma_caps.src_addr_widths;
+	}
+
+	/*
+	 * Prepare formats mask for valid/allowed sample types. If the dma does
+	 * not have support for the given physical word size, it needs to be
+	 * masked out so user space can not use the format which produces
+	 * corrupted audio.
+	 * In case the dma driver does not implement the slave_caps the default
+	 * assumption is that it supports 1, 2 and 4 bytes widths.
+	 */
+	for (i = 0; i <= SNDRV_PCM_FORMAT_LAST; i++) {
+		int bits = snd_pcm_format_physical_width(i);
+
+		/* Enable only samples with DMA supported physical widths */
+		switch (bits) {
+		case 8:
+		case 16:
+		case 24:
+		case 32:
+		case 64:
+			if (addr_widths & (1 << (bits / 8)))
+				hw.formats |= (1LL << i);
+			break;
+		default:
+			/* Unsupported types */
+			break;
+		}
+	}
+
+	return snd_soc_set_runtime_hwparams(substream, &hw);
+}
+
+static int dmaengine_mpcm_open(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct dmaengine_mpcm *pcm = soc_platform_to_pcm(rtd->platform);
+	struct dmaengine_mpcm_runtime_data *prtd;
+	int ret, i;
+
+	ret = dmaengine_mpcm_set_runtime_hwparams(substream);
+	if (ret)
+		return ret;
+
+	ret = snd_pcm_hw_constraint_integer(substream->runtime,
+					    SNDRV_PCM_HW_PARAM_PERIODS);
+	if (ret < 0)
+		return ret;
+
+	prtd = kzalloc(sizeof(*prtd), GFP_KERNEL);
+	if (!prtd)
+		return -ENOMEM;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		prtd->channel_maps = pcm->mdais->playback_channel_maps;
+		for (i = 0; i < pcm->mdais->num_dais; i++)
+			prtd->chans[i] = pcm->tx_chans[i];
+	} else {
+		prtd->channel_maps = pcm->mdais->capture_channel_maps;
+		for (i = 0; i < pcm->mdais->num_dais; i++)
+			prtd->chans[i] = pcm->rx_chans[i];
+	}
+
+	prtd->num_chans = pcm->mdais->num_dais;
+	prtd->start_flag = false;
+	substream->runtime->private_data = prtd;
+
+	return 0;
+}
+
+static int dmaengine_mpcm_new(struct snd_soc_pcm_runtime *rtd)
+{
+	struct dmaengine_mpcm *pcm = soc_platform_to_pcm(rtd->platform);
+	struct snd_pcm_substream *substream;
+	size_t prealloc_buffer_size;
+	size_t max_buffer_size;
+	unsigned int i;
+	int ret;
+
+	prealloc_buffer_size = 512 * 1024;
+	max_buffer_size = SIZE_MAX;
+
+	for (i = SNDRV_PCM_STREAM_PLAYBACK; i <= SNDRV_PCM_STREAM_CAPTURE; i++) {
+		substream = rtd->pcm->streams[i].substream;
+		if (!substream)
+			continue;
+
+		ret = snd_pcm_lib_preallocate_pages(substream,
+						    SNDRV_DMA_TYPE_DEV_IRAM,
+						    dmaengine_dma_dev(pcm, substream),
+						    prealloc_buffer_size,
+						    max_buffer_size);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static snd_pcm_uframes_t dmaengine_mpcm_pointer(struct snd_pcm_substream *substream)
+{
+	struct dmaengine_mpcm_runtime_data *prtd = substream_to_prtd(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct dma_tx_state state;
+	snd_pcm_uframes_t frames;
+	unsigned int buf_size;
+	unsigned int pos = 0;
+	unsigned int master = prtd->master_chan;
+
+	buf_size = snd_pcm_lib_buffer_bytes(substream);
+	dmaengine_tx_status(prtd->chans[master], prtd->cookies[master], &state);
+	if (state.residue > 0 && state.residue <= buf_size)
+		pos = buf_size - state.residue;
+
+	frames = bytes_to_frames(substream->runtime, pos);
+#ifdef CONFIG_SND_SOC_ROCKCHIP_VAD
+	if (prtd->vpos)
+		frames = bytes_to_frames(substream->runtime, prtd->vpos);
+#endif
+	if (!prtd->start_flag && frames >= MAX_FIFO_SIZE)
+		prtd->start_flag = true;
+
+	if (prtd->start_flag) {
+		if (frames >= MAX_FIFO_SIZE)
+			frames -= MAX_FIFO_SIZE;
+		else
+			frames = runtime->buffer_size + frames - MAX_FIFO_SIZE;
+	} else {
+		frames = 0;
+	}
+
+	return frames;
+}
+
+static int dmaengine_mpcm_close(struct snd_pcm_substream *substream)
+{
+	struct dmaengine_mpcm_runtime_data *prtd = substream_to_prtd(substream);
+
+	kfree(prtd);
+
+	return 0;
+}
+
+static const struct snd_pcm_ops dmaengine_mpcm_ops = {
+	.open		= dmaengine_mpcm_open,
+	.close		= dmaengine_mpcm_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= dmaengine_mpcm_hw_params,
+	.hw_free	= snd_pcm_lib_free_pages,
+	.trigger	= snd_dmaengine_mpcm_trigger,
+	.pointer	= dmaengine_mpcm_pointer,
+};
+
+static const struct snd_soc_platform_driver dmaengine_mpcm_platform = {
+	.component_driver = {
+		.probe_order = SND_SOC_COMP_ORDER_LATE,
+	},
+	.ops		= &dmaengine_mpcm_ops,
+	.pcm_new	= dmaengine_mpcm_new,
+};
+
+static void dmaengine_mpcm_release_chan(struct dmaengine_mpcm *pcm)
+{
+	int i;
+
+	for (i = 0; i < pcm->mdais->num_dais; i++) {
+		if (pcm->tx_chans[i])
+			dma_release_channel(pcm->tx_chans[i]);
+		if (pcm->rx_chans[i])
+			dma_release_channel(pcm->rx_chans[i]);
+	}
+}
+
+int snd_dmaengine_mpcm_register(struct rk_mdais_dev *mdais)
+{
+	struct device *dev;
+	struct device *child;
+	struct dmaengine_mpcm *pcm;
+	struct dma_chan *chan;
+	unsigned int *tx_maps, *rx_maps;
+	int ret, i, num;
+
+	dev = mdais->dev;
+	num = mdais->num_dais;
+	tx_maps = mdais->playback_channel_maps;
+	rx_maps = mdais->capture_channel_maps;
+	pcm = kzalloc(sizeof(*pcm), GFP_KERNEL);
+	if (!pcm)
+		return -ENOMEM;
+
+	pcm->mdais = mdais;
+	for (i = 0; i < num; i++) {
+		child = mdais->dais[i].dev;
+		if (tx_maps[i]) {
+			chan = dma_request_slave_channel_reason(child, "tx");
+			if (IS_ERR(chan))
+				chan = NULL;
+			pcm->tx_chans[i] = chan;
+		}
+
+		if (rx_maps[i]) {
+			chan = dma_request_slave_channel_reason(child, "rx");
+			if (IS_ERR(chan))
+				chan = NULL;
+			pcm->rx_chans[i] = chan;
+		}
+	}
+
+	ret = snd_soc_add_platform(dev, &pcm->platform,
+				   &dmaengine_mpcm_platform);
+	if (ret)
+		goto err_free_dma;
+
+	return 0;
+
+err_free_dma:
+	dmaengine_mpcm_release_chan(pcm);
+	kfree(pcm);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(snd_dmaengine_mpcm_register);
+
+void snd_dmaengine_mpcm_unregister(struct device *dev)
+{
+	struct snd_soc_platform *platform;
+	struct dmaengine_mpcm *pcm;
+
+	platform = snd_soc_lookup_platform(dev);
+	if (!platform)
+		return;
+
+	pcm = soc_platform_to_pcm(platform);
+
+	snd_soc_remove_platform(platform);
+	dmaengine_mpcm_release_chan(pcm);
+	kfree(pcm);
+}
+EXPORT_SYMBOL_GPL(snd_dmaengine_mpcm_unregister);
+
+MODULE_LICENSE("GPL");
Index: linux-5.10.27/sound/soc/rockchip/rockchip_multicodecs.c
===================================================================
--- /dev/null
+++ linux-5.10.27/sound/soc/rockchip/rockchip_multicodecs.c
@@ -0,0 +1,346 @@
+/*
+ * Rockchip machine ASoC driver for Rockchip Multi-codecs audio
+ *
+ * Copyright (C) 2018 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * Authors: Sugar Zhang <sugar.zhang@rock-chips.com>,
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <sound/core.h>
+#include <sound/jack.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#include "../codecs/rk3308_codec_provider.h"
+
+#define DRV_NAME "rk-multicodecs"
+#define MAX_CODECS	2
+#define WAIT_CARDS	(SNDRV_CARDS - 1)
+#define DEFAULT_MCLK_FS	256
+
+struct multicodecs_data {
+	struct snd_soc_card snd_card;
+	struct snd_soc_dai_link dai_link;
+	unsigned int mclk_fs;
+	bool codec_hp_det;
+};
+
+static struct snd_soc_jack mc_hp_jack;
+
+static int rk_multicodecs_hw_params(struct snd_pcm_substream *substream,
+				    struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
+	struct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);
+	struct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);
+
+
+	struct multicodecs_data *mc_data = snd_soc_card_get_drvdata(rtd->card);
+	unsigned int mclk;
+	int ret;
+
+	mclk = params_rate(params) * mc_data->mclk_fs;
+
+	ret = snd_soc_dai_set_sysclk(codec_dai, substream->stream, mclk,
+				     SND_SOC_CLOCK_IN);
+	if (ret && ret != -ENOTSUPP) {
+		pr_err("Set codec_dai sysclk failed: %d\n", ret);
+		goto out;
+	}
+
+	ret = snd_soc_dai_set_sysclk(cpu_dai, substream->stream, mclk,
+				     SND_SOC_CLOCK_OUT);
+	if (ret && ret != -ENOTSUPP) {
+		pr_err("Set cpu_dai sysclk failed: %d\n", ret);
+		goto out;
+	}
+
+	return 0;
+
+out:
+	return ret;
+}
+
+static int rk_dailink_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct multicodecs_data *mc_data = snd_soc_card_get_drvdata(rtd->card);
+
+	if (mc_data->codec_hp_det) {
+		snd_soc_card_jack_new(rtd->card, "Headphones",
+				      SND_JACK_HEADPHONE,
+				      &mc_hp_jack, NULL, 0);
+
+#ifdef CONFIG_SND_SOC_RK3308
+		rk3308_codec_set_jack_detect(asoc_rtd_to_codec(rtd, 0)->component, &mc_hp_jack);
+#endif
+	}
+
+	return 0;
+}
+
+static int rk_multicodecs_parse_daifmt(struct device_node *node,
+				       struct device_node *codec,
+				       struct multicodecs_data *mc_data,
+				       const char *prefix)
+{
+	struct snd_soc_dai_link *dai_link = &mc_data->dai_link;
+	struct device_node *bitclkmaster = NULL;
+	struct device_node *framemaster = NULL;
+	unsigned int daifmt;
+
+	daifmt = snd_soc_of_parse_daifmt(node, prefix,
+					 &bitclkmaster, &framemaster);
+
+	daifmt &= ~SND_SOC_DAIFMT_MASTER_MASK;
+
+	if (strlen(prefix) && !bitclkmaster && !framemaster) {
+		/*
+		 * No dai-link level and master setting was not found from
+		 * sound node level, revert back to legacy DT parsing and
+		 * take the settings from codec node.
+		 */
+		pr_debug("%s: Revert to legacy daifmt parsing\n", __func__);
+
+		daifmt = snd_soc_of_parse_daifmt(codec, NULL, NULL, NULL) |
+			(daifmt & ~SND_SOC_DAIFMT_CLOCK_MASK);
+	} else {
+		if (codec == bitclkmaster)
+			daifmt |= (codec == framemaster) ?
+				SND_SOC_DAIFMT_CBM_CFM : SND_SOC_DAIFMT_CBM_CFS;
+		else
+			daifmt |= (codec == framemaster) ?
+				SND_SOC_DAIFMT_CBS_CFM : SND_SOC_DAIFMT_CBS_CFS;
+	}
+
+	/*
+	 * If there is NULL format means that the format isn't specified, we
+	 * need to set i2s format by default.
+	 */
+	if (!(daifmt & SND_SOC_DAIFMT_FORMAT_MASK))
+		daifmt |= SND_SOC_DAIFMT_I2S;
+
+	dai_link->dai_fmt = daifmt;
+
+	of_node_put(bitclkmaster);
+	of_node_put(framemaster);
+
+	return 0;
+}
+
+static int wait_locked_card(struct device_node *np, struct device *dev)
+{
+	char *propname = "rockchip,wait-card-locked";
+	u32 cards[WAIT_CARDS];
+	int num, i;
+	int ret;
+
+	ret = of_property_count_u32_elems(np, propname);
+	if (ret < 0) {
+		if (ret == -EINVAL) {
+			/*
+			 * -EINVAL means the property does not exist, this is
+			 * fine.
+			 */
+			return 0;
+		}
+
+		dev_err(dev, "Property '%s' elems could not be read: %d\n",
+			propname, ret);
+		return ret;
+	}
+
+	num = ret;
+	if (num > WAIT_CARDS)
+		num = WAIT_CARDS;
+
+	ret = of_property_read_u32_array(np, propname, cards, num);
+	if (ret < 0) {
+		if (ret == -EINVAL) {
+			/*
+			 * -EINVAL means the property does not exist, this is
+			 * fine.
+			 */
+			return 0;
+		}
+
+		dev_err(dev, "Property '%s' could not be read: %d\n",
+			propname, ret);
+		return ret;
+	}
+
+	ret = 0;
+	for (i = 0; i < num; i++) {
+		if (!snd_card_locked(cards[i])) {
+			dev_warn(dev, "card: %d has not been locked, re-probe again\n",
+				 cards[i]);
+			ret = -EPROBE_DEFER;
+			break;
+		}
+	}
+
+	return ret;
+}
+
+static struct snd_soc_ops rk_ops = {
+	.hw_params = rk_multicodecs_hw_params,
+};
+
+static int rk_multicodecs_probe(struct platform_device *pdev)
+{
+	struct snd_soc_card *card;
+	struct device_node *np = pdev->dev.of_node;
+	struct snd_soc_dai_link *link;
+	struct snd_soc_dai_link_component *codecs;
+	struct multicodecs_data *mc_data;
+	struct of_phandle_args args;
+	struct device_node *node;
+	u32 val;
+	int count;
+	int ret = 0, i = 0, idx = 0;
+	const char *prefix = "rockchip,";
+	struct device_node *np_cpu;
+
+	ret = wait_locked_card(np, &pdev->dev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "check_lock_card failed: %d\n", ret);
+		return ret;
+	}
+
+	mc_data = devm_kzalloc(&pdev->dev, sizeof(*mc_data), GFP_KERNEL);
+	if (!mc_data)
+		return -ENOMEM;
+
+	card = &mc_data->snd_card;
+	card->dev = &pdev->dev;
+
+	/* Parse the card name from DT */
+	ret = snd_soc_of_parse_card_name(card, "rockchip,card-name");
+	if (ret < 0)
+		return ret;
+
+	link = &mc_data->dai_link;
+	link->name = "dailink-multicodecs";
+	link->stream_name = link->name;
+	link->init = rk_dailink_init;
+	link->ops = &rk_ops;
+
+	card->dai_link = link;
+	card->num_links = 1;
+	card->num_aux_devs = 0;
+
+	count = of_count_phandle_with_args(np, "rockchip,codec", NULL);
+	if (count < 0 || count > MAX_CODECS)
+		return -EINVAL;
+
+	/* refine codecs, remove unavailable node */
+	for (i = 0; i < count; i++) {
+		node = of_parse_phandle(np, "rockchip,codec", i);
+		if (!node)
+			return -ENODEV;
+		if (of_device_is_available(node))
+			idx++;
+	}
+
+	if (!idx)
+		return -ENODEV;
+
+	codecs = devm_kcalloc(&pdev->dev, idx,
+			      sizeof(*codecs), GFP_KERNEL);
+	link->codecs = codecs;
+	link->num_codecs = idx;
+	idx = 0;
+	for (i = 0; i < count; i++) {
+		node = of_parse_phandle(np, "rockchip,codec", i);
+		if (!node)
+			return -ENODEV;
+		if (!of_device_is_available(node))
+			continue;
+
+		ret = of_parse_phandle_with_fixed_args(np, "rockchip,codec",
+						       0, i, &args);
+		if (ret)
+			return ret;
+
+		codecs[idx].of_node = node;
+		ret = snd_soc_get_dai_name(&args, &codecs[idx].dai_name);
+		if (ret)
+			return ret;
+		idx++;
+	}
+
+	/* Only reference the codecs[0].of_node which maybe as master. */
+	rk_multicodecs_parse_daifmt(np, codecs[0].of_node, mc_data, prefix);
+
+	np_cpu = of_parse_phandle(np, "rockchip,cpu", 0);
+	if (!np_cpu)
+		return -ENODEV;
+
+	link->platforms = devm_kcalloc(&pdev->dev, 1,
+			      sizeof(*link->platforms), GFP_KERNEL);
+	link->cpus = devm_kcalloc(&pdev->dev, 1,
+			      sizeof(*link->cpus), GFP_KERNEL);
+	link->platforms->of_node = link->cpus->of_node = np_cpu;
+	link->num_cpus=link->num_platforms=1;
+
+	mc_data->mclk_fs = DEFAULT_MCLK_FS;
+	if (!of_property_read_u32(np, "rockchip,mclk-fs", &val))
+		mc_data->mclk_fs = val;
+
+	mc_data->codec_hp_det =
+		of_property_read_bool(np, "rockchip,codec-hp-det");
+
+	snd_soc_card_set_drvdata(card, mc_data);
+
+	ret = devm_snd_soc_register_card(&pdev->dev, card);
+	if (ret == -EPROBE_DEFER)
+		return -EPROBE_DEFER;
+	if (ret) {
+		dev_err(&pdev->dev, "card register failed %d\n", ret);
+		return ret;
+	}
+
+	platform_set_drvdata(pdev, card);
+
+	return ret;
+}
+
+static const struct of_device_id rockchip_multicodecs_of_match[] = {
+	{ .compatible = "rockchip,multicodecs-card", },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, rockchip_multicodecs_of_match);
+
+static struct platform_driver rockchip_multicodecs_driver = {
+	.probe = rk_multicodecs_probe,
+	.driver = {
+		.name = DRV_NAME,
+		.pm = &snd_soc_pm_ops,
+		.of_match_table = rockchip_multicodecs_of_match,
+	},
+};
+
+module_platform_driver(rockchip_multicodecs_driver);
+
+MODULE_AUTHOR("Sugar Zhang <sugar.zhang@rock-chips.com>");
+MODULE_DESCRIPTION("Rockchip General Multicodecs ASoC driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" DRV_NAME);
Index: linux-5.10.27/sound/soc/rockchip/rockchip_pdm.c
===================================================================
--- linux-5.10.27.orig/sound/soc/rockchip/rockchip_pdm.c
+++ linux-5.10.27/sound/soc/rockchip/rockchip_pdm.c
@@ -1,8 +1,17 @@
-// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Rockchip PDM ALSA SoC Digital Audio Interface(DAI)  driver
  *
  * Copyright (C) 2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
  */
 
 #include <linux/module.h>
@@ -149,7 +158,7 @@ static int rockchip_pdm_hw_params(struct
 	struct rk_pdm_dev *pdm = to_info(dai);
 	unsigned int val = 0;
 	unsigned int clk_rate, clk_div, samplerate;
-	unsigned int clk_src, clk_out = 0;
+	unsigned int clk_src, clk_out;
 	unsigned long m, n;
 	bool change;
 	int ret;
@@ -201,9 +210,7 @@ static int rockchip_pdm_hw_params(struct
 	regmap_update_bits(pdm->regmap, PDM_HPF_CTRL,
 			   PDM_HPF_LE | PDM_HPF_RE, PDM_HPF_LE | PDM_HPF_RE);
 	regmap_update_bits(pdm->regmap, PDM_CLK_CTRL, PDM_CLK_EN, PDM_CLK_EN);
-	if (pdm->version != RK_PDM_RK3229)
-		regmap_update_bits(pdm->regmap, PDM_CTRL0,
-				   PDM_MODE_MSK, PDM_MODE_LJ);
+	regmap_update_bits(pdm->regmap, PDM_CTRL0, PDM_MODE_MSK, PDM_MODE_LJ);
 
 	val = 0;
 	switch (params_format(params)) {
@@ -229,13 +236,13 @@ static int rockchip_pdm_hw_params(struct
 	switch (params_channels(params)) {
 	case 8:
 		val |= PDM_PATH3_EN;
-		fallthrough;
+		/* fallthrough */
 	case 6:
 		val |= PDM_PATH2_EN;
-		fallthrough;
+		/* fallthrough */
 	case 4:
 		val |= PDM_PATH1_EN;
-		fallthrough;
+		/* fallthrough */
 	case 2:
 		val |= PDM_PATH0_EN;
 		break;
@@ -248,9 +255,8 @@ static int rockchip_pdm_hw_params(struct
 	regmap_update_bits(pdm->regmap, PDM_CTRL0,
 			   PDM_PATH_MSK | PDM_VDW_MSK,
 			   val);
-	/* all channels share the single FIFO */
 	regmap_update_bits(pdm->regmap, PDM_DMA_CTRL, PDM_DMA_RDL_MSK,
-			   PDM_DMA_RDL(8 * params_channels(params)));
+			   PDM_DMA_RDL(16));
 
 	return 0;
 }
@@ -316,7 +322,7 @@ static int rockchip_pdm_dai_probe(struct
 	return 0;
 }
 
-static const struct snd_soc_dai_ops rockchip_pdm_dai_ops = {
+static struct snd_soc_dai_ops rockchip_pdm_dai_ops = {
 	.set_fmt = rockchip_pdm_set_fmt,
 	.trigger = rockchip_pdm_trigger,
 	.hw_params = rockchip_pdm_hw_params,
@@ -408,7 +414,6 @@ static bool rockchip_pdm_rd_reg(struct d
 	case PDM_INT_CLR:
 	case PDM_INT_ST:
 	case PDM_DATA_VALID:
-	case PDM_RXFIFO_DATA:
 	case PDM_VERSION:
 		return true;
 	default:
@@ -423,17 +428,6 @@ static bool rockchip_pdm_volatile_reg(st
 	case PDM_FIFO_CTRL:
 	case PDM_INT_CLR:
 	case PDM_INT_ST:
-	case PDM_RXFIFO_DATA:
-		return true;
-	default:
-		return false;
-	}
-}
-
-static bool rockchip_pdm_precious_reg(struct device *dev, unsigned int reg)
-{
-	switch (reg) {
-	case PDM_RXFIFO_DATA:
 		return true;
 	default:
 		return false;
@@ -456,17 +450,13 @@ static const struct regmap_config rockch
 	.writeable_reg = rockchip_pdm_wr_reg,
 	.readable_reg = rockchip_pdm_rd_reg,
 	.volatile_reg = rockchip_pdm_volatile_reg,
-	.precious_reg = rockchip_pdm_precious_reg,
 	.cache_type = REGCACHE_FLAT,
 };
 
 static const struct of_device_id rockchip_pdm_match[] = {
-	{ .compatible = "rockchip,pdm",
-	  .data = (void *)RK_PDM_RK3229 },
+	{ .compatible = "rockchip,pdm", },
 	{ .compatible = "rockchip,px30-pdm",
 	  .data = (void *)RK_PDM_RK3308 },
-	{ .compatible = "rockchip,rk1808-pdm",
-	  .data = (void *)RK_PDM_RK3308 },
 	{ .compatible = "rockchip,rk3308-pdm",
 	  .data = (void *)RK_PDM_RK3308 },
 	{},
@@ -475,6 +465,7 @@ MODULE_DEVICE_TABLE(of, rockchip_pdm_mat
 
 static int rockchip_pdm_probe(struct platform_device *pdev)
 {
+	struct device_node *node = pdev->dev.of_node;
 	const struct of_device_id *match;
 	struct rk_pdm_dev *pdm;
 	struct resource *res;
@@ -541,6 +532,8 @@ static int rockchip_pdm_probe(struct pla
 	}
 
 	rockchip_pdm_rxctrl(pdm, 0);
+	if (of_property_read_bool(node, "rockchip,no-dmaengine"))
+		return ret;
 	ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
 	if (ret) {
 		dev_err(&pdev->dev, "could not register pcm: %d\n", ret);
@@ -590,10 +583,8 @@ static int rockchip_pdm_resume(struct de
 	int ret;
 
 	ret = pm_runtime_get_sync(dev);
-	if (ret < 0) {
-		pm_runtime_put(dev);
+	if (ret < 0)
 		return ret;
-	}
 
 	ret = regcache_sync(pdm->regmap);
 
Index: linux-5.10.27/sound/soc/rockchip/rockchip_pdm.h
===================================================================
--- linux-5.10.27.orig/sound/soc/rockchip/rockchip_pdm.h
+++ linux-5.10.27/sound/soc/rockchip/rockchip_pdm.h
@@ -1,8 +1,17 @@
-/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Rockchip PDM ALSA SoC Digital Audio Interface(DAI)  driver
  *
  * Copyright (C) 2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
  */
 
 #ifndef _ROCKCHIP_PDM_H
Index: linux-5.10.27/sound/soc/rockchip/rockchip_spdif.c
===================================================================
--- linux-5.10.27.orig/sound/soc/rockchip/rockchip_spdif.c
+++ linux-5.10.27/sound/soc/rockchip/rockchip_spdif.c
@@ -1,4 +1,3 @@
-// SPDX-License-Identifier: GPL-2.0-only
 /* sound/soc/rockchip/rk_spdif.c
  *
  * ALSA SoC Audio Layer - Rockchip I2S Controller driver
@@ -7,6 +6,10 @@
  * Author: Jianqun <jay.xu@rock-chips.com>
  * Copyright (c) 2015 Collabora Ltd.
  * Author: Sjoerd Simons <sjoerd.simons@collabora.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
  */
 
 #include <linux/module.h>
@@ -66,7 +69,6 @@ static int __maybe_unused rk_spdif_runti
 {
 	struct rk_spdif_dev *spdif = dev_get_drvdata(dev);
 
-	regcache_cache_only(spdif->regmap, true);
 	clk_disable_unprepare(spdif->mclk);
 	clk_disable_unprepare(spdif->hclk);
 
@@ -90,16 +92,7 @@ static int __maybe_unused rk_spdif_runti
 		return ret;
 	}
 
-	regcache_cache_only(spdif->regmap, false);
-	regcache_mark_dirty(spdif->regmap);
-
-	ret = regcache_sync(spdif->regmap);
-	if (ret) {
-		clk_disable_unprepare(spdif->mclk);
-		clk_disable_unprepare(spdif->hclk);
-	}
-
-	return ret;
+	return 0;
 }
 
 static int rk_spdif_hw_params(struct snd_pcm_substream *substream,
@@ -112,7 +105,21 @@ static int rk_spdif_hw_params(struct snd
 	int ret;
 
 	srate = params_rate(params);
-	mclk = srate * 128;
+	switch (srate) {
+	case 32000:
+	case 48000:
+	case 96000:
+		mclk = 96000 * 128; /* 12288000 hz */
+		break;
+	case 44100:
+		mclk = 44100 * 256; /* 11289600 hz */
+		break;
+	case 192000:
+		mclk = 192000 * 128; /* 24576000 hz */
+		break;
+	default:
+		return -EINVAL;
+	}
 
 	switch (params_format(params)) {
 	case SNDRV_PCM_FORMAT_S16_LE:
@@ -136,6 +143,7 @@ static int rk_spdif_hw_params(struct snd
 		return ret;
 	}
 
+	val |= SPDIF_CFGR_CLK_DIV(mclk/(srate * 256));
 	ret = regmap_update_bits(spdif->regmap, SPDIF_CFGR,
 		SPDIF_CFGR_CLK_DIV_MASK | SPDIF_CFGR_HALFWORD_ENABLE |
 		SDPIF_CFGR_VDW_MASK,
@@ -306,22 +314,44 @@ static int rk_spdif_probe(struct platfor
 		return -ENOMEM;
 
 	spdif->hclk = devm_clk_get(&pdev->dev, "hclk");
-	if (IS_ERR(spdif->hclk))
+	if (IS_ERR(spdif->hclk)) {
+		dev_err(&pdev->dev, "Can't retrieve rk_spdif bus clock\n");
 		return PTR_ERR(spdif->hclk);
+	}
+	ret = clk_prepare_enable(spdif->hclk);
+	if (ret) {
+		dev_err(spdif->dev, "hclock enable failed %d\n", ret);
+		return ret;
+	}
 
 	spdif->mclk = devm_clk_get(&pdev->dev, "mclk");
-	if (IS_ERR(spdif->mclk))
-		return PTR_ERR(spdif->mclk);
+	if (IS_ERR(spdif->mclk)) {
+		dev_err(&pdev->dev, "Can't retrieve rk_spdif master clock\n");
+		ret = PTR_ERR(spdif->mclk);
+		goto err_disable_hclk;
+	}
+
+	ret = clk_prepare_enable(spdif->mclk);
+	if (ret) {
+		dev_err(spdif->dev, "clock enable failed %d\n", ret);
+		goto err_disable_clocks;
+	}
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	regs = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(regs))
-		return PTR_ERR(regs);
+	if (IS_ERR(regs)) {
+		ret = PTR_ERR(regs);
+		goto err_disable_clocks;
+	}
 
 	spdif->regmap = devm_regmap_init_mmio_clk(&pdev->dev, "hclk", regs,
 						  &rk_spdif_regmap_config);
-	if (IS_ERR(spdif->regmap))
-		return PTR_ERR(spdif->regmap);
+	if (IS_ERR(spdif->regmap)) {
+		dev_err(&pdev->dev,
+			"Failed to initialise managed register map\n");
+		ret = PTR_ERR(spdif->regmap);
+		goto err_disable_clocks;
+	}
 
 	spdif->playback_dma_data.addr = res->start + SPDIF_SMPDR;
 	spdif->playback_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
@@ -330,50 +360,79 @@ static int rk_spdif_probe(struct platfor
 	spdif->dev = &pdev->dev;
 	dev_set_drvdata(&pdev->dev, spdif);
 
+	pm_runtime_set_active(&pdev->dev);
 	pm_runtime_enable(&pdev->dev);
-	if (!pm_runtime_enabled(&pdev->dev)) {
-		ret = rk_spdif_runtime_resume(&pdev->dev);
-		if (ret)
-			goto err_pm_runtime;
-	}
+	pm_request_idle(&pdev->dev);
 
 	ret = devm_snd_soc_register_component(&pdev->dev,
 					      &rk_spdif_component,
 					      &rk_spdif_dai, 1);
 	if (ret) {
 		dev_err(&pdev->dev, "Could not register DAI\n");
-		goto err_pm_suspend;
+		goto err_pm_runtime;
 	}
 
 	ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
 	if (ret) {
 		dev_err(&pdev->dev, "Could not register PCM\n");
-		goto err_pm_suspend;
+		goto err_pm_runtime;
 	}
 
 	return 0;
 
-err_pm_suspend:
-	if (!pm_runtime_status_suspended(&pdev->dev))
-		rk_spdif_runtime_suspend(&pdev->dev);
 err_pm_runtime:
 	pm_runtime_disable(&pdev->dev);
+err_disable_clocks:
+	clk_disable_unprepare(spdif->mclk);
+err_disable_hclk:
+	clk_disable_unprepare(spdif->hclk);
 
 	return ret;
 }
 
 static int rk_spdif_remove(struct platform_device *pdev)
 {
+	struct rk_spdif_dev *spdif = dev_get_drvdata(&pdev->dev);
+
 	pm_runtime_disable(&pdev->dev);
 	if (!pm_runtime_status_suspended(&pdev->dev))
 		rk_spdif_runtime_suspend(&pdev->dev);
 
+	clk_disable_unprepare(spdif->mclk);
+	clk_disable_unprepare(spdif->hclk);
+
 	return 0;
 }
 
+#ifdef CONFIG_PM_SLEEP
+static int rockchip_spdif_suspend(struct device *dev)
+{
+	struct rk_spdif_dev *spdif = dev_get_drvdata(dev);
+
+	regcache_mark_dirty(spdif->regmap);
+
+	return 0;
+}
+
+static int rockchip_spdif_resume(struct device *dev)
+{
+	struct rk_spdif_dev *spdif = dev_get_drvdata(dev);
+	int ret;
+
+	ret = pm_runtime_get_sync(dev);
+	if (ret < 0)
+		return ret;
+	ret = regcache_sync(spdif->regmap);
+	pm_runtime_put(dev);
+
+	return ret;
+}
+#endif
+
 static const struct dev_pm_ops rk_spdif_pm_ops = {
 	SET_RUNTIME_PM_OPS(rk_spdif_runtime_suspend, rk_spdif_runtime_resume,
 			   NULL)
+	SET_SYSTEM_SLEEP_PM_OPS(rockchip_spdif_suspend, rockchip_spdif_resume)
 };
 
 static struct platform_driver rk_spdif_driver = {
Index: linux-5.10.27/sound/soc/rockchip/rockchip_spdif.h
===================================================================
--- linux-5.10.27.orig/sound/soc/rockchip/rockchip_spdif.h
+++ linux-5.10.27/sound/soc/rockchip/rockchip_spdif.h
@@ -1,9 +1,12 @@
-/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * ALSA SoC Audio Layer - Rockchip SPDIF transceiver driver
  *
  * Copyright (c) 2015 Collabora Ltd.
  * Author: Sjoerd Simons <sjoerd.simons@collabora.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
  */
 
 #ifndef _ROCKCHIP_SPDIF_H
Index: linux-5.10.27/sound/soc/rockchip/Kconfig
===================================================================
--- linux-5.10.27.orig/sound/soc/rockchip/Kconfig
+++ linux-5.10.27/sound/soc/rockchip/Kconfig
@@ -7,20 +7,42 @@ config SND_SOC_ROCKCHIP
 	  the Rockchip SoCs' Audio interfaces. You will also need to
 	  select the audio interfaces to support below.
 
+config SND_SOC_ROCKCHIP_FORCE_SRAM
+	bool "Rockchip force using sram buffer"
+	def_bool n
+	help
+	  Say Y if you want to force using sram buffer for pcm buffer,
+	  but the sram size is limited.
+
 config SND_SOC_ROCKCHIP_I2S
 	tristate "Rockchip I2S Device Driver"
 	depends on CLKDEV_LOOKUP && SND_SOC_ROCKCHIP
 	select SND_SOC_GENERIC_DMAENGINE_PCM
 	help
 	  Say Y or M if you want to add support for I2S driver for
-	  Rockchip I2S device. The device supports upto maximum of
+	  Rockchip I2S device. The device supports up to maximum of
 	  8 channels each for play and record.
 
+config SND_SOC_ROCKCHIP_I2S_TDM
+	tristate "Rockchip I2S/TDM Device Driver"
+	depends on CLKDEV_LOOKUP && SND_SOC_ROCKCHIP
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	help
+	  Say Y or M if you want to add support for I2S/TDM driver for
+	  Rockchip I2S/TDM device. The device supports up to maximum of
+	  8 channels each for play and record.
+
+config SND_SOC_ROCKCHIP_MULTI_DAIS
+	tristate "Rockchip Multi-DAIS Device Driver"
+	depends on CLKDEV_LOOKUP && SND_SOC_ROCKCHIP
+	help
+	  Say Y or M if you want to add support for Multi-dais driver for
+	  Rockchip.
+
 config SND_SOC_ROCKCHIP_PDM
 	tristate "Rockchip PDM Controller Driver"
 	depends on CLKDEV_LOOKUP && SND_SOC_ROCKCHIP
 	select SND_SOC_GENERIC_DMAENGINE_PCM
-	select RATIONAL
 	help
 	  Say Y or M if you want to add support for PDM driver for
 	  Rockchip PDM Controller. The Controller supports up to maximum of
@@ -34,6 +56,14 @@ config SND_SOC_ROCKCHIP_SPDIF
 	  Say Y or M if you want to add support for SPDIF driver for
 	  Rockchip SPDIF transceiver device.
 
+config SND_SOC_ROCKCHIP_SPDIFRX
+	tristate "Rockchip SPDIFRX Device Driver"
+	depends on CLKDEV_LOOKUP && SND_SOC_ROCKCHIP
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	help
+	  Say Y or M if you want to add support for SPDIFRX driver for
+	  Rockchip SPDIF receiver device.
+
 config SND_SOC_ROCKCHIP_MAX98090
 	tristate "ASoC support for Rockchip boards using a MAX98090 codec"
 	depends on SND_SOC_ROCKCHIP && I2C && GPIOLIB && CLKDEV_LOOKUP
@@ -45,6 +75,13 @@ config SND_SOC_ROCKCHIP_MAX98090
 	  Say Y or M here if you want to add support for SoC audio on Rockchip
 	  boards using the MAX98090 codec and HDMI codec, such as Veyron.
 
+config SND_SOC_ROCKCHIP_MULTICODECS
+	tristate "ASoC support for Rockchip multicodecs"
+	depends on SND_SOC_ROCKCHIP && CLKDEV_LOOKUP
+	help
+	  Say Y or M here if you want to add support for SoC audio on Rockchip
+	  boards using multicodecs, such as RK3308 boards.
+
 config SND_SOC_ROCKCHIP_RT5645
 	tristate "ASoC support for Rockchip boards using a RT5645/RT5650 codec"
 	depends on SND_SOC_ROCKCHIP && I2C && GPIOLIB && CLKDEV_LOOKUP
Index: linux-5.10.27/sound/soc/rockchip/rockchip_spdifrx.c
===================================================================
--- /dev/null
+++ linux-5.10.27/sound/soc/rockchip/rockchip_spdifrx.c
@@ -0,0 +1,403 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * ALSA SoC Audio Layer - Rockchip SPDIF_RX Controller driver
+ *
+ * Copyright (C) 2018 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/of_gpio.h>
+#include <linux/clk.h>
+#include <linux/pm_runtime.h>
+#include <linux/mfd/syscon.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include <sound/pcm_params.h>
+#include <sound/dmaengine_pcm.h>
+
+#include "rockchip_spdifrx.h"
+
+struct rk_spdifrx_dev {
+	struct device *dev;
+	struct clk *mclk;
+	struct clk *hclk;
+	struct snd_dmaengine_dai_dma_data capture_dma_data;
+	struct regmap *regmap;
+	struct reset_control *reset;
+	int irq;
+};
+
+static int rk_spdifrx_runtime_suspend(struct device *dev)
+{
+	struct rk_spdifrx_dev *spdifrx = dev_get_drvdata(dev);
+
+	clk_disable_unprepare(spdifrx->mclk);
+	clk_disable_unprepare(spdifrx->hclk);
+
+	return 0;
+}
+
+static int rk_spdifrx_runtime_resume(struct device *dev)
+{
+	struct rk_spdifrx_dev *spdifrx = dev_get_drvdata(dev);
+	int ret;
+
+	ret = clk_prepare_enable(spdifrx->mclk);
+	if (ret) {
+		dev_err(spdifrx->dev, "mclk clock enable failed %d\n", ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(spdifrx->hclk);
+	if (ret) {
+		dev_err(spdifrx->dev, "hclk clock enable failed %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int rk_spdifrx_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params,
+				struct snd_soc_dai *dai)
+{
+	struct rk_spdifrx_dev *spdifrx = snd_soc_dai_get_drvdata(dai);
+
+	regmap_update_bits(spdifrx->regmap, SPDIFRX_INTEN,
+			   SPDIFRX_INTEN_SYNCIE_MASK |
+			   SPDIFRX_INTEN_NSYNCIE_MASK,
+			   SPDIFRX_INTEN_SYNCIE_EN |
+			   SPDIFRX_INTEN_NSYNCIE_EN);
+	regmap_update_bits(spdifrx->regmap, SPDIFRX_DMACR,
+			   SPDIFRX_DMACR_RDL_MASK, SPDIFRX_DMACR_RDL(8));
+	regmap_update_bits(spdifrx->regmap, SPDIFRX_CDR,
+			   SPDIFRX_CDR_AVGSEL_MASK | SPDIFRX_CDR_BYPASS_MASK,
+			   SPDIFRX_CDR_AVGSEL_MIN | SPDIFRX_CDR_BYPASS_DIS);
+	return 0;
+}
+
+static void rk_spdifrx_reset(struct rk_spdifrx_dev *spdifrx)
+{
+	reset_control_assert(spdifrx->reset);
+	udelay(1);
+	reset_control_deassert(spdifrx->reset);
+}
+
+static int rk_spdifrx_trigger(struct snd_pcm_substream *substream,
+			      int cmd, struct snd_soc_dai *dai)
+{
+	struct rk_spdifrx_dev *spdifrx = snd_soc_dai_get_drvdata(dai);
+	int ret;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		rk_spdifrx_reset(spdifrx);
+		ret = regmap_update_bits(spdifrx->regmap, SPDIFRX_DMACR,
+					 SPDIFRX_DMACR_RDE_MASK,
+					 SPDIFRX_DMACR_RDE_ENABLE);
+
+		if (ret != 0)
+			return ret;
+
+		ret = regmap_update_bits(spdifrx->regmap, SPDIFRX_CFGR,
+					 SPDIFRX_EN_MASK,
+					 SPDIFRX_EN);
+		break;
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		ret = regmap_update_bits(spdifrx->regmap, SPDIFRX_DMACR,
+					 SPDIFRX_DMACR_RDE_MASK,
+					 SPDIFRX_DMACR_RDE_DISABLE);
+
+		if (ret != 0)
+			return ret;
+
+		ret = regmap_update_bits(spdifrx->regmap, SPDIFRX_CFGR,
+					 SPDIFRX_EN_MASK,
+					 SPDIFRX_DIS);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static int rk_spdifrx_dai_probe(struct snd_soc_dai *dai)
+{
+	struct rk_spdifrx_dev *spdifrx = snd_soc_dai_get_drvdata(dai);
+
+	dai->capture_dma_data = &spdifrx->capture_dma_data;
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops rk_spdifrx_dai_ops = {
+	.hw_params = rk_spdifrx_hw_params,
+	.trigger = rk_spdifrx_trigger,
+};
+
+static struct snd_soc_dai_driver rk_spdifrx_dai = {
+	.probe = rk_spdifrx_dai_probe,
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = (SNDRV_PCM_RATE_32000 |
+			  SNDRV_PCM_RATE_44100 |
+			  SNDRV_PCM_RATE_48000 |
+			  SNDRV_PCM_RATE_96000 |
+			  SNDRV_PCM_RATE_192000),
+		.formats = (SNDRV_PCM_FMTBIT_S16_LE |
+			    SNDRV_PCM_FMTBIT_S20_3LE |
+			    SNDRV_PCM_FMTBIT_S24_LE),
+	},
+	.ops = &rk_spdifrx_dai_ops,
+};
+
+static const struct snd_soc_component_driver rk_spdifrx_component = {
+	.name = "rockchip-spdifrx",
+};
+
+static bool rk_spdifrx_wr_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case SPDIFRX_CFGR:
+	case SPDIFRX_CLR:
+	case SPDIFRX_CDR:
+	case SPDIFRX_CDRST:
+	case SPDIFRX_DMACR:
+	case SPDIFRX_FIFOCTRL:
+	case SPDIFRX_INTEN:
+	case SPDIFRX_INTMASK:
+	case SPDIFRX_INTSR:
+	case SPDIFRX_INTCLR:
+	case SPDIFRX_SMPDR:
+	case SPDIFRX_BURSTINFO:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool rk_spdifrx_rd_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case SPDIFRX_CFGR:
+	case SPDIFRX_CLR:
+	case SPDIFRX_CDR:
+	case SPDIFRX_CDRST:
+	case SPDIFRX_DMACR:
+	case SPDIFRX_FIFOCTRL:
+	case SPDIFRX_INTEN:
+	case SPDIFRX_INTMASK:
+	case SPDIFRX_INTSR:
+	case SPDIFRX_INTCLR:
+	case SPDIFRX_SMPDR:
+	case SPDIFRX_BURSTINFO:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool rk_spdifrx_volatile_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case SPDIFRX_CLR:
+	case SPDIFRX_CDR:
+	case SPDIFRX_CDRST:
+	case SPDIFRX_FIFOCTRL:
+	case SPDIFRX_INTSR:
+	case SPDIFRX_INTCLR:
+	case SPDIFRX_BURSTINFO:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static const struct regmap_config rk_spdifrx_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = SPDIFRX_BURSTINFO,
+	.writeable_reg = rk_spdifrx_wr_reg,
+	.readable_reg = rk_spdifrx_rd_reg,
+	.volatile_reg = rk_spdifrx_volatile_reg,
+	.cache_type = REGCACHE_FLAT,
+};
+
+static irqreturn_t rk_spdifrx_isr(int irq, void *dev_id)
+{
+	struct rk_spdifrx_dev *spdifrx = dev_id;
+	u32 intsr;
+
+	regmap_read(spdifrx->regmap, SPDIFRX_INTSR, &intsr);
+
+	if (intsr & BIT(7)) {
+		dev_dbg(spdifrx->dev, "NSYNC\n");
+		regmap_write(spdifrx->regmap, SPDIFRX_INTCLR, BIT(7));
+	}
+
+	if (intsr & BIT(9)) {
+		dev_dbg(spdifrx->dev, "SYNC\n");
+		regmap_write(spdifrx->regmap, SPDIFRX_INTCLR, BIT(9));
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int rk_spdifrx_probe(struct platform_device *pdev)
+{
+	struct rk_spdifrx_dev *spdifrx;
+	struct resource *res;
+	void __iomem *regs;
+	int ret;
+
+	spdifrx = devm_kzalloc(&pdev->dev, sizeof(*spdifrx), GFP_KERNEL);
+	if (!spdifrx)
+		return -ENOMEM;
+
+	spdifrx->reset = devm_reset_control_get(&pdev->dev, "spdifrx-m");
+	if (IS_ERR(spdifrx->reset)) {
+		ret = PTR_ERR(spdifrx->reset);
+		if (ret != -ENOENT)
+			return ret;
+	}
+
+	spdifrx->hclk = devm_clk_get(&pdev->dev, "hclk");
+	if (IS_ERR(spdifrx->hclk))
+		return PTR_ERR(spdifrx->hclk);
+
+	spdifrx->mclk = devm_clk_get(&pdev->dev, "mclk");
+	if (IS_ERR(spdifrx->mclk))
+		return PTR_ERR(spdifrx->mclk);
+
+	spdifrx->irq = platform_get_irq(pdev, 0);
+	if (spdifrx->irq < 0)
+		return spdifrx->irq;
+
+	ret = devm_request_threaded_irq(&pdev->dev, spdifrx->irq, NULL,
+					rk_spdifrx_isr,
+					IRQF_TRIGGER_HIGH | IRQF_ONESHOT,
+					dev_name(&pdev->dev), spdifrx);
+	if (ret)
+		return ret;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(regs))
+		return PTR_ERR(regs);
+
+	spdifrx->regmap = devm_regmap_init_mmio(&pdev->dev, regs,
+						&rk_spdifrx_regmap_config);
+	if (IS_ERR(spdifrx->regmap))
+		return PTR_ERR(spdifrx->regmap);
+
+	spdifrx->capture_dma_data.addr = res->start + SPDIFRX_SMPDR;
+	spdifrx->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	spdifrx->capture_dma_data.maxburst = 4;
+
+	spdifrx->dev = &pdev->dev;
+	dev_set_drvdata(&pdev->dev, spdifrx);
+
+	pm_runtime_enable(&pdev->dev);
+	if (!pm_runtime_enabled(&pdev->dev)) {
+		ret = rk_spdifrx_runtime_resume(&pdev->dev);
+		if (ret)
+			goto err_pm_runtime;
+	}
+
+	ret = devm_snd_soc_register_component(&pdev->dev,
+					      &rk_spdifrx_component,
+					      &rk_spdifrx_dai, 1);
+	if (ret) {
+		dev_err(&pdev->dev, "Could not register DAI\n");
+		goto err_pm_suspend;
+	}
+
+	ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
+	if (ret) {
+		dev_err(&pdev->dev, "Could not register PCM\n");
+		goto err_pm_suspend;
+	}
+
+	return 0;
+
+err_pm_suspend:
+	if (!pm_runtime_status_suspended(&pdev->dev))
+		rk_spdifrx_runtime_suspend(&pdev->dev);
+err_pm_runtime:
+	pm_runtime_disable(&pdev->dev);
+
+	return ret;
+}
+
+static int rk_spdifrx_remove(struct platform_device *pdev)
+{
+	pm_runtime_disable(&pdev->dev);
+	if (!pm_runtime_status_suspended(&pdev->dev))
+		rk_spdifrx_runtime_suspend(&pdev->dev);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int rockchip_spdifrx_suspend(struct device *dev)
+{
+	struct rk_spdifrx_dev *spdifrx = dev_get_drvdata(dev);
+
+	regcache_mark_dirty(spdifrx->regmap);
+
+	return 0;
+}
+
+static int rockchip_spdifrx_resume(struct device *dev)
+{
+	struct rk_spdifrx_dev *spdifrx = dev_get_drvdata(dev);
+	int ret;
+
+	ret = pm_runtime_get_sync(dev);
+	if (ret < 0)
+		return ret;
+	ret = regcache_sync(spdifrx->regmap);
+	pm_runtime_put(dev);
+
+	return ret;
+}
+#endif
+
+static const struct dev_pm_ops rk_spdifrx_pm_ops = {
+	SET_RUNTIME_PM_OPS(rk_spdifrx_runtime_suspend, rk_spdifrx_runtime_resume,
+			   NULL)
+	SET_SYSTEM_SLEEP_PM_OPS(rockchip_spdifrx_suspend, rockchip_spdifrx_resume)
+};
+
+static const struct of_device_id rk_spdifrx_match[] = {
+	{ .compatible = "rockchip,rk3308-spdifrx", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, rk_spdifrx_match);
+
+static struct platform_driver rk_spdifrx_driver = {
+	.probe = rk_spdifrx_probe,
+	.remove = rk_spdifrx_remove,
+	.driver = {
+		.name = "rockchip-spdifrx",
+		.of_match_table = of_match_ptr(rk_spdifrx_match),
+		.pm = &rk_spdifrx_pm_ops,
+	},
+};
+module_platform_driver(rk_spdifrx_driver);
+
+MODULE_ALIAS("platform:rockchip-spdifrx");
+MODULE_DESCRIPTION("ROCKCHIP SPDIFRX Controller Interface");
+MODULE_AUTHOR("Sugar Zhang <sugar.zhang@rock-chips.com>");
+MODULE_LICENSE("GPL v2");
Index: linux-5.10.27/sound/soc/rockchip/rockchip_spdifrx.h
===================================================================
--- /dev/null
+++ linux-5.10.27/sound/soc/rockchip/rockchip_spdifrx.h
@@ -0,0 +1,113 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * ALSA SoC Audio Layer - Rockchip SPDIF_RX Controller driver
+ *
+ * Copyright (C) 2018 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ */
+
+#ifndef _ROCKCHIP_SPDIFRX_H
+#define _ROCKCHIP_SPDIFRX_H
+
+/* CFGR */
+#define SPDIFRX_CFGR_TWAD_SHIFT		1
+#define SPDIFRX_CFGR_TWAD_DATA_ONLY	(0 << 1)
+#define SPDIFRX_CFGR_TWAD_STREAM	BIT(1)
+#define SPDIFRX_EN_MASK			BIT(0)
+#define SPDIFRX_EN			BIT(0)
+#define SPDIFRX_DIS			0
+
+/* CLR */
+#define SPDIFRX_CLR_RXSC		BIT(0)
+
+/* CDR */
+#define SPDIFRX_CDR_CS_MASK		GENMASK(10, 9)
+#define SPDIFRX_CDR_AVGSEL_MASK		BIT(1)
+#define SPDIFRX_CDR_AVGSEL_MIN		(0 << 1)
+#define SPDIFRX_CDR_AVGSEL_AVG		BIT(1)
+#define SPDIFRX_CDR_BYPASS_MASK		BIT(0)
+#define SPDIFRX_CDR_BYPASS_EN		BIT(0)
+#define SPDIFRX_CDR_BYPASS_DIS		0
+
+/* CDRST */
+#define SPDIFRX_CDRST_NOSTRTHR_MASK	GENMASK(31, 16)
+#define SPDIFRX_CDRST_MAXCNT_MASK	GENMASK(15, 8)
+#define SPDIFRX_CDRST_MINCNT_MASK	GENMASK(7, 0)
+
+/* DMACR */
+#define SPDIFRX_DMACR_RDE_MASK		BIT(5)
+#define SPDIFRX_DMACR_RDE_DISABLE	(0 << 5)
+#define SPDIFRX_DMACR_RDE_ENABLE	BIT(5)
+#define SPDIFRX_DMACR_RDL_MASK		GENMASK(4, 0)
+#define SPDIFRX_DMACR_RDL(x)		(((x) - 1) << 0)
+
+/* FIFOCTRL */
+#define SPDIFRX_FIFOCTRL_RFL_MASK	GENMASK(13, 8)
+#define SPDIFRX_FIFOCTRL_RFT_MASK	GENMASK(4, 0)
+
+/* INTEN */
+#define SPDIFRX_INTEN_UBCIE_MASK	BIT(10)
+#define SPDIFRX_INTEN_UBCIE_EN		BIT(10)
+#define SPDIFRX_INTEN_UBCIE_DIS		(0 << 10)
+#define SPDIFRX_INTEN_SYNCIE_MASK	BIT(9)
+#define SPDIFRX_INTEN_SYNCIE_EN		BIT(9)
+#define SPDIFRX_INTEN_SYNCIE_DIS	(0 << 9)
+#define SPDIFRX_INTEN_BTEIE_MASK	BIT(8)
+#define SPDIFRX_INTEN_BTEIE_EN		BIT(8)
+#define SPDIFRX_INTEN_BTEIE_DIS		(0 << 8)
+#define SPDIFRX_INTEN_NSYNCIE_MASK	BIT(7)
+#define SPDIFRX_INTEN_NSYNCIE_EN	BIT(7)
+#define SPDIFRX_INTEN_NSYNCIE_DIS	(0 << 7)
+
+/* INTMASK */
+#define SPDIFRX_INTMASK_UBCIMSK		BIT(10)
+#define SPDIFRX_INTMASK_UBCIUMSK	(0 << 10)
+#define SPDIFRX_INTMASK_SYNCIMSK	BIT(9)
+#define SPDIFRX_INTMASK_SYNCIUMSK	(0 << 9)
+#define SPDIFRX_INTMASK_BTEIMSK		BIT(8)
+#define SPDIFRX_INTMASK_BTEIUMSK	(0 << 8)
+#define SPDIFRX_INTMASK_NSYNCIMSK	BIT(7)
+#define SPDIFRX_INTMASK_NSYNCIUMSK	(0 << 7)
+
+/* INTSR */
+#define SPDIFRX_INTSR_UBCISR_ACTIVE	BIT(10)
+#define SPDIFRX_INTSR_SYNCISR_ACTIVE	BIT(9)
+#define SPDIFRX_INTSR_BTEISR_ACTIVE	BIT(8)
+#define SPDIFRX_INTSR_NSYNCISR_ACTIVE	BIT(7)
+
+/* INTCLR */
+#define SPDIFRX_INTCLR_UBCICLR_MASK	BIT(10)
+#define SPDIFRX_INTCLR_UBCICLR		BIT(10)
+#define SPDIFRX_INTCLR_SYNCICLR_MASK	BIT(9)
+#define SPDIFRX_INTCLR_SYNCICLR		BIT(9)
+#define SPDIFRX_INTCLR_BTECLR_MASK	BIT(8)
+#define SPDIFRX_INTCLR_BIECLR		BIT(8)
+#define SPDIFRX_INTCLR_NSYNCICLR_MASK	BIT(7)
+#define SPDIFRX_INTCLR_NSYNCICLR	BIT(7)
+
+/* BURSTINFO */
+#define SPDIFRX_BURSTINFO_PD_MASK	GENMASK(31, 16)
+#define SPDIFRX_BURSTINFO_BSNUM_MASK	GENMASK(15, 13)
+#define SPDIFRX_BURSTINFO_DATAINFO_MASK	GENMASK(12, 8)
+#define SPDIFRX_BURSTINFO_ERRFLAG_MASK	BIT(7)
+#define SPDIFRX_BURSTINFO_ERR		BIT(7)
+#define SPDIFRX_BURSTINFO_VALID		(0 << 7)
+#define SPDIFRX_BURSTINFO_DATATYPE_MASK	GENMASK(6, 0)
+
+#define SPDIFRX_VERSION			(0x0000)
+#define SPDIFRX_CFGR			(0x0004)
+#define SPDIFRX_CLR			(0x0008)
+#define SPDIFRX_CDR			(0x000c)
+#define SPDIFRX_CDRST			(0x0010)
+#define SPDIFRX_DMACR			(0x0014)
+#define SPDIFRX_FIFOCTRL		(0x0018)
+#define SPDIFRX_INTEN			(0x001C)
+#define SPDIFRX_INTMASK			(0x0020)
+#define SPDIFRX_INTSR			(0x0024)
+#define SPDIFRX_INTCLR			(0x0028)
+#define SPDIFRX_SMPDR			(0x002C)
+#define SPDIFRX_USRDRN			(0x0030)
+#define SPDIFRX_CHNSRN			(0x0060)
+#define SPDIFRX_BURSTINFO		(0x0100)
+
+#endif /* _ROCKCHIP_SPDIFRX_H */
