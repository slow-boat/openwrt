Index: linux-4.19.91/drivers/usb/host/dwc_otg/dwc_otg_cil_intr.c
===================================================================
--- linux-4.19.91.orig/drivers/usb/host/dwc_otg/dwc_otg_cil_intr.c
+++ linux-4.19.91/drivers/usb/host/dwc_otg/dwc_otg_cil_intr.c
@@ -1336,6 +1336,7 @@ static inline uint32_t dwc_otg_read_comm
 #ifdef CONFIG_USB_DWC_OTG_LPM
 	gintmsk_common.b.lpmtranrcvd = 1;
 #endif
+	unsigned long flags;
 	gintmsk_common.b.restoredone = 1;
 	if(dwc_otg_is_device_mode(core_if))
 	{
@@ -1345,8 +1346,7 @@ static inline uint32_t dwc_otg_read_comm
 		gintmsk_common.b.portintr = 1;
 	}
 	if(fiq_enable) {
-		local_fiq_disable();
-		fiq_fsm_spin_lock(&hcd->fiq_state->lock);
+		fiq_fsm_spin_lock_irqsave(&hcd->fiq_state->lock, flags);
 		gintsts.d32 = DWC_READ_REG32(&core_if->core_global_regs->gintsts);
 		gintmsk.d32 = DWC_READ_REG32(&core_if->core_global_regs->gintmsk);
 		/* Pull in the interrupts that the FIQ has masked */
@@ -1354,8 +1354,7 @@ static inline uint32_t dwc_otg_read_comm
 		gintmsk.d32 |= gintmsk_common.d32;
 		/* for the upstairs function to reenable - have to read it here in case FIQ triggers again */
 		reenable_gintmsk->d32 = gintmsk.d32;
-		fiq_fsm_spin_unlock(&hcd->fiq_state->lock);
-		local_fiq_enable();
+		fiq_fsm_spin_unlock_irqrestore(&hcd->fiq_state->lock, flags);
 	} else {
 		gintsts.d32 = DWC_READ_REG32(&core_if->core_global_regs->gintsts);
 		gintmsk.d32 = DWC_READ_REG32(&core_if->core_global_regs->gintmsk);
Index: linux-4.19.91/drivers/usb/host/dwc_otg/dwc_otg_hcd.c
===================================================================
--- linux-4.19.91.orig/drivers/usb/host/dwc_otg/dwc_otg_hcd.c
+++ linux-4.19.91/drivers/usb/host/dwc_otg/dwc_otg_hcd.c
@@ -175,6 +175,7 @@ static void kill_urbs_in_qh_list(dwc_otg
 	dwc_list_link_t *qh_item, *qh_tmp;
 	dwc_otg_qh_t *qh;
 	dwc_otg_qtd_t *qtd, *qtd_tmp;
+	unsigned long flags;
 
 	DWC_LIST_FOREACH_SAFE(qh_item, qh_tmp, qh_list) {
 		qh = DWC_LIST_ENTRY(qh_item, dwc_otg_qh_t, qh_list_entry);
@@ -195,11 +196,13 @@ static void kill_urbs_in_qh_list(dwc_otg
 			 * but not yet been through the IRQ handler.
 			 */
 			if (fiq_fsm_enable && (hcd->fiq_state->channel[qh->channel->hc_num].fsm != FIQ_PASSTHROUGH)) {
+				fiq_fsm_spin_lock_irqsave(&hcd->fiq_state->lock, flags);
 				qh->channel->halt_status = DWC_OTG_HC_XFER_URB_DEQUEUE;
 				qh->channel->halt_pending = 1;
 				if (hcd->fiq_state->channel[n].fsm == FIQ_HS_ISOC_TURBO ||
 					hcd->fiq_state->channel[n].fsm == FIQ_HS_ISOC_SLEEPING)
 					hcd->fiq_state->channel[n].fsm = FIQ_HS_ISOC_ABORTED;
+				fiq_fsm_spin_unlock_irqrestore(&hcd->fiq_state->lock, flags);
 			} else {
 				dwc_otg_hc_halt(hcd->core_if, qh->channel,
 						DWC_OTG_HC_XFER_URB_DEQUEUE);
@@ -289,6 +292,7 @@ static int32_t dwc_otg_hcd_start_cb(void
  */
 static int32_t dwc_otg_hcd_disconnect_cb(void *p)
 {
+	unsigned long flags;
 	gintsts_data_t intr;
 	dwc_otg_hcd_t *dwc_otg_hcd = p;
 
@@ -298,10 +302,8 @@ static int32_t dwc_otg_hcd_disconnect_cb
 	 */
 	dwc_otg_hcd->flags.b.port_connect_status_change = 1;
 	dwc_otg_hcd->flags.b.port_connect_status = 0;
-	if(fiq_enable) {
-		local_fiq_disable();
-		fiq_fsm_spin_lock(&dwc_otg_hcd->fiq_state->lock);
-	}
+	if(fiq_enable)
+		fiq_fsm_spin_lock_irqsave(&dwc_otg_hcd->fiq_state->lock, flags);
 	/*
 	 * Shutdown any transfers in process by clearing the Tx FIFO Empty
 	 * interrupt mask and status bits and disabling subsequent host
@@ -378,14 +380,11 @@ static int32_t dwc_otg_hcd_disconnect_cb
 		}
 	}
 
-	if(fiq_enable) {
-		fiq_fsm_spin_unlock(&dwc_otg_hcd->fiq_state->lock);
-		local_fiq_enable();
-	}
+	if(fiq_enable)
+		fiq_fsm_spin_unlock_irqrestore(&dwc_otg_hcd->fiq_state->lock, flags);
 
-	if (dwc_otg_hcd->fops->disconnect) {
+	if (dwc_otg_hcd->fops->disconnect)
 		dwc_otg_hcd->fops->disconnect(dwc_otg_hcd);
-	}
 
 	DWC_SPINUNLOCK(dwc_otg_hcd->lock);
 	return 1;
@@ -546,6 +545,7 @@ int dwc_otg_hcd_urb_dequeue(dwc_otg_hcd_
 {
 	dwc_otg_qh_t *qh;
 	dwc_otg_qtd_t *urb_qtd;
+	unsigned long flags;
 	BUG_ON(!hcd);
 	BUG_ON(!dwc_otg_urb);
 
@@ -600,15 +600,13 @@ int dwc_otg_hcd_urb_dequeue(dwc_otg_hcd_
 			/* In FIQ FSM mode, we need to shut down carefully.
 			 * The FIQ may attempt to restart a disabled channel */
 			if (fiq_fsm_enable && (hcd->fiq_state->channel[n].fsm != FIQ_PASSTHROUGH)) {
-				local_fiq_disable();
-				fiq_fsm_spin_lock(&hcd->fiq_state->lock);
+				fiq_fsm_spin_lock_irqsave(&hcd->fiq_state->lock, flags);
 				qh->channel->halt_status = DWC_OTG_HC_XFER_URB_DEQUEUE;
 				qh->channel->halt_pending = 1;
 				if (hcd->fiq_state->channel[n].fsm == FIQ_HS_ISOC_TURBO ||
 					hcd->fiq_state->channel[n].fsm == FIQ_HS_ISOC_SLEEPING)
 					hcd->fiq_state->channel[n].fsm = FIQ_HS_ISOC_ABORTED;
-				fiq_fsm_spin_unlock(&hcd->fiq_state->lock);
-				local_fiq_enable();
+				fiq_fsm_spin_unlock_irqrestore(&hcd->fiq_state->lock, flags);
 			} else {
 				dwc_otg_hc_halt(hcd->core_if, qh->channel,
 						DWC_OTG_HC_XFER_URB_DEQUEUE);
@@ -1431,7 +1429,6 @@ static void assign_and_init_hc(dwc_otg_h
 
 	dwc_otg_hc_init(hcd->core_if, hc);
 
-
 	if (fiq_enable)
 		fiq_fsm_spin_lock_irqsave(&hcd->fiq_state->lock, flags);
 	else
@@ -1449,6 +1446,7 @@ static void assign_and_init_hc(dwc_otg_h
 		fiq_fsm_spin_unlock_irqrestore(&hcd->fiq_state->lock, flags);
 	else
 		local_irq_restore(flags);
+
 	hc->qh = qh;
 }
 
Index: linux-4.19.91/drivers/irqchip/irq-bcm2835.c
===================================================================
--- linux-4.19.91.orig/drivers/irqchip/irq-bcm2835.c
+++ linux-4.19.91/drivers/irqchip/irq-bcm2835.c
@@ -78,6 +78,7 @@
 #define REG_FIQ_CONTROL		0x0c
 #define REG_FIQ_ENABLE		0x80
 #define REG_FIQ_DISABLE		0
+#define FIQ_CONTROL_ENABLE	BIT(7)
 
 #define NR_BANKS		3
 #define IRQS_PER_BANK		32
@@ -210,6 +211,7 @@ static int __init armctrl_of_init(struct
 {
 	void __iomem *base;
 	int irq = 0, last_irq, b, i;
+	u32 reg;
 
 	base = of_iomap(node, 0);
 	if (!base)
@@ -233,6 +235,19 @@ static int __init armctrl_of_init(struct
 				handle_level_irq);
 			irq_set_probe(irq);
 		}
+
+		reg = readl_relaxed(intc.enable[b]);
+		if (reg) {
+			writel_relaxed(reg, intc.disable[b]);
+			pr_err(FW_BUG "Bootloader left irq enabled: "
+			       "bank %d irq %*pbl\n", b, IRQS_PER_BANK, &reg);
+		}
+	}
+
+	reg = readl_relaxed(base + REG_FIQ_CONTROL);
+	if (reg & FIQ_CONTROL_ENABLE) {
+		writel_relaxed(0, base + REG_FIQ_CONTROL);
+		pr_err(FW_BUG "Bootloader left fiq enabled\n");
 	}
 
 	last_irq = irq;
